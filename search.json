[{"title":"内存溢出常见场景","url":"http://www.shenjian.online/2020/03/12/内存溢出常见场景/","content":"<p>内存溢出分为两大类：OutOfMemoryError和StackOverflowError</p>\n<h3 id=\"1-java堆内存溢出\"><a href=\"#1-java堆内存溢出\" class=\"headerlink\" title=\"1. java堆内存溢出\"></a>1. java堆内存溢出</h3><p>当出现java.lang.OutOfMemeoryError:Java heap space异常时，就是堆内存溢出了  </p>\n<p>问题描述：  </p>\n<ol>\n<li>设置的JVM内存太小，对象所需内存过大，创建对象时分配空间，就会抛出这个异常    </li>\n<li>流量/数据峰值超过预期阈值时  </li>\n</ol>\n<p>示例代码: 执行时jvm参数设置为-Xms20m -Xmx20m<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HeapOomError</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;<span class=\"keyword\">byte</span>[]&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            list.add(<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">5</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果：<br><img src=\"/2020/03/12/内存溢出常见场景/HeapOomError.png\" alt=\"HeapOomError\"></p>\n<p>解决方法：  </p>\n<ol>\n<li>如果没有什么问题，可以适当调整-Xms -Xmx参数，压测调整到最优值</li>\n<li>尽量避免大对象申请，像文件上传、大批量从数据库读取，尽量分块或者分批处理  </li>\n</ol>\n<h3 id=\"2-java堆内存泄漏\"><a href=\"#2-java堆内存泄漏\" class=\"headerlink\" title=\"2. java堆内存泄漏\"></a>2. java堆内存泄漏</h3><p>问题描述：<br>内存泄漏是一些对象不再被应用程序使用，但是垃圾收集器无法识别的情况  </p>\n<p>示例代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemoryLeakOomError</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Map map = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">                Key key = <span class=\"keyword\">new</span> Key(i);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!map.containsKey(key)) &#123;</span><br><span class=\"line\">                    map.put(key, i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(map.size());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Key</span> </span>&#123;</span><br><span class=\"line\">    Integer id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Key</span><span class=\"params\">(Integer id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果：<br><img src=\"/2020/03/12/内存溢出常见场景/MemoryLeakOomError.png\" alt=\"MemoryLeakOomError\"></p>\n<p>解决方法：<br>重写hashCode()、equals()方法即可<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Key</span> </span>&#123;</span><br><span class=\"line\">    Integer id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Key</span><span class=\"params\">(Integer id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> id.hashCode();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> res = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> Key) &#123;</span><br><span class=\"line\">            res = ((Key)obj).id.equals(<span class=\"keyword\">this</span>.id);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-垃圾回收超时内存溢出\"><a href=\"#3-垃圾回收超时内存溢出\" class=\"headerlink\" title=\"3. 垃圾回收超时内存溢出\"></a>3. 垃圾回收超时内存溢出</h3><p>问题描述：<br>默认JVM配置GC的时间超过98%，回收堆内存低于2%  </p>\n<p>示例代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OverheadLimitOomError</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Map map = System.getProperties();</span><br><span class=\"line\">        Random r = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            map.put(r.nextInt(), <span class=\"string\">\"Hello World\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果：<br><a href=\"内存溢出常见场景/OverheadLimitOomError.png\">OverheadLimitOomError</a></p>\n<p>解决方法：<br>减少对象生命周期，尽量能快速的进行垃圾回收<br>-XX:-UseGCOverheadLimit取消GC开销限制</p>\n<h3 id=\"4-Metaspace内存溢出\"><a href=\"#4-Metaspace内存溢出\" class=\"headerlink\" title=\"4. Metaspace内存溢出\"></a>4. Metaspace内存溢出</h3><p>问题描述：<br>元空间的溢出，系统会抛出java.lang.OutofMemoryError:Metaspace,出现这个问题是系统引用第三方包或者动态代码生成类加载等，导致元空间溢出  </p>\n<p>示例代码: 执行时设置参数-XX:MaxMetaspaceSize=6m -XX:+PrintGCDetails<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getUsername</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUsername</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Domi\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserInvocationHandler</span><span class=\"params\">(Object target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> method.invoke(target, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MetaspaceOomError</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Map&lt;Integer, UserService&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(); <span class=\"comment\">// 静态属性引用的对象存在于元空间</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> MalformedURLException </span>&#123;</span><br><span class=\"line\">        ClassLoadingMXBean loadingMXBean = ManagementFactory.getClassLoadingMXBean();</span><br><span class=\"line\">        LongAdder longAdder = <span class=\"keyword\">new</span> LongAdder();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            URL[] urls = <span class=\"keyword\">new</span> URL[] &#123; <span class=\"keyword\">new</span> URL(<span class=\"string\">\"file:\"</span> + longAdder.intValue() + <span class=\"string\">\".jar\"</span>) &#125;;</span><br><span class=\"line\">            URLClassLoader urlClassLoader = <span class=\"keyword\">new</span> URLClassLoader(urls); <span class=\"comment\">// 关键在于每次创建新的classloader</span></span><br><span class=\"line\">            UserService userService = <span class=\"keyword\">new</span> UserServiceImpl();</span><br><span class=\"line\">            <span class=\"comment\">// 若把urlClassLoader参数改为userService.getClass().getClassLoader()则不会出现元空间溢出情况</span></span><br><span class=\"line\">            UserService proxy = (UserService) Proxy.newProxyInstance(urlClassLoader, </span><br><span class=\"line\">                    userService.getClass().getInterfaces(), <span class=\"keyword\">new</span> UserInvocationHandler(userService));</span><br><span class=\"line\">                    userService.getClass().getInterfaces(), <span class=\"keyword\">new</span> UserInvocationHandler(userService));</span><br><span class=\"line\">            map.put(longAdder.intValue(), proxy);</span><br><span class=\"line\">            longAdder.increment();</span><br><span class=\"line\">            System.out.print(<span class=\"string\">\"total: \"</span> + loadingMXBean.getTotalLoadedClassCount() +</span><br><span class=\"line\">                            <span class=\"string\">\" loaded: \"</span> + loadingMXBean.getLoadedClassCount() +</span><br><span class=\"line\">                            <span class=\"string\">\" unloaded: \"</span> + loadingMXBean.getUnloadedClassCount() +</span><br><span class=\"line\">                            <span class=\"string\">\" map size:\"</span> + map.size() + <span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：<br><img src=\"/2020/03/12/内存溢出常见场景/MetaspaceOomError.png\" alt=\"MetaspaceOomError\"></p>\n<p>解决方法：<br>默认情况下，元空间大小仅受本地内存的影响<br>1）优化-XX:MetaspaceSize、-XX:MaxMetaspaceSize<br>2）慎重引用第三方包<br>3）关注动态生成类的框架  </p>\n<h3 id=\"5-直接内存溢出\"><a href=\"#5-直接内存溢出\" class=\"headerlink\" title=\"5. 直接内存溢出\"></a>5. 直接内存溢出</h3><p>问题描述：<br>直接内存溢出，系统抛出java.lang.OutOfMemoryError: Direct buffer memory。<br>如果直接或间接使用了ByteBuffer#allocateDirect方法的时候，而不做clear的时候就会出现类似的问题   </p>\n<p>示例代码：-XX:+PrintGCDetails -XX:MaxDirectMemorySize=10M<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DirectoryMemoryOomError</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIZE = <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Map&lt;String, ByteBuffer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            ByteBuffer buffer = ByteBuffer.allocateDirect(SIZE);</span><br><span class=\"line\">            map.put(<span class=\"string\">\" \"</span> + (i++), buffer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">执行结果：  </span><br><span class=\"line\">![DirectoryMemoryOomError](内存溢出常见场景/DirectoryMemoryOomError.png)</span><br><span class=\"line\"></span><br><span class=\"line\">解决方法：  </span><br><span class=\"line\">可以考虑设置参数：-XX:MaxDirectMemorySize，并及时clear内存</span><br><span class=\"line\"></span><br><span class=\"line\">### 6. 栈内存溢出</span><br><span class=\"line\"></span><br><span class=\"line\">问题描述：  </span><br><span class=\"line\">栈内存溢出时，会抛出java.lang.StackOverflowError。方法的每一次调用都会产生一个栈帧，当递归调用自己死递归时，栈内存溢出。</span><br><span class=\"line\"></span><br><span class=\"line\">示例代码：  </span><br><span class=\"line\">```java</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StackOomError</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.call();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        StackOomError stackOomError = <span class=\"keyword\">new</span> StackOomError();</span><br><span class=\"line\">        stackOomError.call();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果:<br><img src=\"/2020/03/12/内存溢出常见场景/StackOomError.png\" alt=\"StackOomError\"></p>\n<p>解决方法：<br>程序中确实存在递归，可适当调大-Xss的大小，同时也要防止死递归</p>\n<h3 id=\"7-创建本地线程内存溢出\"><a href=\"#7-创建本地线程内存溢出\" class=\"headerlink\" title=\"7. 创建本地线程内存溢出\"></a>7. 创建本地线程内存溢出</h3><p>问题描述：<br>线程基本占了heao以外的内存区域，要么时内存本身不够，要么heap空间设置的过大  </p>\n<p>示例代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UnableCreateNativeThreadError</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            Executor executor = Executors.newCachedThreadPool();</span><br><span class=\"line\">            executor.execute(() -&gt; &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"Hello World!\"</span>);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果:<br><img src=\"/2020/03/12/内存溢出常见场景/UnableCreateNativeThreadError.png\" alt=\"UnableCreateNativeThreadError\"></p>\n<p>解决方法：<br>尽量保证线程最大数可控制，不要随意用线程池<br>减少堆空间<br>修改操作系统级别的限制：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ulimit -a # 查看配置</span><br><span class=\"line\">ulimit -u 1800 # 增大用户最大进程数</span><br><span class=\"line\">ulimit -n 4096 # 增大每个进程可打开的最大文件数</span><br></pre></td></tr></table></figure></p>\n<p>减小-Xss栈空间</p>\n<h3 id=\"8-超出交换区内存溢出\"><a href=\"#8-超出交换区内存溢出\" class=\"headerlink\" title=\"8. 超出交换区内存溢出\"></a>8. 超出交换区内存溢出</h3><p>问题描述：<br>当JVM请求的总内存大于可用物理内存的时候，操作系统开始将数据从内存交换到硬盘  </p>\n<p>解决方法：<br>增加系统交换区的大小，但是性能会大大降低，生产环境避免最大内存超过系统物理内存，<br>其次，去掉系统交换区<code>echo &quot;vm.swappiness = 0&quot; &gt;&gt; /etc/sysctl.conf</code></p>\n<h3 id=\"9-数组超限内存溢出\"><a href=\"#9-数组超限内存溢出\" class=\"headerlink\" title=\"9. 数组超限内存溢出\"></a>9. 数组超限内存溢出</h3><p>问题描述：<br>数组超限内存溢出,系统报java.lang.OutOfMemoryError: Requested array size exceeds VM limit，数组分配长度要在平台允许范围之内</p>\n<p>示例代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayLimitOomError</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[Integer.MAX_VALUE - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果：<br><img src=\"/2020/03/12/内存溢出常见场景/ArrayLimitOomError.png\" alt=\"ArrayLimitOomError\"></p>\n<p>解决方法：<br>数组长度要在平台允许的长度范围之内,比如Integer.MAX_VALUE - 2  </p>\n<h3 id=\"10-系统杀死进程内存溢出\"><a href=\"#10-系统杀死进程内存溢出\" class=\"headerlink\" title=\"10. 系统杀死进程内存溢出\"></a>10. 系统杀死进程内存溢出</h3><p>进程在内核中作业，其中有个特殊的进程，称为“内存杀手”。当内核检测到系统内存不足时，OOM killer被激活，检查当前谁占用内存最大就杀死谁  </p>\n<p>解决方法：<br>增加系统内存  </p>\n<p>参考：<a href=\"https://segmentfault.com/a/1190000017226359\" target=\"_blank\" rel=\"noopener\">十种JVM内存溢出的情况，你碰到过几种？</a><br>多次面试题目</p>\n","categories":["JVM"],"tags":["JVM"]},{"title":"55_跳跃游戏_leetcode","url":"http://www.shenjian.online/2020/03/09/55-跳跃游戏-leetcode/","content":"<p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置。</p>\n<blockquote>\n<p>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p>\n</blockquote>\n<p><strong>题解：</strong> 动态规划</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canJump</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxPosition = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前位置大于可跳最远位置，则跳不到</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; maxPosition) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 更新可跳最远位置</span></span><br><span class=\"line\">            maxPosition = Math.max(maxPosition, nums[i] + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/jump-game/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"单字段字符串分割由一行改为多行","url":"http://www.shenjian.online/2020/03/09/单字段内容根据分割符分离为多行/","content":"<h3 id=\"1-项目需求\"><a href=\"#1-项目需求\" class=\"headerlink\" title=\"1. 项目需求\"></a>1. 项目需求</h3><p>虚拟核销中，若起草人离职，则已办视图项目客户专员无法查看，故需新增虚拟核销项目对应客户专员查看权限。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">ID</span>,PROJECTNO, CREATOR <span class=\"keyword\">FROM</span> FORM_MADJ_ACCOUNT <span class=\"keyword\">WHERE</span> <span class=\"keyword\">ID</span> <span class=\"keyword\">IN</span>(<span class=\"string\">'8cfa11ee-6ef4-448a-b75b-d7c99c96a76b'</span>, <span class=\"string\">'bf7ca28c-6d97-48b7-ad6e-a7398b5a11e4'</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2020/03/09/单字段内容根据分割符分离为多行/1.png\" alt=\"1\"></p>\n<p>可见，项目中存在多项目编号，|分割，故首先分离项目</p>\n<h3 id=\"2-开始分离\"><a href=\"#2-开始分离\" class=\"headerlink\" title=\"2. 开始分离\"></a>2. 开始分离</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span></span><br><span class=\"line\">\t<span class=\"keyword\">ID</span>,</span><br><span class=\"line\">\tREGEXP_SUBSTR( PROJECTNO, <span class=\"string\">'[^|]+'</span>, <span class=\"number\">1</span>, <span class=\"keyword\">LEVEL</span> ) <span class=\"keyword\">AS</span> PROJECTNO <span class=\"comment\">-- 搜索正则匹配的串</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">\tYDAMS.FORM_MADJ_ACCOUNT </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"keyword\">ID</span>=<span class=\"string\">'8cfa11ee-6ef4-448a-b75b-d7c99c96a76b'</span></span><br><span class=\"line\">\t<span class=\"keyword\">CONNECT</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">LEVEL</span> &lt;= REGEXP_COUNT ( PROJECTNO, <span class=\"string\">'|'</span> ) + <span class=\"number\">1</span>  <span class=\"comment\">-- level关键字，代表树形结构中的层级编号</span></span><br><span class=\"line\">\t<span class=\"keyword\">AND</span> <span class=\"keyword\">ID</span> = <span class=\"keyword\">PRIOR</span> <span class=\"keyword\">ID</span>  <span class=\"comment\">-- 主键ID 表示从下往上查找数据，可以理解为从叶子节点往上查找父级节点点</span></span><br><span class=\"line\">\t<span class=\"keyword\">AND</span> <span class=\"keyword\">PRIOR</span> DBMS_RANDOM.VALUE <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"comment\">--该句不变</span></span><br></pre></td></tr></table></figure>\n<p>分离为多行结果：</p>\n<p><img src=\"/2020/03/09/单字段内容根据分割符分离为多行/2.png\" alt=\"2\"></p>\n<h3 id=\"3-注意事项\"><a href=\"#3-注意事项\" class=\"headerlink\" title=\"3. 注意事项\"></a>3. 注意事项</h3><p>由于在子查询中ID无法使用外部别名ID,故采用左连接查询方式<br>注：项目表中存在项目客户专员信息</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> <span class=\"keyword\">id</span> <span class=\"keyword\">FROM</span> table_name <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"built_in\">number</span> <span class=\"keyword\">DESC</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--- 运行时往往会报错。因为在order by中出现的number没有在select distinct中出现，所以正确的写法应该是 </span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> <span class=\"keyword\">id</span> ,<span class=\"built_in\">number</span> <span class=\"keyword\">FROM</span> table_name <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"built_in\">number</span> <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-最终SQL语句\"><a href=\"#4-最终SQL语句\" class=\"headerlink\" title=\"4.最终SQL语句\"></a>4.最终SQL语句</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">\t<span class=\"keyword\">DISTINCT</span> FMA.ID, </span><br><span class=\"line\">\tFMA.PROJECTNO,</span><br><span class=\"line\">\tto_char(fma.create_date,<span class=\"string\">'yyyy-mm-dd hh24:mi:ss'</span>) <span class=\"keyword\">as</span> create_date,</span><br><span class=\"line\">\tFMA.CREATE_DATE CREATE_DATE2 <span class=\"comment\">-- 注意这个在ORDER BY中存在，必须写否则会报错</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">\tFORM_MADJ_ACCOUNT FMA</span><br><span class=\"line\">\t<span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> sys_user SU <span class=\"keyword\">ON</span> FMA.CREATOR = SU.ID</span><br><span class=\"line\">\t<span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> (</span><br><span class=\"line\">\t\t<span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">ID</span>,</span><br><span class=\"line\">\t\t\tREGEXP_SUBSTR( PROJECTNO, <span class=\"string\">'[^|]+'</span>, <span class=\"number\">1</span>, <span class=\"keyword\">LEVEL</span> ) <span class=\"keyword\">AS</span> PROJECTNO </span><br><span class=\"line\">\t\t<span class=\"keyword\">FROM</span></span><br><span class=\"line\">\t\t\tYDAMS.FORM_MADJ_ACCOUNT <span class=\"keyword\">CONNECT</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">LEVEL</span> &lt;= REGEXP_COUNT ( PROJECTNO, <span class=\"string\">'|'</span> ) + <span class=\"number\">1</span> </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">AND</span> <span class=\"keyword\">ID</span> = <span class=\"keyword\">PRIOR</span> <span class=\"keyword\">ID</span> </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">AND</span> <span class=\"keyword\">PRIOR</span> DBMS_RANDOM.VALUE <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> </span><br><span class=\"line\">\t\t) PSI <span class=\"keyword\">ON</span> FMA.ID = PSI.ID</span><br><span class=\"line\">\t<span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> PROJ_INFO <span class=\"keyword\">pi</span> <span class=\"keyword\">ON</span> pi.PROJECTNO = PSI.PROJECTNO </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">\tFMA.STATUS = <span class=\"number\">1</span> </span><br><span class=\"line\">\t<span class=\"keyword\">AND</span> (SU.LOGINNAME = <span class=\"string\">'XXX'</span> <span class=\"keyword\">OR</span> PI.PROJECT_MANAGER_ID = <span class=\"string\">'08BA5F8B2CC4FC29E05010ACB550646D'</span> ) </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span></span><br><span class=\"line\">\tFMA.CREATE_DATE <span class=\"keyword\">DESC</span></span><br></pre></td></tr></table></figure>","categories":["Oracle","工作干货"],"tags":["工作干货","Oracle"]},{"title":"54_螺旋矩阵_leetcode","url":"http://www.shenjian.online/2020/02/29/54-螺旋矩阵-leetcode/","content":"<p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>\n<blockquote>\n<p>输入:<br>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]<br>输出: [1,2,3,6,9,8,7,4,5]</p>\n</blockquote>\n<p><strong>题解：</strong> 纯代码模拟，见代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">spiralOrder</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] matrix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;Integer&gt; ans = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(matrix.length * matrix[<span class=\"number\">0</span>].length);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r1 = <span class=\"number\">0</span>, r2 = matrix.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c1 = <span class=\"number\">0</span>, c2 = matrix[<span class=\"number\">0</span>].length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (r1 &lt;= r2 &amp;&amp; c1 &lt;= c2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> c = c1; c &lt;= c2; c++) &#123;</span><br><span class=\"line\">                ans.add(matrix[r1][c]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> r = r1 + <span class=\"number\">1</span>; r &lt;= r2; r++) &#123;</span><br><span class=\"line\">                ans.add(matrix[r][c2]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r1 &lt; r2 &amp;&amp; c1 &lt; c2) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> c = c2 - <span class=\"number\">1</span>; c &gt; c1; c--) &#123;</span><br><span class=\"line\">                    ans.add(matrix[r2][c]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> r = r2; r &gt; r1; r--) &#123;</span><br><span class=\"line\">                    ans.add(matrix[r][c1]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            r1++;</span><br><span class=\"line\">            r2--;</span><br><span class=\"line\">            c1++;</span><br><span class=\"line\">            c2--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/spiral-matrix/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"53_最大子序和_leetcode","url":"http://www.shenjian.online/2020/02/28/53-最大子序和-leetcode/","content":"<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n<blockquote>\n<p>示例:<br>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br>进阶:</p>\n</blockquote>\n<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>\n<p><strong>题解：</strong> 动态规划</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 对于当前数num之前数的组合而言，从左到右遍历所得当前最大值为sum</span></span><br><span class=\"line\">            <span class=\"comment\">// 若sum &gt; 0, 则sum + num &gt; num,更新sum=sum+num</span></span><br><span class=\"line\">            <span class=\"comment\">// 若sum &lt;= 0,则sum + num &lt;= num,更新sum=num</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                sum += num;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                sum = num;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 更新遍历中所得最大值</span></span><br><span class=\"line\">            res = Math.max(res, sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/maximum-subarray/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"微服务面试篇","url":"http://www.shenjian.online/2020/02/13/微服务面试篇/","content":"<h3 id=\"1-什么是微服务\"><a href=\"#1-什么是微服务\" class=\"headerlink\" title=\"1. 什么是微服务\"></a>1. 什么是微服务</h3><p>微服务架构它提倡将单一应用程序划分一组小的服务，每个服务运行在独立的进程中，服务之间相互协调、互相配合。<br>服务之间采用轻量级的通信机制互相沟通(通常是基于HTTP的RESTful API),每个服务围绕着具体的业务进行构建。  </p>\n<h3 id=\"2-SpringBoot与SpringCloud-谈谈你对他们的理解\"><a href=\"#2-SpringBoot与SpringCloud-谈谈你对他们的理解\" class=\"headerlink\" title=\"2. SpringBoot与SpringCloud,谈谈你对他们的理解\"></a>2. SpringBoot与SpringCloud,谈谈你对他们的理解</h3><p>1）SpringBoot专注于快速方便的开发单个个体微服务<br>2）SpringCloud是关注全局的微服务协调、整理、治理的框架，它将SpringBoot开发的单体整合并管理起来<br>3）SpringBoot不依赖于SpringCloud可独立使用开发项目，SpringCloud依赖于SpringBoot  </p>\n<h3 id=\"3-微服务的优缺点\"><a href=\"#3-微服务的优缺点\" class=\"headerlink\" title=\"3. 微服务的优缺点\"></a>3. 微服务的优缺点</h3><p>优点：  </p>\n<ul>\n<li>每个服务足够内聚，足够小，代码容易理解这样能聚焦一个指定业务功能或业务需求  </li>\n<li>开发简单，开发效率提高，一个服务可能就是专一的只干一件事</li>\n<li>微服务能够被小团队开发，这个团队可以是2-5个开发人员组成</li>\n<li>微服务是松耦合的，是有功能意义的服务，无论在开发阶段还是部署阶段都是独立的</li>\n<li>微服务能够使用不同的语言开发</li>\n<li>每个微服务都有自己的存储能力，可以有自己的数据库</li>\n</ul>\n<p>缺点：  </p>\n<ul>\n<li>开发人员要处理分布式系统的复杂性</li>\n<li>多服务运维难度，随着服务的增加，运维的难度也在增加</li>\n<li>系统部署依赖</li>\n<li>服务间通讯成本</li>\n<li>数据一致性</li>\n<li>系统集成测试</li>\n<li>性能监控</li>\n</ul>\n","categories":["微服务"],"tags":["面试","微服务"]},{"title":"Kafka基本原理及常见问题","url":"http://www.shenjian.online/2020/02/13/Kafka基本原理及常见问题/","content":"<h3 id=\"1-基本原理\"><a href=\"#1-基本原理\" class=\"headerlink\" title=\"1. 基本原理\"></a>1. 基本原理</h3><h3 id=\"2-使用场景\"><a href=\"#2-使用场景\" class=\"headerlink\" title=\"2. 使用场景\"></a>2. 使用场景</h3><ul>\n<li>异步处理： 将一些实时性要求不是很强的业务进行异步处理</li>\n<li>解耦： 消息队列将消息生产与订阅分离，可以实现应用解耦</li>\n<li>削峰： 常用于秒杀，在应用前端以消息队列接收请求来达到削峰的目的。请求超过队列长度直接不处理重定向错误页面</li>\n<li>提速： 消息队列应用下，消息生产应用只管生产，不需要等待消费就可以处理其他事情，实际上起到了提速的作用</li>\n</ul>\n<h3 id=\"3-丢消息常见解决方法\"><a href=\"#3-丢消息常见解决方法\" class=\"headerlink\" title=\"3. 丢消息常见解决方法\"></a>3. 丢消息常见解决方法</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acks = all <span class=\"comment\"># 所有副本接收成功消息才算发送成功</span></span><br><span class=\"line\">retries = 300 <span class=\"comment\"># 重试时间间隔(可适当调整，防止磁盘卡顿，网络中断超过)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># producer异步发送消息，当broker返回异常信息时并不会抛出异常</span></span><br><span class=\"line\"><span class=\"comment\"># 此时考虑单条数据大小的问题 kafka.common.MessageSizeTooLargeException</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Consumer side: this will determine the largest size of a message that can be fetched by the consumer</span></span><br><span class=\"line\">fetch.message.max.bytes</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Broker side: this will allow for the replicas in the brokers to send messages within the cluster and make sure the messages are replicated correctly. If this is too small, then the message will never be replicated, and therefore, the consumer will never see the message because the message will never be committed (fully replicated)</span></span><br><span class=\"line\">replica.fetch.max.bytes </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Broker side: this is the largest size of the message that can be received by the broker from a producer</span></span><br><span class=\"line\">message.max.bytes</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Broker side(per topic): this is the largest size of the message the broker will allow to be appended to the topic. This size is validated pre-compression. (Defaults to broker'smessage.max.bytes.)</span></span><br><span class=\"line\">max.message.bytes</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-重复消费原因及解决办法\"><a href=\"#4-重复消费原因及解决办法\" class=\"headerlink\" title=\"4. 重复消费原因及解决办法\"></a>4. 重复消费原因及解决办法</h3><p>使用kafka时，消费者每次poll的数据业务处理时间超过kafka的max.poll.interval.ms,默认300秒，导致kafka的broker认为consumer挂掉，触发kafka进行rebalance，导致重新消费<br>增加rebalance listener即可，发生rebalance前提交offset    </p>\n<h3 id=\"5-常用消息队列及优缺点-瀚途面试题\"><a href=\"#5-常用消息队列及优缺点-瀚途面试题\" class=\"headerlink\" title=\"5. 常用消息队列及优缺点[瀚途面试题]\"></a>5. 常用消息队列及优缺点[瀚途面试题]</h3><p>当前使用较多的消息队列有RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMQ等，而部分数据库如Redis、Mysql也可以实现消息队列的功能  </p>\n","categories":["Kafka"],"tags":["Kafka"]},{"title":"Oracle与Mysql的区别","url":"http://www.shenjian.online/2020/02/12/Oracle与Mysql的区别/","content":"<h3 id=\"1-并发性\"><a href=\"#1-并发性\" class=\"headerlink\" title=\"1. 并发性\"></a>1. 并发性</h3><p>oracle对并发性的支持要好的多。  </p>\n<ul>\n<li>mysql以表级锁为主，对InnoDB引擎的表可以使用行级锁，但是依赖于表的索引</li>\n<li>oracle使用行级锁，锁的粒度小，不依赖于索引</li>\n</ul>\n<h3 id=\"2-一致性\"><a href=\"#2-一致性\" class=\"headerlink\" title=\"2. 一致性\"></a>2. 一致性</h3><ul>\n<li>oracle支持serializable的隔离级别，通过在undo表空间中构造多版本数据块来实现读一致性 </li>\n<li>mysql没有构造多版本块的机制，只支持read committed隔离级别</li>\n</ul>\n<h3 id=\"3-事务\"><a href=\"#3-事务\" class=\"headerlink\" title=\"3. 事务\"></a>3. 事务</h3><ul>\n<li>oracle很早就支持事务</li>\n<li>mysql在innoDB存储引擎的行级锁的情况才支持事务</li>\n</ul>\n<h3 id=\"4-数据持久性\"><a href=\"#4-数据持久性\" class=\"headerlink\" title=\"4. 数据持久性\"></a>4. 数据持久性</h3><ul>\n<li>oracle保证提交的数据均可恢复</li>\n<li>mysql可能会丢失数据</li>\n</ul>\n<h3 id=\"5-提交方式\"><a href=\"#5-提交方式\" class=\"headerlink\" title=\"5. 提交方式\"></a>5. 提交方式</h3><ul>\n<li>oracle默认不自动提交，需用户手动提交</li>\n<li>mysql默认自动提交</li>\n</ul>\n<h3 id=\"6-逻辑备份\"><a href=\"#6-逻辑备份\" class=\"headerlink\" title=\"6. 逻辑备份\"></a>6. 逻辑备份</h3><ul>\n<li>oracle逻辑备份不锁定数据，且备份的数据是一致的</li>\n<li>mysql逻辑备份时要锁定数据，才能保证备份的数据是一致的</li>\n</ul>\n<h3 id=\"7-热备份\"><a href=\"#7-热备份\" class=\"headerlink\" title=\"7. 热备份\"></a>7. 热备份</h3><ul>\n<li>oracle有成熟的热备工具rman</li>\n<li>mysql innoDB的引擎，它会备份表和索引，但是不会备份.frm文件</li>\n</ul>\n<h3 id=\"8-复制\"><a href=\"#8-复制\" class=\"headerlink\" title=\"8. 复制\"></a>8. 复制</h3><ul>\n<li>oracle主库出现问题时，可以自动切换到从库，但是配置较复杂</li>\n<li>mysql主库出现问题时，需要手动切换从库到主库</li>\n</ul>\n<h3 id=\"9-性能诊断\"><a href=\"#9-性能诊断\" class=\"headerlink\" title=\"9. 性能诊断\"></a>9. 性能诊断</h3><ul>\n<li>oracle有各种成熟的性能诊断工具，比如awr、addm等</li>\n<li>mysql诊断调优方法较少，主要有慢查询日志</li>\n</ul>\n","categories":["Mysql"],"tags":["Mysql"]},{"title":"浅谈红黑树","url":"http://www.shenjian.online/2020/02/12/浅谈红黑树/","content":"<h3 id=\"1-红黑树简介\"><a href=\"#1-红黑树简介\" class=\"headerlink\" title=\"1.红黑树简介\"></a>1.红黑树简介</h3><p>红黑树是一种自平衡二叉搜索树，不能保证非常严格的平衡性，但是其平衡性仍然足以确保以O(logN)的时间复杂度进行插入、删除和检索操作。<br>它需要更少的内存，并且可以更快的进行再平衡，所以它常在树需要被频繁修改的情况下使用。</p>\n<h3 id=\"2-红黑树性质\"><a href=\"#2-红黑树性质\" class=\"headerlink\" title=\"2. 红黑树性质\"></a>2. 红黑树性质</h3><p>1）每个节点要么是红色节点，要么是黑色节点<br>2）根节点是黑色节点<br>3）叶节点是空节点，也称为黑色节点<br>4）每个红色节点必须有两个黑色子节点，也就是说，一个红色节点不可能有红色子节点(虽然黑色节点可以有黑色子节点)<br>5）每一条从某一节点至叶节点的路径必须包含相同数量的黑色子节点  </p>\n<h3 id=\"3-为什么这样的树是平衡的\"><a href=\"#3-为什么这样的树是平衡的\" class=\"headerlink\" title=\"3. 为什么这样的树是平衡的\"></a>3. 为什么这样的树是平衡的</h3><p>根据性质5)假设从某节点(根节点)到叶节点有路径1与路径2，每条路径均有b个黑色节点，最坏情况下，  </p>\n<ul>\n<li>红色节点最少数量为0，则路径1共有b个节点  </li>\n<li>红色节点最大数量为b(性质4决定红色节点数不会超过一半), 路径2共有2b个节点<br>即使在最极端的情况下，两条路径的长度相差也不会超过一倍，这足以确保在O(logN)的时间复杂度内完成查找和插入操作  </li>\n</ul>\n<h3 id=\"4-Java8中HashMap链表使用红黑树而不是AVL树\"><a href=\"#4-Java8中HashMap链表使用红黑树而不是AVL树\" class=\"headerlink\" title=\"4. Java8中HashMap链表使用红黑树而不是AVL树\"></a>4. Java8中HashMap链表使用红黑树而不是AVL树</h3><p>在ConcurrentHashMap中是加了锁的，实际上是读写锁，如果写冲突就会等待，如果插入时间过长必然等待时间更长，而红黑树相对AVL树插入更快</p>\n<h3 id=\"5-既然红黑树那么好，为啥hashmap不直接采用红黑树，而是当大于8个的时候才转换红黑树\"><a href=\"#5-既然红黑树那么好，为啥hashmap不直接采用红黑树，而是当大于8个的时候才转换红黑树\" class=\"headerlink\" title=\"5. 既然红黑树那么好，为啥hashmap不直接采用红黑树，而是当大于8个的时候才转换红黑树\"></a>5. 既然红黑树那么好，为啥hashmap不直接采用红黑树，而是当大于8个的时候才转换红黑树</h3><p>因为红黑树需要左旋、右旋操作，而单链表不需要<br>以下都是单链表与红黑树结构对比<br>如果元素小于8个，查询成本高，新增成本低<br>如果元素大于8个，查询成本低，新增成本高  </p>\n<h3 id=\"6-红黑树应用实例\"><a href=\"#6-红黑树应用实例\" class=\"headerlink\" title=\"6. 红黑树应用实例\"></a>6. 红黑树应用实例</h3><p>JAVA: java.util.TreeMap、java.utils.TreeSet<br>C++ STL: map、multimap、multiset<br>Linux内核： 完全公平的调度程序， linux/rbtree.h  </p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构"]},{"title":"Spring如何解决循环依赖问题","url":"http://www.shenjian.online/2020/02/10/Spring如何解决循环依赖问题/","content":"<p>循环依赖就是N个类循环嵌套引用。  </p>\n<h3 id=\"1-循环依赖发生的时机\"><a href=\"#1-循环依赖发生的时机\" class=\"headerlink\" title=\"1. 循环依赖发生的时机\"></a>1. 循环依赖发生的时机</h3><p>Spring单例对象的初始化大略分为三步：  </p>\n<ol>\n<li>createBeanInstance: 实例化，其实就是调用对象的构造方法进行实例化对象  </li>\n<li>populateBean: 填充属性，这一步主要是多bean的依赖属性进行填充  </li>\n<li>initialzeBean: 初始化<br>循环依赖主要发生在第一、第二步。也就是构造器循环依赖和field循环依赖  </li>\n</ol>\n<h3 id=\"2-构造器循环依赖\"><a href=\"#2-构造器循环依赖\" class=\"headerlink\" title=\"2. 构造器循环依赖\"></a>2. 构造器循环依赖</h3><p>抛出BeanCurrentlylnCreationException异常</p>\n<h3 id=\"3-单例setter循环依赖\"><a href=\"#3-单例setter循环依赖\" class=\"headerlink\" title=\"3. 单例setter循环依赖\"></a>3. 单例setter循环依赖</h3><p>Spring为了解决单例的循环依赖问题，使用了<strong>三级缓存</strong><br>先让最底层对象完成初始化，通过三级缓存与二级缓存提前暴露创建中的bean,让其他bean率先完成初始化  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 一级缓存：完成初始化的单例对象的cache **/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; singletonObjects = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class=\"number\">256</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 二级缓存：完成实例化但尚未填充属性初始化的单例对象的cache */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 三级缓存：进入实例化阶段单例对象工厂的cache */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class=\"keyword\">new</span> HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">bean 的获取过程：先从一级获取，失败再从二级、三级里面获取</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">创建中状态：是指对象已经 new 出来了但是所有的属性均为 null 等待被 init</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>检测循环依赖的过程如下：  </p>\n<ul>\n<li>A创建过程中需要B，于是<strong>A将自己放入三级缓存里面</strong>，去实例化B  </li>\n<li>B实例化的时候发现需要A，于是B先检查一级缓存，没有在查二级缓存，还是没有，则在查三级缓存，找到了！  <ul>\n<li><strong>然后把三级缓存里的A放入二级缓存，并删除三级缓存里的A</strong>  </li>\n<li>B顺利初始化完毕，<strong>将自己放入一级缓存</strong>(此时B里面的A依然是创建中状态)  </li>\n</ul>\n</li>\n<li>然后回来接着创建A，此时B已经创建结束，直接从一级缓存中拿到B，然后完成创建，<strong>并将自己放入一级缓存中</strong>  </li>\n<li>如此依赖便解决了循环依赖的问题  </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以上叙述的源码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">getSingleton</span><span class=\"params\">(String beanName, <span class=\"keyword\">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class=\"line\">\tObject singletonObject = <span class=\"keyword\">this</span>.singletonObjects.get(beanName);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (singletonObject == <span class=\"keyword\">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.singletonObjects) &#123;</span><br><span class=\"line\">\t\t\tsingletonObject = <span class=\"keyword\">this</span>.earlySingletonObjects.get(beanName);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (singletonObject == <span class=\"keyword\">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class=\"line\">\t\t\t\tObjectFactory&lt;?&gt; singletonFactory = <span class=\"keyword\">this</span>.singletonFactories.get(beanName);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (singletonFactory != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tsingletonObject = singletonFactory.getObject();</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">this</span>.singletonFactories.remove(beanName);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> singletonObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-非单例循环依赖\"><a href=\"#4-非单例循环依赖\" class=\"headerlink\" title=\"4. 非单例循环依赖\"></a>4. 非单例循环依赖</h3><p>Spring无法完成依赖注入。因为Spring不缓存“prototype”作用域的bean,因此无法提前暴露一个创建中的bean</p>\n","categories":["Spring"],"tags":["面试","Spring"]},{"title":"SAP面试总结","url":"http://www.shenjian.online/2020/02/05/SAP面试总结/","content":"<p>机会是留给有准备的人的，哎，春节几天没有复习基础知识，面试前一天看了看之前写的博客，发现好多重复问到的问题，然而，并想不起如何作答~~ 这是一次惨痛的教训</p>\n<h3 id=\"1-介绍下最近做过的两个项目\"><a href=\"#1-介绍下最近做过的两个项目\" class=\"headerlink\" title=\"1. 介绍下最近做过的两个项目\"></a>1. 介绍下最近做过的两个项目</h3><p>项目都是传统的项目，面试官可能不感兴趣，没有继续问下去，接下来开始基础知识的空袭了</p>\n<h3 id=\"2-JAVA访问修饰符\"><a href=\"#2-JAVA访问修饰符\" class=\"headerlink\" title=\"2. JAVA访问修饰符\"></a>2. JAVA访问修饰符</h3><p><a href=\"https://shenjian.online/2019/11/01/%E8%85%BE%E8%AE%AF%E7%AF%87%E4%B9%8BJAVA%E5%9F%BA%E7%A1%80/#18-%E5%A6%82%E4%BD%95%E5%9C%A8%E7%88%B6%E7%B1%BB%E4%B8%AD%E4%B8%BA%E5%AD%90%E7%B1%BB%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90%E6%89%80%E6%9C%89%E7%9A%84hashcode%E5%92%8Cequals%E5%AE%9E%E7%8E%B0%EF%BC%9F%E8%BF%99%E4%B9%88%E5%81%9A%E6%9C%89%E4%BD%95%E4%BC%98%E5%8A%A3\" target=\"_blank\" rel=\"noopener\">请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用</a></p>\n<h3 id=\"3-error与exception的区别\"><a href=\"#3-error与exception的区别\" class=\"headerlink\" title=\"3. error与exception的区别\"></a>3. error与exception的区别</h3><p><a href=\"https://shenjian.online/2019/11/01/%E8%85%BE%E8%AE%AF%E7%AF%87%E4%B9%8BJAVA%E5%9F%BA%E7%A1%80/#21-error%E5%92%8Cexception%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8CCheckedException%EF%BC%8CRuntimeException%E7%9A%84%E5%8C%BA%E5%88%AB\" target=\"_blank\" rel=\"noopener\">error和exception的区别，CheckedException，RuntimeException的区别</a></p>\n<h3 id=\"4-Stringbuffer，StringBuilder的区别及扩容机制\"><a href=\"#4-Stringbuffer，StringBuilder的区别及扩容机制\" class=\"headerlink\" title=\"4. Stringbuffer，StringBuilder的区别及扩容机制\"></a>4. Stringbuffer，StringBuilder的区别及扩容机制</h3><p><a href=\"https://shenjian.online/2019/11/01/%E8%85%BE%E8%AE%AF%E7%AF%87%E4%B9%8BJAVA%E5%9F%BA%E7%A1%80/#3-String%EF%BC%8CStringBuffer%EF%BC%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6\" target=\"_blank\" rel=\"noopener\">String，StringBuffer，StringBuilder的区别及扩容机制</a></p>\n<h3 id=\"5-重写、重载区别\"><a href=\"#5-重写、重载区别\" class=\"headerlink\" title=\"5. 重写、重载区别\"></a>5. 重写、重载区别</h3><p><strong>重写(Override)</strong><br>重写是子类对父类允许访问方法的实现过程进行重新编写，返回值与形参都不能改变<br><strong>重载(Overload)</strong><br>重载是在一个类中，方法名字相同，而参数不同，返回类型可以相同，可以不同。  </p>\n<table>\n<thead>\n<tr>\n<th>区别点</th>\n<th>重载方法</th>\n<th>重写方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>参数列表</td>\n<td>必须修改</td>\n<td>一定不能修改</td>\n</tr>\n<tr>\n<td>返回类型</td>\n<td>可以修改</td>\n<td>一定不能修改</td>\n</tr>\n<tr>\n<td>异常</td>\n<td>可以修改</td>\n<td>可以减少或删除，一定不能抛出新的或更广的异常</td>\n</tr>\n<tr>\n<td>访问</td>\n<td>可以修改</td>\n<td>一定不能做更严格的限制(可以降低限制)</td>\n</tr>\n<tr>\n<td>分派类型</td>\n<td>静态分派，由静态类型确定，在类加载时确定</td>\n<td>动态分派，由动态类型确定，在运行时确定  </td>\n</tr>\n</tbody>\n</table>\n<p>ps扩展补充: 动态分配由虚方法表实现，虚方法表中存在各个方法的实际入口地址，若未重写方法，则子父类该方法地址相同，<br>若重写，则子类方法指向重写后的地址</p>\n<h3 id=\"6-HashMap底层实现，如何解决hash碰撞\"><a href=\"#6-HashMap底层实现，如何解决hash碰撞\" class=\"headerlink\" title=\"6. HashMap底层实现，如何解决hash碰撞\"></a>6. HashMap底层实现，如何解决hash碰撞</h3><p><a href=\"https://shenjian.online/2019/11/01/%E8%85%BE%E8%AE%AF%E7%AF%87%E4%B9%8BJAVA%E5%9F%BA%E7%A1%80/#6-%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9BMap%E7%B1%BB%EF%BC%8C%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8CHashMap%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97-%E5%B9%B6%E5%8F%91%E4%B8%8B%E4%BD%BF%E7%94%A8%E7%9A%84Map%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BB%96%E4%BB%AC%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%AF%94%E5%A6%82%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%EF%BC%8Chashcode%EF%BC%8C%E6%89%A9%E5%AE%B9%EF%BC%8C%E9%BB%98%E8%AE%A4%E5%AE%B9%E9%87%8F%E7%AD%89%E3%80%82\" target=\"_blank\" rel=\"noopener\">HashMap是线程安全的吗,并发下使用的Map是什么</a></p>\n<h3 id=\"7-ArrayList与LinkedList区别\"><a href=\"#7-ArrayList与LinkedList区别\" class=\"headerlink\" title=\"7. ArrayList与LinkedList区别\"></a>7. ArrayList与LinkedList区别</h3><p><a href=\"https://shenjian.online/2019/11/01/%E8%85%BE%E8%AE%AF%E7%AF%87%E4%B9%8BJAVA%E5%9F%BA%E7%A1%80/#4-ArrayList%E5%92%8CLinkedList%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\" target=\"_blank\" rel=\"noopener\">ArrayList和LinkedList有什么区别</a></p>\n<h3 id=\"8-synchronized、ReentrantLock实现原理及使用场景\"><a href=\"#8-synchronized、ReentrantLock实现原理及使用场景\" class=\"headerlink\" title=\"8. synchronized、ReentrantLock实现原理及使用场景\"></a>8. synchronized、ReentrantLock实现原理及使用场景</h3><p><a href=\"https://shenjian.online/2019/06/01/Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8Bsynchronized/#2-synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\" target=\"_blank\" rel=\"noopener\">synchronized实现原理</a></p>\n<p><a href=\"https://shenjian.online/2019/03/29/Lock%E6%8E%A5%E5%8F%A3%E5%92%8CReentrantLock/#5-ReentrantLock%E5%86%85%E9%83%A8%E7%BB%84%E6%88%90\" target=\"_blank\" rel=\"noopener\">ReentrantLock内部组成</a></p>\n<p><a href=\"https://shenjian.online/2019/03/29/Lock%E6%8E%A5%E5%8F%A3%E5%92%8CReentrantLock/#6-synchronized%E5%92%8CReentrantLock%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%89%E6%8B%A9\" target=\"_blank\" rel=\"noopener\">synchronized和ReentrantLock之间的选择</a></p>\n<h3 id=\"9-CopyOnWriteArrayList实现原理及使用场景\"><a href=\"#9-CopyOnWriteArrayList实现原理及使用场景\" class=\"headerlink\" title=\"9. CopyOnWriteArrayList实现原理及使用场景\"></a>9. CopyOnWriteArrayList实现原理及使用场景</h3><p><a href=\"https://shenjian.online/2019/02/23/CopyOnWriteArrayList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/#1-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\" target=\"_blank\" rel=\"noopener\">CopyOnWriteArrayList实现原理</a></p>\n<h3 id=\"10-volatile实现原理\"><a href=\"#10-volatile实现原理\" class=\"headerlink\" title=\"10. volatile实现原理\"></a>10. volatile实现原理</h3><p><a href=\"https://shenjian.online/2019/01/10/Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8Bvolatile\" target=\"_blank\" rel=\"noopener\">Java并发机制底层实现原理之volatile</a></p>\n<h3 id=\"11-线程池实现原理，几个重要参数\"><a href=\"#11-线程池实现原理，几个重要参数\" class=\"headerlink\" title=\"11. 线程池实现原理，几个重要参数\"></a>11. 线程池实现原理，几个重要参数</h3><p><a href=\"https://shenjian.online/2019/05/23/ThreadPoolExecutor%E5%8F%8AThreadFactory/\" target=\"_blank\" rel=\"noopener\">ThreadPoolExecutor及ThreadFactory</a></p>\n<h3 id=\"12-JVM运行时数据区结构\"><a href=\"#12-JVM运行时数据区结构\" class=\"headerlink\" title=\"12. JVM运行时数据区结构\"></a>12. JVM运行时数据区结构</h3><p><a href=\"https://shenjian.online/2019/03/21/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E3%80%81JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E3%80%81JAVA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/#1-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84\" target=\"_blank\" rel=\"noopener\">JVM内存结构</a></p>\n<h3 id=\"12-1-GC-ROOT有哪些？\"><a href=\"#12-1-GC-ROOT有哪些？\" class=\"headerlink\" title=\"12.1 GC ROOT有哪些？\"></a>12.1 GC ROOT有哪些？</h3><ul>\n<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中JNI引用的对象</li>\n</ul>\n<h3 id=\"13-垃圾回收算法及垃圾回收器\"><a href=\"#13-垃圾回收算法及垃圾回收器\" class=\"headerlink\" title=\"13. 垃圾回收算法及垃圾回收器\"></a>13. 垃圾回收算法及垃圾回收器</h3><p><a href=\"https://shenjian.online/2019/11/03/%E8%85%BE%E8%AE%AF%E7%AF%87%E4%B9%8BJVM/#5-%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E5%87%A0%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%8C%E9%87%8D%E7%82%B9%E8%AE%B2%E4%B8%8Bcms%E5%92%8CG1%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%8E%9F%E7%90%86%EF%BC%8C%E6%B5%81%E7%A8%8B%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9\" target=\"_blank\" rel=\"noopener\">哪几种垃圾收集器，各自的优缺点</a></p>\n<h3 id=\"14-说说双亲委派模型，如何打破\"><a href=\"#14-说说双亲委派模型，如何打破\" class=\"headerlink\" title=\"14. 说说双亲委派模型，如何打破\"></a>14. 说说双亲委派模型，如何打破</h3><p><a href=\"https://shenjian.online/2019/11/03/%E8%85%BE%E8%AE%AF%E7%AF%87%E4%B9%8BJVM/#9-%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E6%89%93%E7%A0%B4\" target=\"_blank\" rel=\"noopener\">简单说说你了解的类加载器，可以打破双亲委派么，怎么打破</a></p>\n<h3 id=\"15-Redis数据类型\"><a href=\"#15-Redis数据类型\" class=\"headerlink\" title=\"15. Redis数据类型\"></a>15. Redis数据类型</h3><p><a href=\"https://shenjian.online/2019/10/08/Redis%E9%9D%A2%E8%AF%95%E7%AF%87/\" target=\"_blank\" rel=\"noopener\">五种数据类型</a></p>\n<h3 id=\"16-redis为什么是单线程\"><a href=\"#16-redis为什么是单线程\" class=\"headerlink\" title=\"16. redis为什么是单线程\"></a>16. redis为什么是单线程</h3><p>注意，redis单线程指的是网络请求模块使用了一个线程，即一个线程处理所有网络请求，其他模块仍然用了多个线程。<br><strong>官方答案</strong><br>因为redis是基于内存的操作，CPU不是redis的瓶颈，redis的瓶颈最有可能是机器内存与网络带宽，既然单线程容易实现并且CPU不会成为瓶颈，顺理成章采用单线程方案。<br><strong>性能指标</strong><br>关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万请求。<br><strong>详细原因</strong><br>1）不需要各种锁的性能消耗<br>2）单线程多进程集群方案<br>3）避免了上线文切换和竞争条件导致的CPU消耗  </p>\n<h3 id=\"17-MySQL乐观锁、悲观锁如何实现\"><a href=\"#17-MySQL乐观锁、悲观锁如何实现\" class=\"headerlink\" title=\"17. MySQL乐观锁、悲观锁如何实现\"></a>17. MySQL乐观锁、悲观锁如何实现</h3><p><strong>乐观锁:</strong><br>使用数据版本(Version)、使用时间戳(timestamp)<br><strong>悲观锁</strong><br><code>SELECT ... FOR UPDATE</code>，<code>SELECT ... LOCK IN SHARE MODE</code>  </p>\n<h3 id=\"18-Mysql索引存储数据的数据结构及原因\"><a href=\"#18-Mysql索引存储数据的数据结构及原因\" class=\"headerlink\" title=\"18. Mysql索引存储数据的数据结构及原因\"></a>18. Mysql索引存储数据的数据结构及原因</h3><p>采用B+树  </p>\n<ul>\n<li>B+树就是一种多叉树，是由二叉搜索树不断演化而来，为了满足区间快速查询，B+树的叶子节点通过双向链表串联起来</li>\n<li>使用双向链表是为了支持顺序与倒叙查询，虽然双向链表相对于单向链表会浪费一倍的空间，但对于硬盘来说微乎其微</li>\n<li>索引存在于硬盘中，为了提升查询速度，二叉改为m叉，降低树的高度，减少磁盘IO</li>\n<li>B+树的子节点树不超过m个，超过则分裂，同时也不能少于m/2个，少于则合并</li>\n</ul>\n<p>参考：<a href=\"https://learnku.com/articles/25879\" target=\"_blank\" rel=\"noopener\">MySQL 索引为啥要选择B+树</a></p>\n<h3 id=\"19-Spring如何解决循环依赖\"><a href=\"#19-Spring如何解决循环依赖\" class=\"headerlink\" title=\"19. Spring如何解决循环依赖\"></a>19. Spring如何解决循环依赖</h3><p><a href=\"https://shenjian.online/2020/02/10/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/\" target=\"_blank\" rel=\"noopener\">单例setter循环依赖</a> </p>\n<h3 id=\"20-Spring-AOP实现\"><a href=\"#20-Spring-AOP实现\" class=\"headerlink\" title=\"20. Spring AOP实现\"></a>20. Spring AOP实现</h3><p><a href=\"https://shenjian.online/2019/11/05/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E7%AF%87/#4-Spring-AOP%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-AOP%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E6%9C%AF%E8%AF%AD%EF%BC%8C%E5%AE%83%E4%BB%AC%E6%98%AF%E6%80%8E%E4%B9%88%E7%9B%B8%E4%BA%92%E5%B7%A5%E4%BD%9C%E7%9A%84\" target=\"_blank\" rel=\"noopener\">Spring AOP的实现原理</a></p>\n<h3 id=\"21-Spring事务传播属性\"><a href=\"#21-Spring事务传播属性\" class=\"headerlink\" title=\"21. Spring事务传播属性\"></a>21. Spring事务传播属性</h3><p><a href=\"https://shenjian.online/2019/11/05/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E7%AF%87/#5-%E8%AE%B2%E8%AE%B2Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7\" target=\"_blank\" rel=\"noopener\">讲讲Spring事务的传播属性</a></p>\n<h3 id=\"22-Spring如何管理事务的\"><a href=\"#22-Spring如何管理事务的\" class=\"headerlink\" title=\"22. Spring如何管理事务的\"></a>22. Spring如何管理事务的</h3><p><a href=\"https://shenjian.online/2019/11/05/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E7%AF%87/#6-Spring%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E7%9A%84\" target=\"_blank\" rel=\"noopener\">Spring如何管理事务的</a></p>\n<h3 id=\"23-Spring框架bean生命周期\"><a href=\"#23-Spring框架bean生命周期\" class=\"headerlink\" title=\"23. Spring框架bean生命周期\"></a>23. Spring框架bean生命周期</h3><p><a href=\"https://shenjian.online/2019/01/20/Spring%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/#6-%E8%A7%A3%E9%87%8ASpring%E6%A1%86%E6%9E%B6%E4%B8%ADbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\" target=\"_blank\" rel=\"noopener\">Spring框架中bean的生命周期</a></p>\n<h3 id=\"24-SrpingMVC-request请求流程\"><a href=\"#24-SrpingMVC-request请求流程\" class=\"headerlink\" title=\"24. SrpingMVC request请求流程\"></a>24. SrpingMVC request请求流程</h3><p><a href=\"https://shenjian.online/2019/11/05/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E7%AF%87/#17-SpringMVC%E7%94%A8%E5%88%B0%E7%9A%84%E6%B3%A8%E8%A7%A3%EF%BC%8C%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%8E%9F%E7%90%86\" target=\"_blank\" rel=\"noopener\">SpringMVC运行原理</a></p>\n<h3 id=\"25-SpringBoot自动配置如何实现\"><a href=\"#25-SpringBoot自动配置如何实现\" class=\"headerlink\" title=\"25. SpringBoot自动配置如何实现\"></a>25. SpringBoot自动配置如何实现</h3><p>1）引入spring-boot-autoconfigure模块<br>2）编写Java Configuration类,并添加条件注解<br>3）在当前项目resource目录下META-INF目录下创建spring.factories文件，内容如下<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\</span><br><span class=\"line\">自定义configuration类路径</span><br></pre></td></tr></table></figure></p>\n","categories":["面试"],"tags":["面试"]},{"title":"JSON与自定义对象转换工具类","url":"http://www.shenjian.online/2020/02/01/JSON与自定义对象转换工具类/","content":"<p>话不多说，直接撸代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.codehaus.jackson.map.ObjectMapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.codehaus.jackson.type.JavaType;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonUtils</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 使用泛型方法，把json字符串转换为相应的JavaBean对象。</span></span><br><span class=\"line\"><span class=\"comment\">     * 转换为普通JavaBean：readValue(json,Student.class)</span></span><br><span class=\"line\"><span class=\"comment\">     * 转换为List:readValue(json,List.class</span></span><br><span class=\"line\"><span class=\"comment\">     * ).但是如果我们想把json转换为特定类型的List，比如List&lt;Student&gt;，就不能直接进行转换了。</span></span><br><span class=\"line\"><span class=\"comment\">     * 因为readValue(json,List .class)返回的其实是List&lt;Map&gt;类型，</span></span><br><span class=\"line\"><span class=\"comment\">     * 你不能指定readValue()的第二个参数是List&lt;Student&gt;.class，所以不能直接转换。</span></span><br><span class=\"line\"><span class=\"comment\">     * 我们可以把readValue()的第二个参数传递为Student[].class.然后使用Arrays.asList();</span></span><br><span class=\"line\"><span class=\"comment\">     * 方法把得到的数组转换为特定类型的List。 转换为Map：readValue(json,Map.class)</span></span><br><span class=\"line\"><span class=\"comment\">     * 将对象转为Map数组可以调用：List&lt;Map&lt;String, Object&gt;&gt; list2 = JsonUtils.toObject(json字符串, List.class);</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> content 要转换的JavaBean类型</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> valueType 原始json字符串数据</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> JavaBean对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">toObject</span><span class=\"params\">(String jsonContent, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ObjectMapperHelper.INSTANCE.getObjectMapper().readValue(jsonContent, type);</span><br><span class=\"line\">        &#125;  <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"数据转换异常：\"</span> + e.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将一个json字符串转为某个对象List&lt;T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> jsonContent</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> type</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">toJsonList</span><span class=\"params\">(String jsonContent, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            JavaType javaType = getJavaType(List.class, type);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ObjectMapperHelper.INSTANCE.getObjectMapper().readValue(jsonContent, javaType);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"传入数据应该是一个数组：\"</span> + e.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 把JavaBean转换为json字符串 普通对象转换：toJson(Student) List转换：toJson(List)</span></span><br><span class=\"line\"><span class=\"comment\">     * Map转换:toJson(Map) 我们发现不管什么类型，都可以直接传入这个方法</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> object JavaBean对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> json字符串</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toJson</span><span class=\"params\">(Object object)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ObjectMapperHelper.INSTANCE.getObjectMapper().writeValueAsString(object);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"数据转换异常：\"</span> + e.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 枚举实现单例模式</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> ObjectMapperHelper &#123;</span><br><span class=\"line\">        INSTANCE;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> ObjectMapper objectMapper = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">ObjectMapperHelper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            objectMapper = <span class=\"keyword\">new</span> ObjectMapper();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> ObjectMapper <span class=\"title\">getObjectMapper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> objectMapper;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> JavaType <span class=\"title\">getJavaType</span><span class=\"params\">(Class&lt;?&gt; collectionType, Class&lt;?&gt; ... elementType)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ObjectMapperHelper.INSTANCE.getObjectMapper().getTypeFactory().constructParametricType(collectionType, elementType);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">30</span>; i++) &#123;</span><br><span class=\"line\">            Thread thread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    ObjectMapper objectMapper = ObjectMapperHelper.INSTANCE.getObjectMapper();</span><br><span class=\"line\">                    System.out.println(objectMapper);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["工作干货"],"tags":["工作干货"]},{"title":"Zookeeper面试篇","url":"http://www.shenjian.online/2020/01/31/Zookeeper面试篇/","content":"<h3 id=\"12-1-0-zookeeper是什么？\"><a href=\"#12-1-0-zookeeper是什么？\" class=\"headerlink\" title=\"12.1.0 zookeeper是什么？\"></a>12.1.0 zookeeper是什么？</h3><p><code>A high-performance coordination service for distributed applications</code><br>Zookeeper是基于Google Chubby论文的开源实现，它主要用于解决分布式应用中经常遇到的数据管理问题，<br>如统一命名服务、状态同步管理、集群管理、配置管理等。由于Hadoop生态系统中有许多项目都依赖于zookeeper，<br>如Hive、HBase，似乎像一个动物管理员，故取名为zookeeper  </p>\n<h3 id=\"12-1-1-zookeeper提供了什么？\"><a href=\"#12-1-1-zookeeper提供了什么？\" class=\"headerlink\" title=\"12.1.1 zookeeper提供了什么？\"></a>12.1.1 zookeeper提供了什么？</h3><p>1、文件系统 2、通知机制  </p>\n<h3 id=\"12-1-2-zookeeper文件系统\"><a href=\"#12-1-2-zookeeper文件系统\" class=\"headerlink\" title=\"12.1.2 zookeeper文件系统\"></a>12.1.2 zookeeper文件系统</h3><p>zookeeper提供一个类似unix文件系统目录的多层级节点命名空间（节点称为znode）。与文件系统不同的是，这些节点都可以设置关联的数据，<br>而文件系统中只有文件节点可以存放数据而目录节点不行。<br>zookeeper为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得zookeeper不能用于存放大量的数据，<br>每个节点的存放数据上限为1M。  </p>\n<h3 id=\"12-1-3-zookeeper的四种类型的znode\"><a href=\"#12-1-3-zookeeper的四种类型的znode\" class=\"headerlink\" title=\"12.1.3 zookeeper的四种类型的znode\"></a>12.1.3 zookeeper的四种类型的znode</h3><p>PERSISTENT 持久化节点<br>PERSISTENT_SEQUENTIAL 顺序自动编号持久化节点，这种节点会根据当前已存在的节点数自动加1<br>EPHEMERAL 临时节点，客户端session超时这类节点会被自动删除<br>EPHEMERAL_SEQUENTIAL 临时自动编号节点   </p>\n<h3 id=\"12-1-4-zookeeper通知机制\"><a href=\"#12-1-4-zookeeper通知机制\" class=\"headerlink\" title=\"12.1.4 zookeeper通知机制\"></a>12.1.4 zookeeper通知机制</h3><p>client会对某个znode建立一个watcher事件，当znode发生变化时，zk会主动通知watch这个znode的所有client,client根据znode的变化来做业务上的改变。  </p>\n<p><strong>watcher的特点</strong>  </p>\n<ul>\n<li>轻量级：一个callback()函数   </li>\n<li>异步性：不会block正常的读写  </li>\n<li>主动推送：watcher被触发时，zk服务端主动将更新推送给客户端</li>\n<li>一次性：数据变化时，watcher只会被触发一次，如果客户端想要得到后续更新通知，需要在watcher触发后重新注册一个watcher.</li>\n<li>仅通知：仅通知变更类型，不附带变更后的结果</li>\n<li>顺序性：如果多个更新触发了多个watcher,那么watcher被触发的顺序与更新一致  </li>\n</ul>\n<p><strong>使用watcher注意事项</strong></p>\n<ul>\n<li>由于watcher是一次性的，所以需要自己去实现永久watcher</li>\n<li>如果被watch的节点频繁更新，会出现“丢数据”的情况</li>\n<li>watcher数量过多会导致性能下降  </li>\n</ul>\n<h3 id=\"12-1-5-zookeeper有哪些应用场景\"><a href=\"#12-1-5-zookeeper有哪些应用场景\" class=\"headerlink\" title=\"12.1.5 zookeeper有哪些应用场景\"></a>12.1.5 zookeeper有哪些应用场景</h3><ol>\n<li>统一命名服务  </li>\n<li>配置管理  </li>\n<li>集群管理  </li>\n<li>分布式锁  </li>\n<li>队列管理  </li>\n<li>消息订阅  </li>\n</ol>\n<h3 id=\"12-1-6-zk命名服务\"><a href=\"#12-1-6-zk命名服务\" class=\"headerlink\" title=\"12.1.6 zk命名服务\"></a>12.1.6 zk命名服务</h3><p>命名服务是指通过指定的名字来获取资源或者服务的地址。利用zk来创建一个全局的路径，即唯一的路径，这个路径就可以作为一个名字，指向集群中的集群、提供服务的地址或者一个远程对象等  </p>\n<h3 id=\"12-1-7-zk配置管理\"><a href=\"#12-1-7-zk配置管理\" class=\"headerlink\" title=\"12.1.7 zk配置管理\"></a>12.1.7 zk配置管理</h3><p>程序分布式的部署在不同机器上，将程序的配置信息放在zk的znode上，当有配置发生改变时，也就是znode发生了改变，利用watcher通知给各个watch该znode的客户端，从而实现配置更改</p>\n<h3 id=\"12-1-8-zk集群管理\"><a href=\"#12-1-8-zk集群管理\" class=\"headerlink\" title=\"12.1.8 zk集群管理\"></a>12.1.8 zk集群管理</h3><p>集群管理在于两点：机器加入和退出、选举master<br>对于第一点，所有机器约定在父目录下创建临时节点，然后监听父目录下所有子节点的变化消息。一旦有机器挂掉，该机器与zookeeper服务器断开连接，其所创建的EPHEMERAL(临时节点)被删除，所有的机器收到通知:<br>某个兄弟目录被删除，新加机器也类似<br>对于第二点，我们稍微改变下，所有机器创建EPHEMERAL_SEQUENTIAL(临时顺序编号节点)，每次选取编号最小的节点作为master  </p>\n<h3 id=\"12-1-9-zk分布式锁\"><a href=\"#12-1-9-zk分布式锁\" class=\"headerlink\" title=\"12.1.9 zk分布式锁\"></a>12.1.9 zk分布式锁</h3><p>有了zookeeper的一致性文件系统，锁的问题变得简单。锁服务可以分为两类：一类是保持独占，另一类是控制时序。<br>第一类，我们将zookeeper上的一个znode看做是一把锁，通过createznode的方式实现。所有客户端都去创建/distribute_lock节点，成功创建的客户端也即拥有了这把锁，<br>用完删除掉distribute_lock节点即释放锁<br>第二类，/distribute_lock节点已经预先存在，所有客户端在它下面创建临时顺序编号节点,和选master一样，编号最小的获得锁，用完删除，依次获取。  </p>\n<p><strong>获取分布式锁的流程</strong><br>在获取分布式锁的时候在locker节点下创建临时顺序节点，释放锁的时候删除该节点。<br>1.客户端调用createznode节点在locker下创建临时顺序节点<br>2.调用getChild(“locker”)获取locker下的所有子节点<br>   2.1 如果发现自己创建的节点在所有的子节点中序号最小，则认为客户端获取到了锁<br>   2.2 否则，说明自己还没有获取到锁，此时客户端需要找到比它小的那个节点，然后对其调用exist()方法，同时对其注册事件监听器。<br>   之后，被watch的节点删除后，则客户端的watcher会收到相应通知，此时再次判断自己创建的节点是否是locker子节点中最小，如果是，则获取到了锁，如果不是则重复以上步骤继续获取比<br>   自己小的那个节点并注册监听。  </p>\n<h1 id=\"TODO-插入图片\"><a href=\"#TODO-插入图片\" class=\"headerlink\" title=\"TODO 插入图片\"></a>TODO 插入图片</h1><p>代码的实现主要基于互斥锁，获取分布式锁的重点逻辑在于BaseDistributeLock,实现了基于Zookeeper实现分布式锁的细节</p>\n<h3 id=\"12-2-0-zk队列管理\"><a href=\"#12-2-0-zk队列管理\" class=\"headerlink\" title=\"12.2.0 zk队列管理\"></a>12.2.0 zk队列管理</h3><p>两种类型的队列。  </p>\n<ol>\n<li>同步队列。当一个队列的所有成员都聚齐时，这个队列才可用，否则等待所有成员到达<br>实现：在约定目录下创建临时目录节点，监听节点数量是否是我们要求的数量  </li>\n<li>队列按照FIFO方式入队与出队。<br>实现：在特定的目录下创建PERSISTENT_SEQUENTIAL节点，创建成功时watcher通知等待的队列，队列删除序号最小的节点用于消费。<br>Zookeeper的znode用于消息存储，znode存储的数据就是消息队列中的消息内容，SEQENTIAL序号就是消息的编号，按序取出即可。<br>由于创建的节点是持久的，所以不必担心队列消息的丢失问题</li>\n</ol>\n<h3 id=\"12-2-1-zk数据复制\"><a href=\"#12-2-1-zk数据复制\" class=\"headerlink\" title=\"12.2.1 zk数据复制\"></a>12.2.1 zk数据复制</h3><p>Zookeeper做为一个集群提供一致的数据服务，自然，它要在所有机器间做数据复制<br>数据复制的好处：  </p>\n<ol>\n<li>容错： 一个节点出错，不致于整个系统停止工作，别的节点可以接管它的工作  </li>\n<li>提高系统的扩展能力：把负载分布到多个节点或者增加节点提高系统的负载能力  </li>\n<li>提高性能： 让客户端本地访问就近节点，提高用户访问速度  </li>\n</ol>\n<p>从客户端读写访问的透明度来说，数据复制集群系统分为以下两种：  </p>\n<ol>\n<li>写主(Write Master): 对数据的修改提高给指定的节点，读无此限制，可以读取任何一个节点。这种情况下客户端需要对读写进行区分，俗称读写分离。  </li>\n<li>写任意(Write Any): 对数据的修改可提交给任意节点，跟读一样。这种情况下，客户端对集群节点的角色与变化透明  </li>\n</ol>\n<p>对zookeeper而言，它采用的方式是写任意。通过增加机器，它的读吞吐能力和响应能力扩展性非常好，而写，随着机器的增加吞吐能力肯定下降(这也是它建立observer的原因)，<br>而响应能力，则取决于具体的实现方式，是延迟复制保持最终一致性，还是立即复制快速响应  </p>\n<h3 id=\"12-2-2-zk中zab的工作原理\"><a href=\"#12-2-2-zk中zab的工作原理\" class=\"headerlink\" title=\"12.2.2 zk中zab的工作原理\"></a>12.2.2 zk中zab的工作原理</h3><p>ZAB是Zookeeper Atomic Broadcast(Zookeeper原子广播协议)的缩写，它是特别为Zookeeper设计的崩溃可恢复的原子消息广播算法。<br>Zookeeper使用Leader来接收并处理所有事务请求，并采用ZAB协议，将服务器数据的状态变更以事务Proposal的形式广播到所有Follower服务器上。这种主备模型架构保证了同一时刻集群中只有一个服务器<br>广播服务器的状态变更，因此能够很好的保证事务的完整性与顺序性。  </p>\n<p>ZAB协议有两种模式：恢复模式(Recovery)和广播模式(Broadcast)。当服务启动或者leader崩溃后，ZAB就进入了恢复模式，当leader选举出来并且大多数follower完成了与leader的状态同步以后，<br>恢复模式就结束了，ZAB开始进入广播模式。</p>\n<h3 id=\"12-2-3-zk是如何保证事务的顺序一致性的？\"><a href=\"#12-2-3-zk是如何保证事务的顺序一致性的？\" class=\"headerlink\" title=\"12.2.3 zk是如何保证事务的顺序一致性的？\"></a>12.2.3 zk是如何保证事务的顺序一致性的？</h3><p>zookeeper采用了递增的事务id来标识。所有的proposal(提议)在提出的时候加上了zxid,zxid实际上是一个64位的数字。<br>高32位是epoch,用来标识leader是否改变，如果有新的leader产生出来，epoch会自增；<br>低32位用来递增计数。当新产生proposal时候，会依据数据库的两阶段过程，首先向其他的server发出事务执行请求，如果超过半数的机器都能执行并且能够成功，<br>那么就会开始执行。</p>\n<h3 id=\"12-2-4-zk集群下server工作状态\"><a href=\"#12-2-4-zk集群下server工作状态\" class=\"headerlink\" title=\"12.2.4 zk集群下server工作状态\"></a>12.2.4 zk集群下server工作状态</h3><p>每个Server工作状态中有四种状态  </p>\n<ul>\n<li>LOOKING: 当前server不知道谁是leader,正在搜寻</li>\n<li>LEADER: 当前server角色是leader</li>\n<li>FOLLOWING: 当前server角色是follower</li>\n<li>OBSERVING: 当前server角色是observer</li>\n</ul>\n<h3 id=\"12-2-5-zk是如何选举leader的？\"><a href=\"#12-2-5-zk是如何选举leader的？\" class=\"headerlink\" title=\"12.2.5 zk是如何选举leader的？\"></a>12.2.5 zk是如何选举leader的？</h3><p>当leader崩溃或者leader失去大多数follower时，这时zk进入恢复模式，恢复模式需要重新选举出一个新的leader,让所有的server都恢复到一个正确的状态。zk的选举算法有两种：<br>一种是基于basic paxos算法实现的，一种是基于fast paxos算法实现，系统默认的选举算法是fast paxos.<br><strong>basic paxos</strong><br>（1） 选举线程由当前server发起选举的线程担任，其主要功能是对投票结果统计，并选出推荐的server<br>（2） 选举线程首先向所有server发起一次询问(包括自己)<br>（3） 选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致),然后获取对方的id(myid),并存储到当前询问对象列表中，最后获取对方提议的leader<br>相关信息(id,zxid),并将这些信息存储到当次选举的投票记录表中<br>（4） 收到所有server回复以后，就计算出zxid最大的那个server,并将这个server相关信息设置成下一次要投票的server<br>（5） 线程线程将当前zxid最大的server设置为当前server要推荐的leader，如果此时获胜的server获得n/2+1的server票数，设置当前推荐的leader为获胜的server,<br>将根据获胜的server相关信息设置自己的状态，否则，继续这个过程，知道leader被选举出来</p>\n<p><strong>fast paxos</strong><br>fast paxos流程是在选举过程中，某server向所有server提议自己要成为leader,当其他server收到提议后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，<br>重复这个流程，最后一定能选举出leader</p>\n<h1 id=\"TODO-图片\"><a href=\"#TODO-图片\" class=\"headerlink\" title=\"TODO 图片\"></a>TODO 图片</h1><h3 id=\"12-2-6-zk同步流程\"><a href=\"#12-2-6-zk同步流程\" class=\"headerlink\" title=\"12.2.6 zk同步流程\"></a>12.2.6 zk同步流程</h3><p>选完leader以后，zk就进入状态同步状态<br>1) leader等待follower和observer连接<br>2) follower连接leader,将最大的zxid发送给leader<br>3) leader根据follower的zxid确定同步点<br>4) 完成通知后通知follower已经成为uptodate状态<br>5) follower收到uptodate消息后，又可以接收client的请求进行服务了  </p>\n<p><strong>数据同步的4中方式</strong><br>1) SNAP-全量同步  </p>\n<ul>\n<li>条件： peerLastZxid &lt; minCommittedLog  </li>\n<li>说明： 证明二者数据差异太大，follower数据过于陈旧，leader发送SNAP指令给follower全量同步数据，即leader将所有数据全量发送给follower<br>2) DIFF-增量同步  </li>\n<li>条件： minCommittedLog &lt;= peerLastZxid &lt;= maxCommittedLog  </li>\n<li>说明： 证明二者数据差异不大，follower上有一些leader上已经提交的提议proposal未同步，此时需要增量提交这些提议即可<br>3) TRUNC-仅回滚同步  </li>\n<li>条件： peerLastZxid &gt; maxCommittedLog  </li>\n<li>说明： 证明follower上有些提议proposal未在leader上提交，follower需要回滚zxid为maxCommittedLog对应的事务操作<br>4) TRUNC-DIFF-回滚+增量同步  </li>\n<li>条件： minCommittedLog &lt;= peerLastZxid &lt;= maxCommittedLog</li>\n<li>说明： leader a已经将事务truncA提交到本地事务日志中，然后还未成功发起proposal协议进行投票就宕机了；然后集群中剔除leader a重新选举出leader b,<br>新leader b提交了若干新的提议proposal，若原有leader a恢复后重新加入集群，需要先回滚truncA,然后增量同步leader b上的数据。  </li>\n</ul>\n<h3 id=\"12-2-7-分布式通知与协调\"><a href=\"#12-2-7-分布式通知与协调\" class=\"headerlink\" title=\"12.2.7 分布式通知与协调\"></a>12.2.7 分布式通知与协调</h3><p>对于系统调度来说：操作人员发送通知实际是通过控制台改变某个节点的状态，然后zk将这些变化发送给注册了这个节点watcher的所有客户端<br>对于执行情况汇报：每个工作进程都在某个目录节点下创建一个临时节点，并携带工作的进度数据，这样汇总进程通过监控某个节点的变化来获取工作进度的实时的全局情况  </p>\n<h3 id=\"12-2-8-zk的session机制\"><a href=\"#12-2-8-zk的session机制\" class=\"headerlink\" title=\"12.2.8 zk的session机制\"></a>12.2.8 zk的session机制</h3><p>zookeeper会为每个客户端分配一个session,类似于web服务器一样，用来标识客户端的身份<br><strong>session的作用：</strong>   </p>\n<ul>\n<li>客户端标识</li>\n<li>超时检查</li>\n<li>请求的顺序执行</li>\n<li>维护临时节点的生命周期</li>\n<li>watcher通知    </li>\n</ul>\n<p><strong>session的状态：</strong>  </p>\n<ul>\n<li>CONNECTING</li>\n<li>CONNECTED</li>\n<li>RECONNECTING</li>\n<li>RECONNECTED</li>\n<li>CLOSED</li>\n</ul>\n<p><strong>session的属性：</strong>    </p>\n<ul>\n<li>SessionID: 会话ID，全局唯一<ul>\n<li>高8位表示创建session时所在zk节点的id</li>\n<li>中间40位表示zk节点当前角色创建时的时间戳</li>\n<li>低16位是一个计数器，初始值为0</li>\n</ul>\n</li>\n<li>TimeOut: 会话超时时间</li>\n<li>TickTime: 下次会话超时时间点</li>\n<li>isClosing: 会话是否已经被关闭</li>\n</ul>\n","categories":["JAVA"],"tags":["面试","JAVA"]},{"title":"49_字母异位词分组_leetcode","url":"http://www.shenjian.online/2020/01/05/49-字母异位词分组-leetcode/","content":"<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。<br>说明：所有输入均为小写字母。不考虑答案输出的顺序。</p>\n<blockquote>\n<p>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>输出:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]</p>\n</blockquote>\n<p><strong>题解：</strong>  字典表 + 哈希表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 字符共26个,故可设置字典表数组大小为26，将串映射到字典表中，</span></span><br><span class=\"line\"><span class=\"comment\"> * 然后将字典表中value拼接成key,存储到哈希表判断即可</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class=\"line\">        Map&lt;String, List&lt;String&gt;&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; strs[i].length(); j++) &#123;</span><br><span class=\"line\">                nums[strs[i].charAt(j) - <span class=\"string\">'a'</span>]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">                sb.append(nums[j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String key = sb.toString();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.get(key) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                map.get(key).add(strs[i]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                List&lt;String&gt; value = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">                value.add(strs[i]);</span><br><span class=\"line\">                map.put(key, value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;(map.values());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/group-anagrams/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"48_旋转图像_leetcode","url":"http://www.shenjian.online/2020/01/04/48-旋转图像-leetcode/","content":"<h2 id=\"48-旋转图像\"><a href=\"#48-旋转图像\" class=\"headerlink\" title=\"48. 旋转图像\"></a>48. 旋转图像</h2><p>给定一个 n × n 的二维矩阵表示一个图像。<br>将图像顺时针旋转 90 度。<br>说明：<br>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>\n<blockquote>\n<p>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],<br>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]</p>\n</blockquote>\n<p><strong>题解：</strong> 详见注释</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] matrix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = matrix.length;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 把矩形分为四部分，上下左右，首先存储左边，然后顺时针开始旋转赋值</span></span><br><span class=\"line\"><span class=\"comment\">         * 则左边 下-&gt;上，行减小，列不变 matrix[n-1-j][i]</span></span><br><span class=\"line\"><span class=\"comment\">         *  下边 右-&gt;左，行不变，列减小 matrix[n-1-i][n-1-j] 该列与上边行相同均为n-1-j</span></span><br><span class=\"line\"><span class=\"comment\">         *  右边 上-&gt;下，行增大，列不变 matrix[j][n-1-i] 该列与上边行相同均为n-1-i</span></span><br><span class=\"line\"><span class=\"comment\">         *  上边 左-&gt;右，行不变，列增大 matrix[i][j] 该列与上边行相同均为j</span></span><br><span class=\"line\"><span class=\"comment\">         * 不知是否发现规律，无非就是 i,j,n-1-i,n-1-j 行与列组合, 下次直接记住左边matrix[n-1-j][i]，并记住上面的规律即可快速解题</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; (n + <span class=\"number\">1</span>) / <span class=\"number\">2</span>; i ++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n / <span class=\"number\">2</span>; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> temp = matrix[n - <span class=\"number\">1</span> - j][i];</span><br><span class=\"line\">                matrix[n - <span class=\"number\">1</span> - j][i] = matrix[n - <span class=\"number\">1</span> - i][n - j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                matrix[n - <span class=\"number\">1</span> - i][n - j - <span class=\"number\">1</span>] = matrix[j][n - <span class=\"number\">1</span> -i];</span><br><span class=\"line\">                matrix[j][n - <span class=\"number\">1</span> - i] = matrix[i][j];</span><br><span class=\"line\">                matrix[i][j] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/rotate-image/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"47_全排列II_leetcode","url":"http://www.shenjian.online/2019/12/29/47-全排列II-leetcode/","content":"<h2 id=\"47-全排列II\"><a href=\"#47-全排列II\" class=\"headerlink\" title=\"47. 全排列II\"></a>47. 全排列II</h2><p>给定一个可包含重复数字的序列，返回所有不重复的全排列</p>\n<blockquote>\n<p>示例:<br>输入: [1,1,2]<br>输出:<br>[<br>  [1,1,2],<br>  [1,2,1],<br>  [2,1,1]<br>]</p>\n</blockquote>\n<p><strong>题解：</strong> 排序+回溯算法+剪枝，Set用于判断数字是否已经用于排列，Stack先进后出特性 + 递归实现回溯</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = nums.length;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Set&lt;Integer&gt; used = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        Stack&lt;Integer&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 首先排序，之后才有可能发现重复分支</span></span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        backtrack(nums, <span class=\"number\">0</span>, len, used, stack, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> depth, <span class=\"keyword\">int</span> len, Set&lt;Integer&gt; used, Stack&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (depth == nums.length) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> ArrayList&lt;&gt;(stack));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 剪枝： 和之前的数相等，并且之前的数没有使用过，才会出现相同分支</span></span><br><span class=\"line\">        \t<span class=\"comment\">// 如 1 2 2 2, 去除相同的1 2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i -<span class=\"number\">1</span>] &amp;&amp; !used.contains(i - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!used.contains(i)) &#123;</span><br><span class=\"line\">                used.add(i);</span><br><span class=\"line\">                stack.push(nums[i]);</span><br><span class=\"line\">                backtrack(nums, depth + <span class=\"number\">1</span>, len, used, stack, res);</span><br><span class=\"line\">                stack.pop();</span><br><span class=\"line\">                used.remove(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/permutations-ii/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"46_全排列_leetcode","url":"http://www.shenjian.online/2019/12/28/46-全排列-leetcode/","content":"<h2 id=\"46-全排列\"><a href=\"#46-全排列\" class=\"headerlink\" title=\"46. 全排列\"></a>46. 全排列</h2><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p>\n<blockquote>\n<p>示例:<br>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p>\n</blockquote>\n<p><strong>题解：</strong> 回溯算法，Set用于判断数字是否已经用于排列，Stack先进后出特性 + 递归实现回溯</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = nums.length;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Set&lt;Integer&gt; used = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        Stack&lt;Integer&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        backtrack(nums, <span class=\"number\">0</span>, len, used, stack, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> depth, <span class=\"keyword\">int</span> len, Set&lt;Integer&gt; used, Stack&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (depth == nums.length) &#123; <span class=\"comment\">// 全部数字已排列完，加入结果集</span></span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> ArrayList&lt;&gt;(stack));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!used.contains(i)) &#123; <span class=\"comment\">// 排列之前未排列的数字</span></span><br><span class=\"line\">                used.add(i);</span><br><span class=\"line\">                stack.push(nums[i]);</span><br><span class=\"line\">                <span class=\"comment\">// 递归求解</span></span><br><span class=\"line\">                backtrack(nums, depth + <span class=\"number\">1</span>, len, used, stack, res);</span><br><span class=\"line\">                stack.pop();</span><br><span class=\"line\">                used.remove(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/permutations/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"45_跳跃游戏II_leetcode","url":"http://www.shenjian.online/2019/12/19/45-跳跃游戏II-leetcode/","content":"<h2 id=\"45-跳跃游戏II\"><a href=\"#45-跳跃游戏II\" class=\"headerlink\" title=\"45. 跳跃游戏II\"></a>45. 跳跃游戏II</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>\n<blockquote>\n<p>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。<br>说明:<br>假设你总是可以到达数组的最后一个位置。</p>\n</blockquote>\n<p><strong>题解：</strong> 贪心算法 每次在可跳范围内选择可以使得跳的更远的位置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">jump</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> end = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxPosition = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> steps = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//  for 循环中，i &lt; nums.length - 1，少了末尾。</span></span><br><span class=\"line\">        <span class=\"comment\">//  因为开始的时候边界是第0个位置，steps已经加1了。</span></span><br><span class=\"line\">        <span class=\"comment\">//  如果最后一步刚好跳到了末尾，此时steps其实不用加1了。</span></span><br><span class=\"line\">        <span class=\"comment\">//  如果是i &lt; nums.length，i遍历到最后的时候，会进入if语句中，steps会多加1。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            maxPosition = Math.max(maxPosition, nums[i] + i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == end) &#123;</span><br><span class=\"line\">                end = maxPosition;</span><br><span class=\"line\">                steps++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> steps;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/jump-game-ii/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"43_字符串相乘_leetcode","url":"http://www.shenjian.online/2019/12/17/43-字符串相乘-leetcode/","content":"<h2 id=\"43-字符串相乘\"><a href=\"#43-字符串相乘\" class=\"headerlink\" title=\"43. 字符串相乘\"></a>43. 字符串相乘</h2><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>\n<blockquote>\n<p>输入: num1 = “123”, num2 = “456”<br>输出: “56088”</p>\n</blockquote>\n<p><strong>题解：</strong> 用一个数组存储乘积，根据两数相乘特定的位偏移关系求解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">multiply</span><span class=\"params\">(String num1, String num2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">\"0\"</span>.equals(num1) || <span class=\"string\">\"0\"</span>.equals(num2)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"0\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 99 * 99 值长度小于4位，故设此数组长度</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] digits = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[num1.length() + num2.length()];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = num1.length() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = num2.length() - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> digit = (num1.charAt(i) - <span class=\"string\">'0'</span>) * (num2.charAt(j) - <span class=\"string\">'0'</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 如234*567，数组长度为6，设当前i=2,j=2,</span></span><br><span class=\"line\">                <span class=\"comment\">// 则4*7的低位8位于(i+j+1)=5处，高位位于(i+j)处</span></span><br><span class=\"line\">                digit += digits[i + j + <span class=\"number\">1</span>]; <span class=\"comment\">// 先加低位看是否有新进位</span></span><br><span class=\"line\">                digits[i + j + <span class=\"number\">1</span>] = digit % <span class=\"number\">10</span>;</span><br><span class=\"line\">                digits[i + j] += digit / <span class=\"number\">10</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (digits[<span class=\"number\">0</span>] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            sb.append(digits[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; digits.length; i++) &#123;</span><br><span class=\"line\">            sb.append(digits[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/multiply-strings/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"HBase基础操作(JAVA版)","url":"http://www.shenjian.online/2019/12/15/HBase基础操作-JAVA版/","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HBaseTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Configuration conf;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Connection conn;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getConfigAndConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        conf = HBaseConfiguration.create();</span><br><span class=\"line\">        <span class=\"comment\">// qurom与clientPort默认属性位于hbase-common包中hbase-default.xml中</span></span><br><span class=\"line\">        conf.set(<span class=\"string\">\"hbase.zookeeper.quorum\"</span>, <span class=\"string\">\"192.168.153.171\"</span>);</span><br><span class=\"line\">        conf.set(<span class=\"string\">\"hbase.zookeeper.property.clientPort\"</span>, <span class=\"string\">\"2181\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置重试次数,第一次连接为了及时打印结果，重试1次</span></span><br><span class=\"line\">        conf.set(<span class=\"string\">\"hbase.client.retries.number\"</span>, <span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">        conn = ConnectionFactory.createConnection(conf);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testCreateTable</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Admin admin = conn.getAdmin();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!admin.isTableAvailable(TableName.valueOf(<span class=\"string\">\"testtable\"</span>))) &#123;</span><br><span class=\"line\">            TableName tableName = TableName.valueOf(<span class=\"string\">\"testtable\"</span>);</span><br><span class=\"line\">            TableDescriptorBuilder tableDescriptorBuilder = TableDescriptorBuilder.newBuilder(tableName);</span><br><span class=\"line\">            <span class=\"comment\">// 获取列族描述器</span></span><br><span class=\"line\">            ColumnFamilyDescriptor columnFamilyDescriptor = ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes(<span class=\"string\">\"user\"</span>)).build();</span><br><span class=\"line\">            tableDescriptorBuilder.setColumnFamily(columnFamilyDescriptor);</span><br><span class=\"line\">            <span class=\"comment\">// 获取表描述器</span></span><br><span class=\"line\">            TableDescriptor tableDescriptor = tableDescriptorBuilder.build();</span><br><span class=\"line\">            admin.createTable(tableDescriptor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testPuts</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        List&lt;Put&gt; puts = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        Put putOne = <span class=\"keyword\">new</span> Put(Bytes.toBytes(<span class=\"string\">\"row1\"</span>));</span><br><span class=\"line\">        putOne.addColumn(Bytes.toBytes(<span class=\"string\">\"user\"</span>), Bytes.toBytes(<span class=\"string\">\"qua1\"</span>), Bytes.toBytes(<span class=\"string\">\"shenjian\"</span>));</span><br><span class=\"line\">        puts.add(putOne);</span><br><span class=\"line\"></span><br><span class=\"line\">        Put putTwo = <span class=\"keyword\">new</span> Put(Bytes.toBytes(<span class=\"string\">\"row1\"</span>));</span><br><span class=\"line\">        putTwo.addColumn(Bytes.toBytes(<span class=\"string\">\"user\"</span>), Bytes.toBytes(<span class=\"string\">\"qual2\"</span>), Bytes.toBytes(<span class=\"string\">\"domi\"</span>));</span><br><span class=\"line\">        puts.add(putTwo);</span><br><span class=\"line\"></span><br><span class=\"line\">        Table table = conn.getTable(TableName.valueOf(<span class=\"string\">\"testtable\"</span>));</span><br><span class=\"line\">        table.put(puts);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testCAS</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Put put = <span class=\"keyword\">new</span> Put(Bytes.toBytes(<span class=\"string\">\"row1\"</span>));</span><br><span class=\"line\">        put.addColumn(Bytes.toBytes(<span class=\"string\">\"user\"</span>), Bytes.toBytes(<span class=\"string\">\"qua1\"</span>), Bytes.toBytes(<span class=\"string\">\"shenjian\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        Table table = conn.getTable(TableName.valueOf(<span class=\"string\">\"testtable\"</span>));</span><br><span class=\"line\">        table.checkAndMutate(Bytes.toBytes(<span class=\"string\">\"row1\"</span>), Bytes.toBytes(<span class=\"string\">\"user\"</span>))</span><br><span class=\"line\">                .qualifier(Bytes.toBytes(<span class=\"string\">\"qual\"</span>))</span><br><span class=\"line\">                .ifNotExists()</span><br><span class=\"line\">                .thenPut(put);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testGet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Table table = conn.getTable(TableName.valueOf(<span class=\"string\">\"testtable\"</span>));</span><br><span class=\"line\">        Get get = <span class=\"keyword\">new</span> Get(Bytes.toBytes(<span class=\"string\">\"row1\"</span>));</span><br><span class=\"line\">        get.addColumn(Bytes.toBytes(<span class=\"string\">\"user\"</span>), Bytes.toBytes(<span class=\"string\">\"qua1\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        Result result = table.get(get);</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] val = result.getValue(Bytes.toBytes(<span class=\"string\">\"user\"</span>), Bytes.toBytes(<span class=\"string\">\"qua1\"</span>));</span><br><span class=\"line\">        Assert.assertEquals(<span class=\"string\">\"shenjian\"</span>, Bytes.toString(val));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testDelete</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Table table = conn.getTable(TableName.valueOf(<span class=\"string\">\"testtable\"</span>));</span><br><span class=\"line\">        Delete delete = <span class=\"keyword\">new</span> Delete(Bytes.toBytes(<span class=\"string\">\"row1\"</span>));</span><br><span class=\"line\">        delete.addColumns(Bytes.toBytes(<span class=\"string\">\"user\"</span>), Bytes.toBytes(<span class=\"string\">\"qual2\"</span>), <span class=\"number\">1576391337431l</span>);</span><br><span class=\"line\">        table.delete(delete);</span><br><span class=\"line\">        table.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testScan</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Table table = conn.getTable(TableName.valueOf(<span class=\"string\">\"testtable\"</span>));</span><br><span class=\"line\">        Scan scan = <span class=\"keyword\">new</span> Scan();</span><br><span class=\"line\">        ResultScanner resultScanner = table.getScanner(scan);</span><br><span class=\"line\">        scan.addColumn(Bytes.toBytes(<span class=\"string\">\"user\"</span>), Bytes.toBytes(<span class=\"string\">\"name\"</span>));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Result res : resultScanner) &#123;</span><br><span class=\"line\">            System.out.println(res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@After</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        conn.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["HBase"],"tags":["HBase"]},{"title":"HBase2.2基本操作","url":"http://www.shenjian.online/2019/12/15/HBase2-2基本操作/","content":"<h2 id=\"1-多版本操作日志\"><a href=\"#1-多版本操作日志\" class=\"headerlink\" title=\"1. 多版本操作日志\"></a>1. 多版本操作日志</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create <span class=\"string\">'test'</span>, <span class=\"string\">'cf1'</span> <span class=\"comment\"># 创建表test,列族cf1</span></span><br><span class=\"line\">describe <span class=\"string\">'test'</span> <span class=\"comment\"># 查看表基本信息，默认只存1个版本</span></span><br><span class=\"line\">alter <span class=\"string\">'test'</span>,&#123;NAME=&gt;<span class=\"string\">'cf1'</span>, VERSIONS=&gt;<span class=\"string\">'3'</span>&#125; <span class=\"comment\"># 查看表基本信息，改为保存3个版本</span></span><br><span class=\"line\">put <span class=\"string\">'test'</span>,<span class=\"string\">'row1'</span>,<span class=\"string\">'cf1:name'</span>,<span class=\"string\">'shenjian'</span> <span class=\"comment\"># 插入数据第一个版本</span></span><br><span class=\"line\">put <span class=\"string\">'test'</span>,<span class=\"string\">'row1'</span>,<span class=\"string\">'cf1:name'</span>,<span class=\"string\">'domi'</span> <span class=\"comment\"># 插入数据第二个版本</span></span><br><span class=\"line\">scan <span class=\"string\">'test'</span>, &#123;VERSIONS=&gt;3&#125; <span class=\"comment\"># 查看多版本数据</span></span><br></pre></td></tr></table></figure>\n","categories":["HBase"],"tags":["HBase"]},{"title":"HBase2.2初装与Java客户端连接","url":"http://www.shenjian.online/2019/12/14/HBase2-2初装与Java客户端连接/","content":"<h2 id=\"1-HBase目录结构\"><a href=\"#1-HBase目录结构\" class=\"headerlink\" title=\"1. HBase目录结构\"></a>1. HBase目录结构</h2><p><img src=\"/2019/12/14/HBase2-2初装与Java客户端连接/1.PNG\" alt=\"结构\"></p>\n<h2 id=\"2-启动\"><a href=\"#2-启动\" class=\"headerlink\" title=\"2. 启动\"></a>2. 启动</h2><p><code>./bin/start-base/sh</code></p>\n<p><img src=\"/2019/12/14/HBase2-2初装与Java客户端连接/start.PNG\" alt=\"启动\"></p>\n<h2 id=\"3-查看是否启动成功\"><a href=\"#3-查看是否启动成功\" class=\"headerlink\" title=\"3. 查看是否启动成功\"></a>3. 查看是否启动成功</h2><p>访问 <a href=\"http://192.168.153.171:16010/\" target=\"_blank\" rel=\"noopener\">http://192.168.153.171:16010/</a></p>\n<p><img src=\"/2019/12/14/HBase2-2初装与Java客户端连接/ui.png\" alt=\"ui\"></p>\n<p><strong>注意：serverName为centos7,常见的Java连接HBase UnknowHostException一般由此产生</strong></p>\n<p>执行<code>hostname</code>查看虚拟机名称，发现centos7名称正好与serverName吻合</p>\n<p><img src=\"/2019/12/14/HBase2-2初装与Java客户端连接/hostname.png\" alt=\"hostname\"></p>\n<h2 id=\"4-虚拟机hostname修改\"><a href=\"#4-虚拟机hostname修改\" class=\"headerlink\" title=\"4. 虚拟机hostname修改\"></a>4. 虚拟机hostname修改</h2><p>临时修改：<code>hostname 192.168.153.171</code> 单机非集群版改为IP,省去DNS解析，简单粗暴<br>永久修改：<br>1）<code>vim /etc/hostname</code>将centos7改为192.168.153.171<br>2）执行<code>systemctl restart network.service</code>重启网络</p>\n<p><img src=\"/2019/12/14/HBase2-2初装与Java客户端连接/ip.png\" alt=\"ip\"><br><img src=\"/2019/12/14/HBase2-2初装与Java客户端连接/update.png\" alt=\"update\"></p>\n<h2 id=\"5-重启Hbase\"><a href=\"#5-重启Hbase\" class=\"headerlink\" title=\"5. 重启Hbase\"></a>5. 重启Hbase</h2><p>执行<code>./bin/stop-base/sh</code>，如果一直…,则执行<code>jps</code>查看HMaster进程，杀死即可</p>\n<p><img src=\"/2019/12/14/HBase2-2初装与Java客户端连接/restart.png\" alt=\"restart\"><br>访问 <a href=\"http://192.168.153.171:16010/\" target=\"_blank\" rel=\"noopener\">http://192.168.153.171:16010/</a>, 发现serverName已经更改过来<br><img src=\"/2019/12/14/HBase2-2初装与Java客户端连接/updated.png\" alt=\"updated\"></p>\n<h2 id=\"6-与shell交互\"><a href=\"#6-与shell交互\" class=\"headerlink\" title=\"6. 与shell交互\"></a>6. 与shell交互</h2><p>执行<code>./bin/hbase shell</code>进入交互页面<br>执行以下命令创建表并查看表<br><img src=\"/2019/12/14/HBase2-2初装与Java客户端连接/crud.png\" alt=\"crud\"></p>\n<h2 id=\"7-JAVA客户端连接\"><a href=\"#7-JAVA客户端连接\" class=\"headerlink\" title=\"7. JAVA客户端连接\"></a>7. JAVA客户端连接</h2><h3 id=\"7-1-创建maven项目并引入pom-xml\"><a href=\"#7-1-创建maven项目并引入pom-xml\" class=\"headerlink\" title=\"7.1 创建maven项目并引入pom.xml\"></a>7.1 创建maven项目并引入pom.xml</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- https://mvnrepository.com/artifact/org.apache.hbase/hbase-client --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.hbase<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>hbase-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-2-resource资源目录下新建log4j-properties文件\"><a href=\"#7-2-resource资源目录下新建log4j-properties文件\" class=\"headerlink\" title=\"7.2 resource资源目录下新建log4j.properties文件\"></a>7.2 resource资源目录下新建log4j.properties文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log4j.rootLogger=INFO, stdout</span><br><span class=\"line\"></span><br><span class=\"line\">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class=\"line\">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\"></span><br><span class=\"line\"># Pattern to output the caller&apos;s file name and line number.</span><br><span class=\"line\">log4j.appender.stdout.layout.ConversionPattern=%5p [%t] (%F:%L) - %m%n</span><br><span class=\"line\"></span><br><span class=\"line\">log4j.logger.org.apache=WARN</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-3-JAVA代码编写\"><a href=\"#7-3-JAVA代码编写\" class=\"headerlink\" title=\"7.3 JAVA代码编写\"></a>7.3 JAVA代码编写</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PutExample</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Configuration conf = HBaseConfiguration.create();</span><br><span class=\"line\">        <span class=\"comment\">// qurom与clientPort默认属性位于hbase-common包中hbase-default.xml中，见下图</span></span><br><span class=\"line\">        conf.set(<span class=\"string\">\"hbase.zookeeper.quorum\"</span>, <span class=\"string\">\"192.168.153.171\"</span>);</span><br><span class=\"line\">        conf.set(<span class=\"string\">\"hbase.zookeeper.property.clientPort\"</span>, <span class=\"string\">\"2181\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置重试次数,第一次连接为了及时打印结果，重试1次</span></span><br><span class=\"line\">        conf.set(<span class=\"string\">\"hbase.client.retries.number\"</span>, <span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">        Admin admin = ConnectionFactory.createConnection(conf).getAdmin();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (admin != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           TableName[] tableNames = admin.listTableNames();</span><br><span class=\"line\">           <span class=\"keyword\">for</span> (TableName name : tableNames) &#123;</span><br><span class=\"line\">               System.out.println(name);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/12/14/HBase2-2初装与Java客户端连接/qurom.png\" alt=\"qurom\"></p>\n<p>执行结果：<br><img src=\"/2019/12/14/HBase2-2初装与Java客户端连接/result.png\" alt=\"result\"></p>\n","categories":["HBase"],"tags":["HBase"]},{"title":"42_接雨水_leetcode","url":"http://www.shenjian.online/2019/12/13/42-接雨水-leetcode/","content":"<h2 id=\"42-接雨水\"><a href=\"#42-接雨水\" class=\"headerlink\" title=\"42. 接雨水\"></a>42. 接雨水</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。(该题出现过字节跳动的笔试题中)</p>\n<p><img src=\"/2019/12/13/42-接雨水-leetcode/雨水.png\" alt=\"雨水\"></p>\n<blockquote>\n<p>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6</p>\n</blockquote>\n<p><strong>题解：</strong> 双指针求解法，左右索引向中间靠拢，记录当前左右最高高度，<br>若左索引小于左最高点，则可积水，更新积水面积；<br>若左索引大于等于左最高点，则不可积水，更新左最高点，<br>右索引同理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">trap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> leftHeightMax = <span class=\"number\">0</span>, rightHeightMax = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = height.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (height[left] &gt;= leftHeightMax) &#123;</span><br><span class=\"line\">                    leftHeightMax = height[left];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    ans += leftHeightMax - height[left];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (height[right] &gt;= rightHeightMax) &#123;</span><br><span class=\"line\">                    rightHeightMax = height[right];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    ans += rightHeightMax - height[right];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/trapping-rain-water/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"40_组合总和II_leetcode","url":"http://www.shenjian.online/2019/12/11/40-组合总和II-leetcode/","content":"<h2 id=\"40-组合总和II\"><a href=\"#40-组合总和II\" class=\"headerlink\" title=\"40. 组合总和II\"></a>40. 组合总和II</h2><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的每个数字在每个组合中只能使用一次<br>说明：所有数字（包括目标数）都是正整数。解集不能包含重复的组合。 </p>\n<blockquote>\n<p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]</p>\n</blockquote>\n<p><strong>题解：</strong> 回溯算法+剪枝，关键在于栈与递归巧妙应用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 回溯 + 剪枝</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] candidates;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class=\"keyword\">int</span>[] candidates, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (candidates == <span class=\"keyword\">null</span> || candidates.length &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Arrays.sort(candidates);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.len = candidates.length;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.candidates = candidates;</span><br><span class=\"line\">        findCombinationSum2(target, <span class=\"number\">0</span>, <span class=\"keyword\">new</span> Stack&lt;&gt;());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">findCombinationSum2</span><span class=\"params\">(<span class=\"keyword\">int</span> residue, <span class=\"keyword\">int</span> start, Stack&lt;Integer&gt; pre)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (residue == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 进行结算，即找到解</span></span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> ArrayList&lt;&gt;(pre));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// residue - candidates[i] &gt;= 0 剪枝</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start; i &lt; len &amp;&amp; residue - candidates[i] &gt;= <span class=\"number\">0</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 相同部分剪枝(与题目39组合总和主要不同之处)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            pre.add(candidates[i]);</span><br><span class=\"line\">            findCombinationSum2(residue - candidates[i], i + <span class=\"number\">1</span>, pre);</span><br><span class=\"line\">            pre.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/combination-sum-ii/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"39_组合总和_leetcode","url":"http://www.shenjian.online/2019/12/10/39-组合总和-leetcode/","content":"<h2 id=\"39-组合总和\"><a href=\"#39-组合总和\" class=\"headerlink\" title=\"39. 组合总和\"></a>39. 组合总和</h2><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的数字可以无限制重复被选取。<br>说明：所有数字（包括 target）都是正整数。解集不能包含重复的组合。 </p>\n<blockquote>\n<p>输入: candidates = [2,3,6,7], target = 7,<br>所求解集为:<br>[<br>  [7],<br>  [2,2,3]<br>]</p>\n</blockquote>\n<p><strong>题解：</strong> 回溯算法+剪枝，关键在于栈与递归巧妙应用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 回溯 + 剪枝</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] candidates;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class=\"keyword\">int</span>[] candidates, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (candidates == <span class=\"keyword\">null</span> || candidates.length &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Arrays.sort(candidates);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.len = candidates.length;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.candidates = candidates;</span><br><span class=\"line\">        findCombinationSum(target, <span class=\"number\">0</span>, <span class=\"keyword\">new</span> Stack&lt;&gt;());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">findCombinationSum</span><span class=\"params\">(<span class=\"keyword\">int</span> residue, <span class=\"keyword\">int</span> start, Stack&lt;Integer&gt; pre)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (residue == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 进行结算，即找到解</span></span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> ArrayList&lt;&gt;(pre));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// residue - candidates[i] &gt;= 0 剪枝小于0的解</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start; i &lt; len &amp;&amp; residue - candidates[i] &gt;= <span class=\"number\">0</span>; i++) &#123;</span><br><span class=\"line\">            pre.add(candidates[i]);</span><br><span class=\"line\">            <span class=\"comment\">// 因为candidates 中的数字可以无限制重复被选取，故仍然取i</span></span><br><span class=\"line\">            findCombinationSum(residue - candidates[i], i, pre);</span><br><span class=\"line\">            pre.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/combination-sum/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"美团面试篇","url":"http://www.shenjian.online/2019/12/02/美团面试篇/","content":"<h3 id=\"1-java虚拟机内存模型\"><a href=\"#1-java虚拟机内存模型\" class=\"headerlink\" title=\"1. java虚拟机内存模型\"></a>1. java虚拟机内存模型</h3><p><a href=\"https://shenjian.online/2019/03/21/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E3%80%81JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E3%80%81JAVA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/\" target=\"_blank\" rel=\"noopener\">java内存模型</a></p>\n<h3 id=\"2-内存溢出一般发生在哪个区？永久代会不会导致内存溢出\"><a href=\"#2-内存溢出一般发生在哪个区？永久代会不会导致内存溢出\" class=\"headerlink\" title=\"2. 内存溢出一般发生在哪个区？永久代会不会导致内存溢出\"></a>2. 内存溢出一般发生在哪个区？永久代会不会导致内存溢出</h3><p>堆内存溢出、栈内存溢出。永久代是JDK1.7中方法区的一种实现，会导致内存溢出，最常见的是大量JSP文件导致永久代溢出</p>\n<h3 id=\"3-动态加载类的框架了解哪些\"><a href=\"#3-动态加载类的框架了解哪些\" class=\"headerlink\" title=\"3. 动态加载类的框架了解哪些\"></a>3. 动态加载类的框架了解哪些</h3><p>JDK动态代理、CGLIB框架 <a href=\"https://github.com/SJshenjian/web-project/blob/master/proxy\" target=\"_blank\" rel=\"noopener\">proxy</a></p>\n<h3 id=\"4-动态代理一般有哪几种实现方式？动态代理的应用场景有哪些\"><a href=\"#4-动态代理一般有哪几种实现方式？动态代理的应用场景有哪些\" class=\"headerlink\" title=\"4. 动态代理一般有哪几种实现方式？动态代理的应用场景有哪些\"></a>4. 动态代理一般有哪几种实现方式？动态代理的应用场景有哪些</h3><p>JDK动态代理、CGLIB框架 <a href=\"https://github.com/SJshenjian/web-project/blob/master/proxy\" target=\"_blank\" rel=\"noopener\">proxy</a></p>\n<p>应用场景：</p>\n<ul>\n<li>统计每个API的请求耗时</li>\n<li>统一的日志输出</li>\n<li>检验被调用的API是否已经登录和权限鉴定</li>\n<li>事务处理</li>\n</ul>\n<h3 id=\"5-栈会不会溢出？栈溢出一般抛什么异常？jvm在哪里设置栈的大小？设置的参数是什么？\"><a href=\"#5-栈会不会溢出？栈溢出一般抛什么异常？jvm在哪里设置栈的大小？设置的参数是什么？\" class=\"headerlink\" title=\"5. 栈会不会溢出？栈溢出一般抛什么异常？jvm在哪里设置栈的大小？设置的参数是什么？\"></a>5. 栈会不会溢出？栈溢出一般抛什么异常？jvm在哪里设置栈的大小？设置的参数是什么？</h3><p>会。StackOverflowError -Xss256K</p>\n<h3 id=\"6-用过哪些命令查看jvm的状态、堆栈信息？\"><a href=\"#6-用过哪些命令查看jvm的状态、堆栈信息？\" class=\"headerlink\" title=\"6. 用过哪些命令查看jvm的状态、堆栈信息？\"></a>6. 用过哪些命令查看jvm的状态、堆栈信息？</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\">top <span class=\"comment\"># 列出消耗CPU靠前的进程</span></span><br><span class=\"line\">top + H <span class=\"comment\"># 列出消耗CPU靠前的线程</span></span><br><span class=\"line\">jstack [进程]|grep -A 10 [线程的16进制] <span class=\"comment\"># jstack查找这个线程的信息 -A 10表示查找到所在行的后10行</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 频繁GC问题或内存溢出问题</span></span><br><span class=\"line\">jps <span class=\"comment\"># 线程PID查看</span></span><br><span class=\"line\">jstat -gc 3331 250 20 <span class=\"comment\"># 查看GC情况</span></span><br><span class=\"line\">jstat -gccause <span class=\"comment\"># 额外输出上次GC原因</span></span><br><span class=\"line\">jmap -dump:format=b,file=heapDump <span class=\"comment\"># 3331生成堆转储文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 死锁问题</span></span><br><span class=\"line\">jps <span class=\"comment\"># 线程PID查看</span></span><br><span class=\"line\">jstack 1159 &gt; /opt/temp/dump1 <span class=\"comment\"># 转储查看线程情况</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://www.cnblogs.com/snake23/archive/2019/01/28/10329149.html\" target=\"_blank\" rel=\"noopener\">详细参考</a></p>\n<h3 id=\"7-jvm的垃圾回收机制\"><a href=\"#7-jvm的垃圾回收机制\" class=\"headerlink\" title=\"7. jvm的垃圾回收机制\"></a>7. jvm的垃圾回收机制</h3><p>垃圾收集算法： 复制算法、标记-清除算法、标记-整理算法、分代收集算法<br><a href=\"https://shenjian.online/2019/11/03/%E8%85%BE%E8%AE%AF%E7%AF%87%E4%B9%8BJVM/#6-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\" target=\"_blank\" rel=\"noopener\">垃圾回收算法的实现原理</a><br><a href=\"https://shenjian.online/2019/11/03/%E8%85%BE%E8%AE%AF%E7%AF%87%E4%B9%8BJVM/#5-%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E5%87%A0%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%8C%E9%87%8D%E7%82%B9%E8%AE%B2%E4%B8%8Bcms%E5%92%8CG1%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%8E%9F%E7%90%86%EF%BC%8C%E6%B5%81%E7%A8%8B%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9\" target=\"_blank\" rel=\"noopener\">几种垃圾收集器</a></p>\n<h3 id=\"8-java类加载机制？如何实现自定义类加载器？findClass与loadClass的区别？\"><a href=\"#8-java类加载机制？如何实现自定义类加载器？findClass与loadClass的区别？\" class=\"headerlink\" title=\"8. java类加载机制？如何实现自定义类加载器？findClass与loadClass的区别？\"></a>8. java类加载机制？如何实现自定义类加载器？findClass与loadClass的区别？</h3><p><a href=\"https://my.oschina.net/u/1458864/blog/2004785\" target=\"_blank\" rel=\"noopener\">类加载机制</a></p>\n<p><strong>实现自定义类加载器</strong><br>继承自ClassLoader，并重写findClass()与loadClass()</p>\n<p><strong>区别</strong><br>findClass()用于写类加载逻辑，loadClass()里的逻辑里如果父类加载器加载失败则会调用自己的findClass()来完成，保证了双亲委派原则<br>如果不想破坏双亲委派模型，只需要重写findClass();如果想打破双亲委派模型，则重写loadClass()</p>\n<h3 id=\"8-String、StringBuffer、StringBuilder的区别？对应的使用场景？\"><a href=\"#8-String、StringBuffer、StringBuilder的区别？对应的使用场景？\" class=\"headerlink\" title=\"8. String、StringBuffer、StringBuilder的区别？对应的使用场景？\"></a>8. String、StringBuffer、StringBuilder的区别？对应的使用场景？</h3><table>\n<thead>\n<tr>\n<th>item</th>\n<th>‘+’区别</th>\n<th>多线程</th>\n<th>性能</th>\n<th>使用场景</th>\n<th>优化</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>String</td>\n<td>不可变类，重新创建字符串</td>\n<td>不安全</td>\n<td>操作少量数据，字符串不变时</td>\n<td>无</td>\n</tr>\n<tr>\n<td>StringBuilder</td>\n<td>可变类，原字符串基础上生成字符串</td>\n<td>不安全</td>\n<td>性能最好（比StringBuffer高10%~15%）</td>\n<td>单线程用于操作大量数据（方法内部，用完回收）</td>\n<td>尽可能指定容量（默认16，不超过16字符不用指定），不指定显著降低性能</td>\n</tr>\n<tr>\n<td>StringBuffer</td>\n<td>可变类，原字符串基础上生成字符串</td>\n<td>安全</td>\n<td>性能好</td>\n<td>主要用在全局变量中，多线程下安全</td>\n<td>同StringBuilder</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"9-如何实现不可变的类\"><a href=\"#9-如何实现不可变的类\" class=\"headerlink\" title=\"9. 如何实现不可变的类\"></a>9. 如何实现不可变的类</h3><ul>\n<li>class声明为final,不可以被继承</li>\n<li>field都是private final,不能提供它们的setter方法</li>\n<li>使用私有的构造器通过深拷贝初始化成员变量</li>\n<li>在getter方法中不能返回对象本身，返回对象的拷贝</li>\n<li>使用建造者模型创建不可变类</li>\n</ul>\n<h3 id=\"10-浅复制和深复制？怎样实现深复制？\"><a href=\"#10-浅复制和深复制？怎样实现深复制？\" class=\"headerlink\" title=\"10. 浅复制和深复制？怎样实现深复制？\"></a>10. 浅复制和深复制？怎样实现深复制？</h3><table>\n<thead>\n<tr>\n<th>item</th>\n<th>值类型拷贝</th>\n<th>引用类型拷贝</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>浅拷贝</td>\n<td>独立副本</td>\n<td>拷贝引用</td>\n</tr>\n<tr>\n<td>深拷贝</td>\n<td>独立副本</td>\n<td>拷贝引用对象及其子对象</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"11-HashMap、HashTable、ConcurrentHashMap的区别？\"><a href=\"#11-HashMap、HashTable、ConcurrentHashMap的区别？\" class=\"headerlink\" title=\"11. HashMap、HashTable、ConcurrentHashMap的区别？\"></a>11. HashMap、HashTable、ConcurrentHashMap的区别？</h3><p><a href=\"https://shenjian.online/2019/02/14/ConcurrentHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/#2-ConcurrentHashMap%E4%B8%8EHashMap%E7%AD%89%E7%9A%84%E5%8C%BA%E5%88%AB\" target=\"_blank\" rel=\"noopener\">ConcurrentHashMap与HashMap等的区别</a></p>\n<h3 id=\"12-CAS是一种什么样的同步机制\"><a href=\"#12-CAS是一种什么样的同步机制\" class=\"headerlink\" title=\"12. CAS是一种什么样的同步机制\"></a>12. CAS是一种什么样的同步机制</h3><p><a href=\"https://shenjian.online/2019/06/02/Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/#2-1-%E4%BD%BF%E7%94%A8%E5%BE%AA%E7%8E%AFCAS%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C\" target=\"_blank\" rel=\"noopener\">使用循环CAS来实现原子操作</a></p>\n<h3 id=\"13-NIO的原理，包括哪几个组件\"><a href=\"#13-NIO的原理，包括哪几个组件\" class=\"headerlink\" title=\"13. NIO的原理，包括哪几个组件\"></a>13. NIO的原理，包括哪几个组件</h3><p><strong>1) Channel</strong></p>\n<p><strong>实现</strong></p>\n<ul>\n<li>FileChannel: 读写文件</li>\n<li>DatagramChannel: UDP协议网络通信</li>\n<li>SocketChannel: TCP协议网络通信</li>\n<li>ServerSocketChannel: 监听TCP连接</li>\n</ul>\n<p>[扩展]Channel与Stream的区别</p>\n<ul>\n<li>Channel是双向的，可读可写；Stream是单向的(所以分为InputStream、OutputStream)</li>\n<li>Channel有非阻塞I/O模式；Stream为传统阻塞I/O模式</li>\n</ul>\n<p><strong>2) Buffer</strong></p>\n<p>有三个重要的变量</p>\n<ul>\n<li>capacity: 总容量</li>\n<li>position: 指示当前位置</li>\n<li>limit: 读写边界位置</li>\n</ul>\n<p>几个重要方法：</p>\n<ul>\n<li>flip(): 设置<code>limit = position;position = 0;</code>，对buffer读取前调用</li>\n<li>rewind(): 设置<code>position = 0;</code>,对buffer读取前进行调用，比如读取同一个buffer数据写入多个通道时会用到</li>\n<li>clear(): 设置<code>position = 0;limit = capacity;</code>,对buffer重新写入时调用</li>\n<li>compact(): 将未读完的数据(position~limit)之间的数据移动到缓冲区开头，并将position设置为这段数据末尾的下一个位置。等价于向缓冲区重新写入了这一段数据</li>\n</ul>\n<p><strong>3) Selector</strong></p>\n<p>Selector选择器用于采集各个通道的状态。我们先将通道注册到选择器，并设置好关心的事件，然后调用select()方法，线程挂起，让出CPU，静静等待事件发生。</p>\n<p>通道有4个事件可供监听</p>\n<ul>\n<li>SelectionKey.OP_ACCEPT: 有可以接受的连接</li>\n<li>SelectionKey.OP_CONNECT: 连接成功</li>\n<li>SelectionKey.OP_READ: 有数据可读</li>\n<li>SelectionKey.OP_WRITE: 可以写入数据</li>\n</ul>\n<p><a href=\"https://github.com/SJshenjian/design-pattern/tree/master/src/main/java/jdk/INio\" target=\"_blank\" rel=\"noopener\">NIO</a></p>\n<h3 id=\"14-简单介绍一下java的反射机制？反射在哪些地方有应用场景？\"><a href=\"#14-简单介绍一下java的反射机制？反射在哪些地方有应用场景？\" class=\"headerlink\" title=\"14. 简单介绍一下java的反射机制？反射在哪些地方有应用场景？\"></a>14. 简单介绍一下java的反射机制？反射在哪些地方有应用场景？</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能调用他的任一方法</p>\n<p>应用场景：</p>\n<ul>\n<li>Spring中的IOC/DI</li>\n<li>JDBC中的驱动加载</li>\n</ul>\n<h3 id=\"15-spring加载bean的流程\"><a href=\"#15-spring加载bean的流程\" class=\"headerlink\" title=\"15. spring加载bean的流程\"></a>15. spring加载bean的流程</h3><p><a href=\"https://shenjian.online/2019/11/05/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E7%AF%87/#3-%E8%AE%B2%E8%AE%B2Spring%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B\" target=\"_blank\" rel=\"noopener\">Spring加载流程</a></p>\n<h3 id=\"16-java线程池？线程池构造函数的几个参数含义？keepAliveTime解释一下？\"><a href=\"#16-java线程池？线程池构造函数的几个参数含义？keepAliveTime解释一下？\" class=\"headerlink\" title=\"16. java线程池？线程池构造函数的几个参数含义？keepAliveTime解释一下？\"></a>16. java线程池？线程池构造函数的几个参数含义？keepAliveTime解释一下？</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadPoolExecutor</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>线程池的构造参数有7个:</p>\n<ul>\n<li>corePoolSize: the number of threads to keep in the pool, even if they are idle, unless {@code allowCoreThreadTimeOut} is set</li>\n<li>maximumPoolSize: the maximum number of threads to allow in the pool</li>\n<li>keepAliveTime: when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating</li>\n<li>unit: the time unit for the {@code keepAliveTime} argument</li>\n<li>workQueue: the queue to use for holding tasks before they are executed. This queue will hold only the {@code Runnable} tasks submitted by the {@code execute} method<ul>\n<li>ArrayBlockingQueue</li>\n<li>LinkedBlockingQueue</li>\n<li>SynchronousQueue</li>\n<li>PriorityBlockingQueue</li>\n</ul>\n</li>\n<li>threadFactory: the factory to use when the executor creates a new thread</li>\n<li>handler: the handler to use when execution is blocked because the thread bounds and queue capacities are reached<ul>\n<li>CallerRunsPolicy: A handler for rejected tasks that runs the rejected task directly in the calling thread of the {@code execute} method</li>\n<li>AbortPolicy: A handler for rejected tasks that throws a {@code RejectedExecutionException}.</li>\n<li>DiscardPolicy: A handler for rejected tasks that silently discards the rejected task.</li>\n<li>DiscardOldestPolicy: A handler for rejected tasks that discards the oldest unhandled request and then retries {@code execute}</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"17-一个接口，要去调用另外5个接口，每一个接口都会返回数据给这个调用接口，调用接口要对数据进行合并并返回给上层。这样一种场景可能用到并发包下的哪些类？你会怎么去实现这样的业务场景\"><a href=\"#17-一个接口，要去调用另外5个接口，每一个接口都会返回数据给这个调用接口，调用接口要对数据进行合并并返回给上层。这样一种场景可能用到并发包下的哪些类？你会怎么去实现这样的业务场景\" class=\"headerlink\" title=\"17. 一个接口，要去调用另外5个接口，每一个接口都会返回数据给这个调用接口，调用接口要对数据进行合并并返回给上层。这样一种场景可能用到并发包下的哪些类？你会怎么去实现这样的业务场景\"></a>17. 一个接口，要去调用另外5个接口，每一个接口都会返回数据给这个调用接口，调用接口要对数据进行合并并返回给上层。这样一种场景可能用到并发包下的哪些类？你会怎么去实现这样的业务场景</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        CyclicBarrier barrier = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">5</span>, () -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 执行结果汇总</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        executorService.execute(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 执行接口1调用,其他接口调用类似</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                barrier.await();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"18-CountDownLatch和CyclicBarrier的区别\"><a href=\"#18-CountDownLatch和CyclicBarrier的区别\" class=\"headerlink\" title=\"18. CountDownLatch和CyclicBarrier的区别\"></a>18. CountDownLatch和CyclicBarrier的区别</h3><p>所有线程必须全部到达栅栏处，才能继续执行；闭锁结束前，不允许线程执行，结束时，允许所有线程执行<br>栅栏等待线程；闭锁等待事件<br>栅栏可以使参与方在栅栏处反复汇集；闭锁是一次性事件，一旦进入终止状态，不能被重置</p>\n<p><a href=\"https://shenjian.online/2019/02/24/JAVA%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8B%E9%97%AD%E9%94%81/\" target=\"_blank\" rel=\"noopener\">JAVA同步工具类之闭锁</a><br><a href=\"https://shenjian.online/2019/02/24/JAVA%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8B%E6%A0%85%E6%A0%8F/\" target=\"_blank\" rel=\"noopener\">JAVA同步工具类之栅栏</a></p>\n<h3 id=\"19-线程加锁有哪些方式？synchronized和lock的区别\"><a href=\"#19-线程加锁有哪些方式？synchronized和lock的区别\" class=\"headerlink\" title=\"19. 线程加锁有哪些方式？synchronized和lock的区别\"></a>19. 线程加锁有哪些方式？synchronized和lock的区别</h3><p>synchronized与lock</p>\n<p><a href=\"https://shenjian.online/2019/03/29/Lock%E6%8E%A5%E5%8F%A3%E5%92%8CReentrantLock/#6-synchronized%E5%92%8CReentrantLock%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%89%E6%8B%A9\" target=\"_blank\" rel=\"noopener\">synchronized和ReentrantLock之间的选择</a></p>\n<h3 id=\"20-volatile关键字的作用？为什么使用AtomicLong而不使用Long-AtomicLong的底层是怎么实现的？\"><a href=\"#20-volatile关键字的作用？为什么使用AtomicLong而不使用Long-AtomicLong的底层是怎么实现的？\" class=\"headerlink\" title=\"20. volatile关键字的作用？为什么使用AtomicLong而不使用Long?AtomicLong的底层是怎么实现的？\"></a>20. volatile关键字的作用？为什么使用AtomicLong而不使用Long?AtomicLong的底层是怎么实现的？</h3><p><a href=\"https://shenjian.online/2019/01/10/Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8Bvolatile/\" target=\"_blank\" rel=\"noopener\">Java并发机制底层实现原理之volatile</a></p>\n<p>long 64位，不具有原子性，使用AtomicLong使其具有原子性，线程安全<br>AtomicLong底层采用volatile + CAS,  具体采用Unsafe类CAS赋值</p>\n<h3 id=\"21-mysql的存储引擎有哪几种\"><a href=\"#21-mysql的存储引擎有哪几种\" class=\"headerlink\" title=\"21. mysql的存储引擎有哪几种\"></a>21. mysql的存储引擎有哪几种</h3><table>\n<thead>\n<tr>\n<th>功能</th>\n<th>InnoDB</th>\n<th>MyISAM</th>\n<th>Memory</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>存储限制</td>\n<td>64TB</td>\n<td>256TB</td>\n<td>RAM</td>\n</tr>\n<tr>\n<td>支持事务</td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>支持全文索引</td>\n<td>No</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>支持数索引</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>支持哈希索引</td>\n<td>No</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>支持数据缓存</td>\n<td>Yes</td>\n<td>No</td>\n<td>N/A</td>\n</tr>\n<tr>\n<td>支持外键</td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"22-sql优化有哪些着手点？组合索引的最左前缀原则的含义\"><a href=\"#22-sql优化有哪些着手点？组合索引的最左前缀原则的含义\" class=\"headerlink\" title=\"22. sql优化有哪些着手点？组合索引的最左前缀原则的含义\"></a>22. sql优化有哪些着手点？组合索引的最左前缀原则的含义</h2><p><a href=\"https://shenjian.online/2019/11/07/MySQL%E9%9D%A2%E8%AF%95%E7%AF%87/#8-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E7%9A%84%E6%80%9D%E8%B7%AF\" target=\"_blank\" rel=\"noopener\">数据库优化的思路</a></p>\n<p>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like(%位于左边停止匹配，在右边仍然走索引))就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。<br>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p>\n<h3 id=\"23-springmvc处理请求的流程\"><a href=\"#23-springmvc处理请求的流程\" class=\"headerlink\" title=\"23. springmvc处理请求的流程\"></a>23. springmvc处理请求的流程</h3><p><a href=\"https://shenjian.online/2019/11/05/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E7%AF%87/#17-SpringMVC%E7%94%A8%E5%88%B0%E7%9A%84%E6%B3%A8%E8%A7%A3%EF%BC%8C%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%8E%9F%E7%90%86\" target=\"_blank\" rel=\"noopener\">SpringMVC用到的注解，作用是什么，原理</a></p>\n<h3 id=\"24-spring的事务怎么使用？事务回滚？自定义异常？\"><a href=\"#24-spring的事务怎么使用？事务回滚？自定义异常？\" class=\"headerlink\" title=\"24. spring的事务怎么使用？事务回滚？自定义异常？\"></a>24. spring的事务怎么使用？事务回滚？自定义异常？</h3><p>使用注解<code>@Transactional</code><br>如让checked例外也回滚<code>@Transactional(rollbackFor=Exception.class)</code>,一般只需添加这个即可<br>让unchecked例外不回滚<code>@Transactional(notRollbackFor=RunTimeException.class)</code><br>不需要事务管理的(只查询的方法)<code>@Transactional(propagation=Propagation.NOT_SUPPORTED)</code>或者不添加   </p>\n<p>Spring声明式事务管理默认对非检查型和运行时异常进行回滚，而对检查型异常则不进行回滚<br>如果异常被try{} catch{}了，事务就不回滚了，要想回滚就必须在往外抛try{} catch{throw Exception}<br>Spring事务设置手动回滚：TransactionAspectSupport.currentTransactionStatus().setRollbackOnly()<br><strong>Transaction是否生效，仅取决于是否加载于接口方法，并且是否通过接口方法调用(而不是本类调用)</strong></p>\n<h3 id=\"24-检查型异常非检查型异常\"><a href=\"#24-检查型异常非检查型异常\" class=\"headerlink\" title=\"24. 检查型异常非检查型异常\"></a>24. 检查型异常非检查型异常</h3><p>1）继承自RuntimeException和Error的是非检查型异常，继承自Exception的则是检查型异常(当然RuntimeException也是Exception的子类)<br>2）对非检查型异常可以不用捕获，检查型异常必须捕获处理</p>\n<h3 id=\"26-脏读？幻读？\"><a href=\"#26-脏读？幻读？\" class=\"headerlink\" title=\"26. 脏读？幻读？\"></a>26. 脏读？幻读？</h3>","categories":["JAVA"],"tags":["面试","JAVA"]},{"title":"38_报数_leetcode","url":"http://www.shenjian.online/2019/11/30/38-报数-leetcode/","content":"<h2 id=\"38-报数\"><a href=\"#38-报数\" class=\"headerlink\" title=\"38. 报数\"></a>38. 报数</h2><p>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p>\n<blockquote>\n<ol>\n<li>1</li>\n<li>11</li>\n<li>21</li>\n<li>1211</li>\n<li>111221<br>1 被读作  “one 1”  (“一个一”) , 即 11。<br>11 被读作 “two 1” (“两个一”）, 即 21。<br>21 被读作 “one 2”,  “one 1” （”一个二” ,  “一个一”) , 即 1211。</li>\n</ol>\n</blockquote>\n<p>给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。<br>注意：整数顺序将表示为一个字符串。</p>\n<p><strong>题解：</strong> 简单，关键在于理解题意</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">countAndSay</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        String pre = <span class=\"string\">\"1\"</span>;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> ch = pre.charAt(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">            sb.delete(<span class=\"number\">0</span>, sb.length());</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> curr : pre.toCharArray()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (curr == ch) &#123;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    sb.append(count).append(ch);</span><br><span class=\"line\">                    <span class=\"comment\">// 重新计数</span></span><br><span class=\"line\">                    ch = curr;</span><br><span class=\"line\">                    count = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sb.append(count).append(ch);</span><br><span class=\"line\">            pre = sb.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/count-and-say/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"36_有效的数独_leetcode","url":"http://www.shenjian.online/2019/11/29/36-有效的数独-leetcode/","content":"<h2 id=\"36-有效的数独\"><a href=\"#36-有效的数独\" class=\"headerlink\" title=\"36. 有效的数独\"></a>36. 有效的数独</h2><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>\n<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p>\n<p><strong>题解：</strong> 根据题意，需满足以上三个条件，故采用三数组记录数字是否满足条件即可，关键在于3x3宫的巧妙设计，详见代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidSudoku</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] board)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">boolean</span>[][] row = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[<span class=\"number\">9</span>][<span class=\"number\">9</span>]; <span class=\"comment\">// 记录行中是否存在重复数字</span></span><br><span class=\"line\">       <span class=\"keyword\">boolean</span>[][] column = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[<span class=\"number\">9</span>][<span class=\"number\">9</span>]; <span class=\"comment\">// 记录列中是否存在重复数字</span></span><br><span class=\"line\">       <span class=\"keyword\">boolean</span>[][] block = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[<span class=\"number\">9</span>][<span class=\"number\">9</span>]; <span class=\"comment\">// 记录3*3宫中是否存在重复数组</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">9</span>; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( board[i][j] != <span class=\"string\">'.'</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// i是行标，j是列标。行标决定一组block的起始位置</span></span><br><span class=\"line\">                    <span class=\"comment\">// 因为block为3行，所以除3取整得到组号，又因为每组block为3个，所以需要乘3</span></span><br><span class=\"line\">                    <span class=\"comment\">// 列标再细分出是哪个block（因为block是3列，所以除3取整）</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> num =  board[i][j] - <span class=\"string\">'1'</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> blockIndex = i / <span class=\"number\">3</span> * <span class=\"number\">3</span> + j / <span class=\"number\">3</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (row[i][num] || column[j][num] || block[blockIndex][num]) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    row[i][num] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    column[j][num] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    block[blockIndex][num] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/valid-sudoku\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"Mysql增量备份与恢复","url":"http://www.shenjian.online/2019/11/24/Mysql增量备份与恢复/","content":"<p>本文基于Centos7与Mysql7.5，其他系统版本可能操作存在差异</p>\n<h3 id=\"1-检查并开启binlog\"><a href=\"#1-检查并开启binlog\" class=\"headerlink\" title=\"1. 检查并开启binlog\"></a>1. 检查并开启binlog</h3><p><code>SHOW VARIABLES LIKE &#39;log_bin%&#39;;</code></p>\n<p><img src=\"/2019/11/24/Mysql增量备份与恢复/showBinlog.png\" alt=\"showBinlog\"></p>\n<p><strong>Centos7下Mysql配置my.cnf位置：</strong> <code>ps aux|grep mysql|grep &#39;my.cnf&#39;</code>, 如果没有没有输出内容则是使用默认配置位置<br><strong>默认配置my.cnf位置：</strong> <code>mysql --help|grep &#39;my.cnf</code> </p>\n<p><img src=\"/2019/11/24/Mysql增量备份与恢复/mycnf.png\" alt=\"mycnf\"></p>\n<p>顺序排前的优先,执行<code>vim /etc/my.cnf</code>编辑配置文件并新增配置如下图方框内容</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log_bin=/var/lib/mysql/mysql-bin</span><br><span class=\"line\">server-id=12354</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/11/24/Mysql增量备份与恢复/conf.png\" alt=\"conf\"></p>\n<p>执行<code>systemctl restart mysqld.service</code>重启mysql<br>登录mysql，再次查看binlog，已经开启</p>\n<p><img src=\"/2019/11/24/Mysql增量备份与恢复/newlogbin.png\" alt=\"newlogbin\"></p>\n<p>进入/var/lib/mysql数据目录，可以发现，增量备份文件已经存在</p>\n<p><img src=\"/2019/11/24/Mysql增量备份与恢复/mysqlbin.png\" alt=\"mysqlbin\"></p>\n<h3 id=\"2-将增量文件定时备份到指定目录\"><a href=\"#2-将增量文件定时备份到指定目录\" class=\"headerlink\" title=\"2. 将增量文件定时备份到指定目录\"></a>2. 将增量文件定时备份到指定目录</h3><h4 id=\"2-1-新增增量备份脚本\"><a href=\"#2-1-新增增量备份脚本\" class=\"headerlink\" title=\"2.1 新增增量备份脚本\"></a>2.1 新增增量备份脚本</h4><p>在目录/var/lib/mysql下创建脚本mysqlIncreamBackup.sh，内容如下<br>注意：脚本中红色字注释表示需要根据实际情况更改</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">backupDir=/opt/data/mysql/backup/ <span class=\"comment\"># 自定义备份目录，确保目录存在，不存在则创建</span></span><br><span class=\"line\">mysqlDir=/var/lib/mysql</span><br><span class=\"line\">logFile=/opt/data/mysql/backup/bak.log <span class=\"comment\"># 自定义文件</span></span><br><span class=\"line\">binFile=/var/lib/mysql/mysql-bin.index <span class=\"comment\"># 为mysql变量log-bin-index值</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 产生新的binlog.00000*文件</span></span><br><span class=\"line\">mysqladmin -uroot -pSj123456! flush-logs <span class=\"comment\"># 用户名密码请自行更改</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># wc -l 统计行数(如显示12 binlog.index), awk '$&#123;print $1&#125;'显示第一列(如12)</span></span><br><span class=\"line\">counter=`wc -l <span class=\"variable\">$binFile</span> | awk <span class=\"string\">'&#123;print $1&#125;'</span>`</span><br><span class=\"line\">nextNum=0</span><br><span class=\"line\"><span class=\"keyword\">for</span> file <span class=\"keyword\">in</span> `cat <span class=\"variable\">$binFile</span>` <span class=\"comment\"># file显示如./binlog.000009</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    base=`basename <span class=\"variable\">$file</span>` <span class=\"comment\"># base则显示为binlog.000009</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$base</span></span><br><span class=\"line\">    nextNum=`expr <span class=\"variable\">$nextNum</span> + 1` <span class=\"comment\"># nextNum+=1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ <span class=\"variable\">$nextNum</span> -eq <span class=\"variable\">$counter</span> ] <span class=\"comment\"># -eq 等于</span></span><br><span class=\"line\">        <span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"variable\">$base</span> skip! &gt;&gt; <span class=\"variable\">$logFile</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        dest=<span class=\"variable\">$backupDir</span>/<span class=\"variable\">$base</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">test</span> -e <span class=\"variable\">$dest</span>) <span class=\"comment\"># test -e 判断目标文件是否存在</span></span><br><span class=\"line\">            <span class=\"keyword\">then</span></span><br><span class=\"line\">                <span class=\"built_in\">echo</span> <span class=\"variable\">$base</span> exist! &gt;&gt; <span class=\"variable\">$logFile</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            cp <span class=\"variable\">$mysqlDir</span>/<span class=\"variable\">$base</span> <span class=\"variable\">$backupDir</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"variable\">$base</span> copying &gt;&gt; <span class=\"variable\">$logFile</span></span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> `date +<span class=\"string\">\"%Y年%m月%d日 %H:%M:%S\"</span>` Bakup success! &gt;&gt; <span class=\"variable\">$logFile</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-保存并授权脚本\"><a href=\"#2-2-保存并授权脚本\" class=\"headerlink\" title=\"2.2 保存并授权脚本\"></a>2.2 保存并授权脚本</h4><p>执行<code>chmod 755 mysqlIncreamBackup.sh</code>授权脚本，使其具有执行权限</p>\n<h4 id=\"2-3-定时执行\"><a href=\"#2-3-定时执行\" class=\"headerlink\" title=\"2.3 定时执行\"></a>2.3 定时执行</h4><p>执行<code>crontab -e</code>进入定时编辑页面(测试设置每5分钟执行，根据具体需求设定)</p>\n<p><img src=\"/2019/11/24/Mysql增量备份与恢复/script.png\" alt=\"script\"></p>\n<p>crontab的格式为:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minute hour day month week <span class=\"built_in\">command</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>minute：表示分钟，可以是从0到59之间的任何整数。</li>\n<li>hour：表示小时，可以是从0到23之间的任何整数。</li>\n<li>day：表示日期，可以是从1到31之间的任何整数。</li>\n<li>month：表示月份，可以是从1到12之间的任何整数。</li>\n<li>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</li>\n<li>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件</li>\n</ul>\n<h3 id=\"3-备份结果查看\"><a href=\"#3-备份结果查看\" class=\"headerlink\" title=\"3. 备份结果查看\"></a>3. 备份结果查看</h3><p><img src=\"/2019/11/24/Mysql增量备份与恢复/result.png\" alt=\"result\"></p>\n<p>OK,至此备份成功！</p>\n<h3 id=\"4-增量备份恢复\"><a href=\"#4-增量备份恢复\" class=\"headerlink\" title=\"4. 增量备份恢复\"></a>4. 增量备份恢复</h3><p>如不小心，在执行<code>DELETE FROM salaries</code>忘记加where子句，可通过增量备份文件进行恢复<br>执行命令如下，本次案例选取mysql-bin.000057，若情况紧急，可以手动执行脚本，及时查看备份文件</p>\n<p>查看增量文件内容：<code>mysqlbinlog --base64-output=decode-rows -v /opt/data/mysql/backup/mysql-bin.000057</code>,mysql5.7中sql已加密，故需要–base64-output=decode-rows</p>\n<p><img src=\"/2019/11/24/Mysql增量备份与恢复/backup.png\" alt=\"backup\"></p>\n<p>可以查看到已经误删除salaries表中数据：</p>\n<p><img src=\"/2019/11/24/Mysql增量备份与恢复/delete.png\" alt=\"delete\"></p>\n<p>继续向前翻看文件,找到想要恢复的开始位置为结束位置</p>\n<p><img src=\"/2019/11/24/Mysql增量备份与恢复/start.png\" alt=\"start\"><br><img src=\"/2019/11/24/Mysql增量备份与恢复/end.png\" alt=\"end\"></p>\n<p>开始恢复296~824(注意起始位置为事务起始位置，可包含多个事务)间的插入与修改操作<br><code>mysqlbinlog --start-position=296 --stop-position=824 -v mysql-bin.000057 | mysql -uroot -p</code></p>\n<p><img src=\"/2019/11/24/Mysql增量备份与恢复/recover.png\" alt=\"recover\"></p>\n<p>恢复成功!，当然也可以根据开始时间，结束时间进行恢复，详见mysqlbinlog –help</p>\n<p><img src=\"/2019/11/24/Mysql增量备份与恢复/success.png\" alt=\"success\"></p>\n","categories":["Mysql"],"tags":["Mysql"]},{"title":"Docker快速部署mysql","url":"http://www.shenjian.online/2019/11/23/Docker快速部署mysql/","content":"<p>基于CentOS7，VMWare虚拟机给其分配了2G内存, <strong>防火墙已关闭</strong></p>\n<h2 id=\"1-编写docker-compose-yml\"><a href=\"#1-编写docker-compose-yml\" class=\"headerlink\" title=\"1. 编写docker-compose.yml\"></a>1. 编写docker-compose.yml</h2><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">'3'</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\"><span class=\"attr\">  db:</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">mysql</span></span><br><span class=\"line\"><span class=\"attr\">    container_name:</span> <span class=\"string\">mysql57</span></span><br><span class=\"line\"><span class=\"attr\">    restart:</span> <span class=\"string\">always</span></span><br><span class=\"line\"><span class=\"attr\">    environment:</span></span><br><span class=\"line\"><span class=\"attr\">      MYSQL_USER:</span> <span class=\"string\">shenjian</span></span><br><span class=\"line\"><span class=\"attr\">      MYSQL_PASSWORD:</span> <span class=\"number\">123456</span></span><br><span class=\"line\"><span class=\"attr\">      MYSQL_DATABASE:</span> <span class=\"string\">database</span></span><br><span class=\"line\"><span class=\"attr\">      MYSQL_ROOT_PASSWORD:</span> <span class=\"number\">123456</span></span><br><span class=\"line\"><span class=\"attr\">    command:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span><span class=\"bullet\">-default-authentication-plugin=mysql_native_password</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span><span class=\"bullet\">-character-set-server=utf8mb4</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span><span class=\"bullet\">-collation-server=utf8mb4_general_ci</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span><span class=\"bullet\">-explicit_defaults_for_timestamp=true</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span><span class=\"bullet\">-lower_case_table_names=1</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span><span class=\"bullet\">-max_allowed_packet=128M</span></span><br><span class=\"line\"><span class=\"attr\">    ports:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"number\">3306</span><span class=\"string\">:3306</span></span><br><span class=\"line\"><span class=\"attr\">    volumes:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">./data:/var/lib/mysql</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-启动mysql\"><a href=\"#2-启动mysql\" class=\"headerlink\" title=\"2. 启动mysql\"></a>2. 启动mysql</h2><p><code>docker-compose up -d</code>启动mysql后，<code>docker ps -a</code>查看启动后的容器ID为7c6c1e35b9d2</p>\n<p>OK, 有了docker，一切都是这么简单</p>\n","categories":["Docker"],"tags":["Docker","Mysql"]},{"title":"35_搜索插入位置_leetcode","url":"http://www.shenjian.online/2019/11/19/35-搜索插入位置-leetcode/","content":"<h2 id=\"35-搜索插入位置\"><a href=\"#35-搜索插入位置\" class=\"headerlink\" title=\"35. 搜索插入位置\"></a>35. 搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>你可以假设数组中无重复元素。</p>\n<blockquote>\n<p>输入: [1,3,5,6], 5<br>输出: 2<br>输入: [1,3,5,6], 2<br>输出: 1<br>输入: [1,3,5,6], 7<br>输出: 4<br>输入: [1,3,5,6], 0<br>输出: 0</p>\n</blockquote>\n<p><strong>题解：</strong> 二分查找。注意模板即可，right=nums.length,则right=mid即可， 若right=nums.length-1,则right=mid-1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">searchInsert</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span> || nums.length &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 考虑到内存溢出，该方式安全些</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] == target) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &gt; target) &#123;</span><br><span class=\"line\">                right = mid;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/search-insert-position/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"34_在排序数组中查找元素的第一个和最后一个位置_leetcode","url":"http://www.shenjian.online/2019/11/13/34-在排序数组中查找元素的第一个和最后一个位置-leetcode/","content":"<h2 id=\"34-在排序数组中查找元素的第一个和最后一个位置\"><a href=\"#34-在排序数组中查找元素的第一个和最后一个位置\" class=\"headerlink\" title=\"34. 在排序数组中查找元素的第一个和最后一个位置\"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。<br>你的算法时间复杂度必须是 O(log n) 级别。<br>如果数组中不存在目标值，返回 [-1, -1]。</p>\n<blockquote>\n<p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: [3,4]<br>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: [-1,-1]</p>\n</blockquote>\n<p><strong>题解：</strong> 数组有序且时间复杂度O(log n),我们可以想到二分查找。关键在于二分搜索到值后不能停止搜索，则应该继续向左或向右搜索，以便找到第一个和最后一个位置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] searchRange(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = &#123;-<span class=\"number\">1</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = nums.length;</span><br><span class=\"line\">        left = findIndex(nums, target, <span class=\"keyword\">true</span>); <span class=\"comment\">// 向左查找</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left == nums.length || nums[left] != target) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        res[<span class=\"number\">0</span>] = left;</span><br><span class=\"line\">        res[<span class=\"number\">1</span>] = findIndex(nums, target, <span class=\"keyword\">false</span>) - <span class=\"number\">1</span>; <span class=\"comment\">// 向右查找</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">findIndex</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target, <span class=\"keyword\">boolean</span> isLeftSearch)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 官方题解，这里巧妙的控制了向左向右查找</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &gt; target || (isLeftSearch &amp;&amp; nums[mid] == target)) &#123;</span><br><span class=\"line\">                right = mid;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"阿里面试篇","url":"http://www.shenjian.online/2019/11/11/阿里面试篇/","content":"<h2 id=\"阿里面试篇\"><a href=\"#阿里面试篇\" class=\"headerlink\" title=\"阿里面试篇\"></a>阿里面试篇</h2><h3 id=\"1-如何实现一个高效的单向链表逆序输出？\"><a href=\"#1-如何实现一个高效的单向链表逆序输出？\" class=\"headerlink\" title=\"1. 如何实现一个高效的单向链表逆序输出？\"></a>1. 如何实现一个高效的单向链表逆序输出？</h3><p>JAVA题解，详见<a href=\"https://shenjian.online/2019/11/09/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/\" target=\"_blank\" rel=\"noopener\">栈实现链表反转</a></p>\n<h3 id=\"2-已知-sqrt-2-约等于-1-414，要求不用数学库，求-sqrt-2-精确到小数点后10位。\"><a href=\"#2-已知-sqrt-2-约等于-1-414，要求不用数学库，求-sqrt-2-精确到小数点后10位。\" class=\"headerlink\" title=\"2. 已知 sqrt(2)约等于 1.414，要求不用数学库，求 sqrt(2)精确到小数点后10位。\"></a>2. 已知 sqrt(2)约等于 1.414，要求不用数学库，求 sqrt(2)精确到小数点后10位。</h3><p>1.已知sqrt(2)约等于1.414,则可以在区间（1.4，1.5）进行二分查找<br>2.当前后两次的差值&lt;=0.0000000001,则可退出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">sqrt2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">double</span> low = <span class=\"number\">1.4</span>, high = <span class=\"number\">1.5</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">double</span> quit = <span class=\"number\">0.0000000001</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">double</span> mid = (low + high) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (high - low &gt; quit) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (mid * mid &gt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">\t\t\t\thigh = mid;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tlow = mid;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tmid = (low + high) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["JAVA"],"tags":["面试","JAVA"]},{"title":"链表反转","url":"http://www.shenjian.online/2019/11/09/链表反转/","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(ListNode&lt;T&gt; head)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t   <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       ListNode&lt;T&gt; currentNode = head;</span><br><span class=\"line\">       Stack&lt;ListNode&lt;T&gt;&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">       <span class=\"keyword\">while</span> (currentNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t   stack.push(currentNode);</span><br><span class=\"line\">    \t   ListNode&lt;T&gt; tempNode = currentNode.next;</span><br><span class=\"line\">    \t   currentNode.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// 断开连接</span></span><br><span class=\"line\">    \t   currentNode = tempNode;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">       head = stack.pop();</span><br><span class=\"line\">       currentNode = head;</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">    \t   currentNode.next = stack.pop();</span><br><span class=\"line\">    \t   currentNode = currentNode.next;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</span><br><span class=\"line\">\tT val;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ListNode</span><span class=\"params\">(T val)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.val = val;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tListNode&lt;T&gt; next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["算法与数据结构"],"tags":["算法与数据结构"]},{"title":"Mysql面试篇","url":"http://www.shenjian.online/2019/11/07/MySQL面试篇/","content":"<h2 id=\"MySQL面试篇\"><a href=\"#MySQL面试篇\" class=\"headerlink\" title=\"MySQL面试篇\"></a>MySQL面试篇</h2><h3 id=\"1-解释下超键、候选键、主键、外键\"><a href=\"#1-解释下超键、候选键、主键、外键\" class=\"headerlink\" title=\"1. 解释下超键、候选键、主键、外键\"></a>1. 解释下超键、候选键、主键、外键</h3><p><strong>超键</strong>： 在关系中能唯一标识元组的属性集称， 如学号、姓名<br><strong>候选键</strong>： 不含有多余属性的超键，如学号<br><strong>主键</strong>： 用户选择的候选键<br><strong>外键</strong>： 外键是相对于主键的，如学生表中学号为主键，成绩表中学号为外键</p>\n<p>总结：主键为候选键的子集，候选键为超键的子集，而外键是相对于主键的</p>\n<h3 id=\"2-数据库事务的四个特性及含义\"><a href=\"#2-数据库事务的四个特性及含义\" class=\"headerlink\" title=\"2. 数据库事务的四个特性及含义\"></a>2. 数据库事务的四个特性及含义</h3><p>ACID: 原子性、一致性、隔离性、持久性</p>\n<p>+原子性： 事务不可分割，要么全部执行、要么全部不执行<br>+一致性： 事物执行的前后数据完整性保持不变<br>+隔离性：一个事务的执行过程中，不应该受到其他事务的干扰<br>+持久性：事务一旦结束，就持久化到数据库中，不会被回滚</p>\n<h3 id=\"3-视图的作用，可以更改吗\"><a href=\"#3-视图的作用，可以更改吗\" class=\"headerlink\" title=\"3. 视图的作用，可以更改吗\"></a>3. 视图的作用，可以更改吗</h3><p>视图是虚拟的表，与包含数据的表不同，视图只包含使用时动态检索数据的查询,不包含任何列或数据；<br>视图可以简化复杂的sql语句，隐藏细节，保护数据；<br>视图创建后，可以使用与表相同的方式使用它们</p>\n<p>视图不能被索引，也不能有关联的触发器或默认值</p>\n<p>对于某些视图比如未使用联结子查询分组聚集函数Distinct Union等是可以更新的，对视图的更新将对基本表更新；<br>但是视图主要用于简化检索、保护数据，并不用于更新，而且大部分视图都不可以更新</p>\n<h3 id=\"4-drop-delete-truncate的区别\"><a href=\"#4-drop-delete-truncate的区别\" class=\"headerlink\" title=\"4. drop delete truncate的区别\"></a>4. drop delete truncate的区别</h3><p>drop直接删除表，truncate删除表中的数据，再插入时自增长id又从1开始,delete删除表中的数据，可以加where条件，自增id标识保留</p>\n<ul>\n<li>delete时每次删除一行，同时将操作记录至日志以便回滚，事务提交后才生效；truncate一次性删除数据并不记录日志，不能回滚且不触发与表相关的删除触发器，速度快</li>\n<li>表和索引所占空间 truncate后表和索引空间恢复至初始大小，delete后表和索引空间不变，drop后释放表和索引的全部空间</li>\n<li>一般来说，drop &gt; truncate &gt; delete</li>\n<li>应用范围 truncate只能对table, drop与delete可用于table与view</li>\n<li>truncate与delete只删除数据，而drop则删除整个表(结构与数据)</li>\n<li>truncate与不带where的delete: 只删除数据，而不删除表的结构,drop删除表的结构被依赖的约束、触发器、索引，依赖与该表的存储过程/函数不会被删除，但其状态会变为invalid</li>\n<li>由于foreign key约束引用的表，不能使用truncate table,而应使用不带where子句的delete语句。由于truncate table不记录在日志中，不能激活触发器删除外键信息</li>\n</ul>\n<h3 id=\"5-索引的工作原理及其种类-太保面试题\"><a href=\"#5-索引的工作原理及其种类-太保面试题\" class=\"headerlink\" title=\"5. 索引的工作原理及其种类(太保面试题)\"></a>5. 索引的工作原理及其种类(太保面试题)</h3><p>数据库索引，是数据库系统中一个排序的数据结构，以便快速查询、更新数据库中数据，通常实现为B树及B+树<br>数据库设计者巧妙利用了磁盘预读原理，将一个节点的大小设置为一个页(主存与磁盘间以页为单位交换数据)，这样每个节点只需一次I/0就可以完全载入<br>B-Tree一次检索最多需要h-1次I/0(根节点常驻内存)，渐进复杂度O(h)=O(logdN)</p>\n<p><strong>种类</strong><br>普通索引： 最基本的索引，没有任何限制<br>唯一索引： 索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一<br>主键索引： 在数据库中为表定义主键则自动创建主键索引，主键索引是唯一索引的特例<br>组合索引： 指多个字段上创建的索引，遵循最左前缀原则<br>全文索引</p>\n<p>主键索引与唯一索引区别:<br>一个表只能有一个主键，可以有多个唯一索引<br>主键列值不允许为空，唯一索引列值可以为空<br>主键可以作为其他表的外键<br>主键是逻辑键，实际不存在，唯一索引是物理键，实际存在  </p>\n<h4 id=\"5-1-不走索引的情况-多次面试题目\"><a href=\"#5-1-不走索引的情况-多次面试题目\" class=\"headerlink\" title=\"5.1 不走索引的情况(多次面试题目)\"></a>5.1 不走索引的情况(多次面试题目)</h4><ul>\n<li>没有查询条件，或者查询条件没有建立索引</li>\n<li>在查询条件上没有使用引导列(引导列是组合索引重要概念，如果将要使用的索引列不是复合索引列表中的第一部分，则不会使用索引）</li>\n<li>查询的数量是大表的大部分，应该是30％以上</li>\n<li>对小表查询</li>\n<li><p>隐式转换导致索引失效，这一点应当引起重视.也是开发中经常会犯的错误. 由于表的字段tu_mdn定义为varchar2(20)  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">错误的例子：select * from test where tu_mdn=13333333333;   </span><br><span class=\"line\">正确的例子：select * from test where tu_mdn=&apos;13333333333&apos;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对索引列进行运算导致索引失效  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">错误的例子：select * from test where id-1=9;   </span><br><span class=\"line\">正确的例子：select * from test where id=10;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用mysql内部函数导致索引失效.对于这样情况应当创建基于函数的索引</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">错误的例子：select * from test where round(id)=10; </span><br><span class=\"line\">说明，此时id的索引已经不起作用了 正确的例子：首先建立函数索引， </span><br><span class=\"line\">create index test_id_fbi_idx on test(round(id)); </span><br><span class=\"line\">然后 select * from test where round(id)=10; 这时函数索引起作用了</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果MySQL估计使用索引比全表扫描更慢，则不使用索引</p>\n</li>\n<li>如果使用MEMORY/HEAP表并且where条件中不使用“=”进行索引列，那么不会用到索引。Heap表只有在“=”的条件下会使用索引。因为用的是哈希索引 </li>\n<li>用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到</li>\n<li><p>如果like是以%开始，MySQL不会采用这个索引</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">问题：解决like ‘%字符串%’时，索引失效问题的方法(么么直播面试题目)</span><br><span class=\"line\">使用覆盖索引(只查询索引的列（索引列和查询列一致）)即可</span><br><span class=\"line\">SELECT id,name,age FROM user WHERE name LIKE &apos;%aa%&apos;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在JOIN操作中，MYSQL只有在主键和外键的数据类型相同时才能使用索引，否则即使建立了索引也不会使用</p>\n</li>\n<li><p>在ORDER BY操作中，MYSQL只有在排序条件不是一个查询条件表达式的情况下才使用索引。尽管如此，在涉及多个数据表的查询里，即使有索引可用，那些索引在加快ORDER BY操作方面也没什么作用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>索引字段上使用 is null / is not null 判断时，会导致索引失效</p>\n</li>\n<li>mysql存储引擎不能继续使用索引中范围条件（bettween、&lt;、&gt;、in等）右边的列</li>\n<li><p>使用短索引</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>索引不会包含有NULL值的列</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用ENUM而不是字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENUM保存的是TINYINT，别在枚举中搞一些“中国”“北京”“技术部”这样的字符串，字符串空间又大，效率又低。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><a href=\"https://blog.csdn.net/wuseyukui/article/details/72312574\" target=\"_blank\" rel=\"noopener\">MySQL高级之索引失效与优化详解</a></p>\n<h3 id=\"6-连接的种类\"><a href=\"#6-连接的种类\" class=\"headerlink\" title=\"6. 连接的种类\"></a>6. 连接的种类</h3><p>左连接(left join)、右连接(right join)、 完整外部连接(full join返回左右连接和)、内连接(join)、交叉连接(cross join产生笛卡尔积)</p>\n<h3 id=\"7-数据库范式\"><a href=\"#7-数据库范式\" class=\"headerlink\" title=\"7. 数据库范式\"></a>7. 数据库范式</h3><p><strong>第一范式：</strong> 列不可分割<br><strong>第二范式：</strong> 非主属性完全依赖于主属性<br><strong>第三范式：</strong> 非主属性不传递依赖于主属性</p>\n<h3 id=\"8-数据库优化的思路\"><a href=\"#8-数据库优化的思路\" class=\"headerlink\" title=\"8. 数据库优化的思路\"></a>8. 数据库优化的思路</h3><ol>\n<li>SQL语句优化</li>\n</ol>\n<ul>\n<li>尽量避免在where子句中使用!=或&lt;&gt;操作符，否则引擎将放弃索引的使用从而全表扫描</li>\n<li>很多时候用exists代替in是一个好的选择<br>[辅助理解]A表比B表数据量大，则使用in, 反之，使用exists,如 select a.<em> from A a exists(select 1 from B b on b.id=a.id)<br>`select </em> from A where id in(select id from B)<code>如:A表有10000条记录,B表有1000000条记录,那么最多有可能遍历10000x1000000次,效率很差.\n  如:A表有10000条记录,B表有100条记录,那么最多有可能遍历10000x100次,遍历次数大大减少,效率大大提升.</code>select a.* from A a where exists(select 1 from B b where a.id=b.id)`<br>  如:A表有10000条记录,B表有1000000条记录,那么exists()会执行10000次去判断A表中的id是否与B表中的id相等.<br>  如:A表有10000条记录,B表有100000000条记录,那么exists()还是执行10000次,因为它只执行A.length次,可见B表数据越多,越适合</li>\n<li>用where代替having子句，因为having子句先检索出所有记录在进行过滤</li>\n</ul>\n<ol start=\"2\">\n<li>索引优化</li>\n</ol>\n<ul>\n<li>每次新建节点时，直接申请一个页的空间</li>\n</ul>\n<ol start=\"3\">\n<li>数据库结构优化</li>\n</ol>\n<ul>\n<li>范式优化：消除冗余，节省空间</li>\n<li>反范式优化：适当增加冗余，减少join</li>\n<li>拆分表：<br>  案例： 简单的购物系统涉及如下表 1.产品表（数据量10w,稳定）2.订单表（数据量200w,有增长趋势）3.用户表（数据量100w,有增长趋势）<ul>\n<li>垂直拆分：<ul>\n<li>解决问题： 表与表之间的io竞争</li>\n<li>未解决问题：单表中数据量增长出现的压力</li>\n<li>方案：把产品表与用户表放到一个server上，订单表单单独放到一个server上</li>\n</ul>\n</li>\n<li>水平拆分：<ul>\n<li>解决问题：单表中数据量增长出现的压力</li>\n<li>未解决问题：表与表之间的io竞争</li>\n<li>方案： 用户表通过性别拆分为男用户表和女用户表，订单表通过已完成和完成中拆分已完成订单表和未完成订单表, 产品表和未完成订单表放到一个server上，已完成订单和男用户表放到一个sever上，女用户表放在一个server上(女的爱购物，多赚钱的行业奥)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"10-解释left-join和right-join-阿里巴巴新零售技术质量部\"><a href=\"#10-解释left-join和right-join-阿里巴巴新零售技术质量部\" class=\"headerlink\" title=\"10. 解释left join和right join[阿里巴巴新零售技术质量部]\"></a>10. 解释left join和right join[阿里巴巴新零售技术质量部]</h3><p>left join与right join都是两个表进行merge操作：left join将右边的表merge到左边，right join将左边的表merge到右边，通常我们会指定按照哪几个列进行merge</p>\n","categories":["Mysql"],"tags":["面试","Mysql"]},{"title":"开源框架面试篇","url":"http://www.shenjian.online/2019/11/05/开源框架面试篇/","content":"<h2 id=\"开源框架面试篇\"><a href=\"#开源框架面试篇\" class=\"headerlink\" title=\"开源框架面试篇\"></a>开源框架面试篇</h2><h3 id=\"1-简单讲讲tomcat结构，以及其类加载流程，线程模型\"><a href=\"#1-简单讲讲tomcat结构，以及其类加载流程，线程模型\" class=\"headerlink\" title=\"1. 简单讲讲tomcat结构，以及其类加载流程，线程模型\"></a>1. 简单讲讲tomcat结构，以及其类加载流程，线程模型</h3><p><strong>结构</strong></p>\n<ul>\n<li><strong>模块组成结构</strong></li>\n</ul>\n<p>Tomcat和核心组件是Connector和Container，一个Connector和一个Container(Engine)构成了一个Service.Service是对外提供服务的组件，有了Service组件Tomcat就能对外提供服务了，但是光有服务还不行，还需要最外层的Server环境让Service提供服务才行。<br>[追问时可回答]Collector是一个连接器，主要负责接收请求并把请求交给Container;Container是一个容器，主要装载的是处理请求的组件;Service主要为了关联Collector和Container,只有这两个结合起来才能够处理请求;Server对外提供接口访问Service,对内维护Service集合包括管理Service生命周期等</p>\n<ul>\n<li><strong>文档组成结构[可不回答]</strong></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Server代表整个容器，是Tomcat的顶层元素。服务器默认在8005端口，shutdown命令=关闭Tomcat --&gt;</span><br><span class=\"line\">&lt;Server&gt;</span><br><span class=\"line\">    &lt;Listener /&gt;</span><br><span class=\"line\">    &lt;GlobaNamingResources&gt;&lt;/GlobaNamingResources&gt;</span><br><span class=\"line\">    &lt;!-- Service包含多个Connector元素，而这些Connector元素共享一个Engine元素。 --&gt;</span><br><span class=\"line\">    &lt;Service&gt;</span><br><span class=\"line\">\t&lt;!-- Connector元素代表与客户时间交互的组件，它负责接收客户的请求，以及向客户响应结果，配置http为https主要是修改Connector --&gt;</span><br><span class=\"line\">\t&lt;Connector /&gt;</span><br><span class=\"line\">\t&lt;!-- 每个Service只能有一个Engine元素，处理同一个Service中所有Connector元素接收到的客户请求.Engine用来处理Connetcor收到的Http请求它匹配请求和自己的虚拟主机，并把请求转给对应的Host来处理 --&gt;</span><br><span class=\"line\">\t&lt;Engine&gt;</span><br><span class=\"line\">\t    &lt;Logger /&gt;</span><br><span class=\"line\">\t    &lt;Realm /&gt;</span><br><span class=\"line\">\t\t&lt;!-- 一个Engine包含多个host元素，每个host元素定义了一个虚拟主机，它包含一个或多个Web应用 --&gt;</span><br><span class=\"line\">\t\t&lt;host&gt;</span><br><span class=\"line\">\t\t    &lt;Logger /&gt;</span><br><span class=\"line\">\t\t    &lt;!-- 由Context接口定义.是使用最频繁的元素，对应于一个Web App --&gt;</span><br><span class=\"line\">\t\t    &lt;Context /&gt;</span><br><span class=\"line\">\t\t&lt;/host&gt;</span><br><span class=\"line\">\t&lt;/Engine&gt;</span><br><span class=\"line\">    &lt;/Service&gt;</span><br><span class=\"line\">&lt;/Server&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>类加载流程</strong></p>\n<p>Tomcat的类加载机制是违背双亲委托机制的，对于一些未加载的非基础类(Object、String)等，各个web应用自己的类加载器(WebAppClassLoader)加载，加载不到时在交给CommonClassLoader走双亲委托</p>\n<p>当应用需要一个类时，则会按照以下顺序进行类加载：<br>1) 使用boostrap引导类加载器加载<br>2) 使用system系统类加载器加载<br>3) 使用应用类加载器在WEB-INF/classes中加载<br>4) 使用应用类加载器在WEB-INF/lib中加载<br>5) 使用common类加载器在CATALINA_HOME/lib中加载</p>\n<p><strong>线程模型</strong></p>\n<p>支持以下四种线程模型</p>\n<table>\n<thead>\n<tr>\n<th>模型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BIO</td>\n<td>同步阻塞，每个请求都会创建一个线程</td>\n</tr>\n<tr>\n<td>NIO</td>\n<td>同步非阻塞，比传统的BIO能更好的支持大并发，tomcat8.0后默认采用该模式</td>\n</tr>\n<tr>\n<td>APR</td>\n<td>tomcat以JNI形式调用http服务器的核心动态链接库来处理读取与网络传输操作，需要编译安装APR库</td>\n</tr>\n<tr>\n<td>AIO</td>\n<td>异步非阻塞,tomcat8.0后支持</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"2-tomcat如何调优，涉及哪些参数\"><a href=\"#2-tomcat如何调优，涉及哪些参数\" class=\"headerlink\" title=\"2. tomcat如何调优，涉及哪些参数\"></a>2. tomcat如何调优，涉及哪些参数</h3><p>tomcat调优主要从四个方面考虑1）吞吐量 2）响应时间 3）CPU负载 4）内存利用率</p>\n<p>1）Tomcat启动参数调优</p>\n<p>Tomcat启动参数位于tomcat安装目录\\bin目录下，linux是catalina.sh文件，windows是catalina.bat文件</p>\n<ul>\n<li>设置-Xms(最小堆内存) -Xmx(最大堆内存)一致，避免当Xms向Xmx变化时，CPU高速运转出发垃圾回收机制，严重时导致系统卡壳<br>[tip]在设置Xmx时先执行<code>java -Xms 1500m -version</code>,如果能正常显示版本信息，则证明可用</li>\n<li>-Xmn: 设置年轻代大小为512m,整个堆大小=年轻代+老年代+持久代。持久代一般大小为64m,所以增大年轻代后，老年代将减少。官方推荐设置整个堆的3/8</li>\n<li>-Xss: 设置每个线程的堆栈大小，一般不宜超过1M</li>\n</ul>\n<p>2）Tomcat容器内调优**</p>\n<p>打开[tomcat安装目录]\\conf\\server.xml,更改后的配置如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Connector port=<span class=\"string\">\"8080\"</span> protocol=<span class=\"string\">\"HTTP/1.1\"</span>           </span><br><span class=\"line\">URIEncoding=<span class=\"string\">\"UTF-8\"</span>  minSpareThreads=<span class=\"string\">\"25\"</span> maxSpareThreads=<span class=\"string\">\"75\"</span>          </span><br><span class=\"line\">enableLookups=<span class=\"string\">\"false\"</span> disableUploadTimeout=<span class=\"string\">\"true\"</span> connectionTimeout=<span class=\"string\">\"20000\"</span> </span><br><span class=\"line\">acceptCount=<span class=\"string\">\"300\"</span>  maxThreads=<span class=\"string\">\"300\"</span> maxProcessors=<span class=\"string\">\"1000\"</span> minProcessors=<span class=\"string\">\"5\"</span></span><br><span class=\"line\">useURIValidationHack=<span class=\"string\">\"false\"</span></span><br><span class=\"line\">compression=<span class=\"string\">\"on\"</span> compressionMinSize=<span class=\"string\">\"2048\"</span></span><br><span class=\"line\">compressableMimeType=<span class=\"string\">\"text/html,text/xml,text/javascript,text/css,text/plain\"</span> </span><br><span class=\"line\">redirectPort=<span class=\"string\">\"8443\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>-URIEncoding=”UTF-8”: 使得url可以解析带有中文的url<br>-minSpareThreads: 最小备用线程数，tomcat启动时初始化的线程数<br>-maxSpareThreads: 如果空闲的线程数大于该设置数，则终止多余的空闲线程,减少池中线程总数<br>-enableLookups: 设置为false,关闭DNS查询，从而消除DNS查询对性能的影响<br>-disableUploadTimeout: 允许servlet容器，正在执行使用一个较长的连接超时值，以使Servlet有较长的时间来执行完成，默认为false<br>-connectionTimeout: 网络连接超时时间毫秒数,默认60s<br>-acceptCount: 当线程数到达maxThreads后，后续请求会放入等待队列，acceptCount即为等待队列的大小<br>-maxThreads： 可创建的最大线程数，即最大并发数<br>-maxProcessors与minProcessors： 在 Java中线程是程序运行时的路径，是在一个程序中与其它控制线程无关的、能够独立运行的代码段。它们共享相同的地址空间。多线程帮助程序员写出CPU最大利用率的高效程序，使空闲时间保持最低，从而接受更多的请求。 通常Windows是1000个左右，Linux是2000个左右。？？？<br>-useURIValidationHack: 禁用url检查<br>-compression： 打开压缩功能<br>-compressionMinSize： 启用压缩的输出内容大小，默认为2K<br>-noCompressionUserAgents=”gozilla, traviata”： 设置不启用压缩的浏览器<br>-compressableMimeType： 压缩类型<br>-redirectPort: 如果走https协议的话，则会用到</p>\n<h3 id=\"3-讲讲Spring加载流程\"><a href=\"#3-讲讲Spring加载流程\" class=\"headerlink\" title=\"3. 讲讲Spring加载流程\"></a>3. 讲讲Spring加载流程</h3><p>初始化环境 -&gt; 加载配置文件 -&gt; 实例化bean -&gt; 调用Bean显示信息<br>// TODO 详细重点说明</p>\n<h3 id=\"4-Spring-AOP的实现原理-AOP中的几个术语，它们是怎么相互工作的\"><a href=\"#4-Spring-AOP的实现原理-AOP中的几个术语，它们是怎么相互工作的\" class=\"headerlink\" title=\"4. Spring AOP的实现原理, AOP中的几个术语，它们是怎么相互工作的\"></a>4. Spring AOP的实现原理, AOP中的几个术语，它们是怎么相互工作的</h3><p>两种主要实现方式：JDK动态代理与CGLIB<br>在Spring5中DefaultAopProxyFactory中调用createAopProxy(AdvisedSupport config)创建AopProxy<br>若AdvisedSupport中设置optimize=true并且proxyTargetClass=true并且目标targetClass不是interface和proxy,则采用ObjenesisCglibAopProxy创建AopProxy,否则，采用JdkDynamicAopProxy创建AopProxy</p>\n<p>JdkDynamicAopProxy实现InvocationHandler接口的方法invoke(Object proxy, Method method, Object[] args)得到AopProxy，<br>其中较为重要的是通过AdvisedSupport的getInterceptorsAndDynamicInterceptionAdvice(Method method, Class&lt;?&gt; tagetClass)获取拦截器链，该方法在DefaultAdvisorChainFactory中实现,其中，主要通过DefaultAdvisorAdapterRegistry.getInterceptors(Advisor advisor)获取拦截器，这样就和advisor连接起来了。最后通过getInterceptors中的AdvisorAdpter获取MethodBeforeInterceptor、AfterReturningInterceptor、ThrowsAdviceInterceptor,<br>如在AfterReturningInterceptor中，其实现了MethodInterceptor与AfterAdvice, 从而在invoke(MethodInvocation mi)中先调用mi.process(), 然后调用advice.afterReturning就完成了后置增强</p>\n<p>ObjenesisCglibAopProxy通过createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks)创建AopProxy, enhancer.createClass()创建proxyClass, proxyClass.getDeclaredConstructor()创建Constructor, 最后constructor.newInstance()获取proxyInstance()</p>\n<p><strong>主要术语</strong></p>\n<p><em>advice通知</em> 拦截增强<br><em>pointcut切入点</em> 目标类<br><em>advisor</em> 通过其子类PointcutAdvisor将Advice与PointCut连接起来</p>\n<h3 id=\"5-讲讲Spring事务的传播属性\"><a href=\"#5-讲讲Spring事务的传播属性\" class=\"headerlink\" title=\"5. 讲讲Spring事务的传播属性\"></a>5. 讲讲Spring事务的传播属性</h3><ul>\n<li><p><strong>REQUIRED</strong>：支持当前事务，如果当前没有事务，就新建一个事务。默认传播属性<br>[辅助理解]ServiceB.methodB的事务级别定义为PROPAGATION_REQUIRED,那么由于执行ServiceA.methodA的时候，ServiceA.methodA已经起了事务，这时调用ServiceB.methodB，ServiceB.methodB看到自己已经运行在ServiceA.methodA的事务内部，就不再起新的事务。而假如ServiceA.methodA运行的时候发现自己没有在事务中，他就会为自己分配一个事务。这样，在ServiceA.methodA或者在ServiceB.methodB内的任何地方出现异常，事务都会被回滚。即使ServiceB.methodB的事务已经被提交，但是ServiceA.methodA在接下来fail要回滚，ServiceB.methodB也要回滚。</p>\n</li>\n<li><p><strong>REQUIRES_NEW</strong>： 支持当前事务，如果当前没有事务，则新建一个事务且挂起外部事务<br>[辅助理解]如ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为PROPAGATION_REQUIRES_NEW，那么当执行到ServiceB.methodB的时候，ServiceA.methodA所在的事务就会挂起，ServiceB.methodB会起一个新的事务，等待ServiceB.methodB的事务完成以后，A才继续执行。他与PROPAGATION_REQUIRED的事务区别在于事务的回滚程度了。因为ServiceB.methodB是新起一个事务，那么就是存在两个不同的事务。如果ServiceB.methodB已经提交，那么ServiceA.methodA失败回滚，ServiceB.methodB是不会回滚的。如果ServiceB.methodB失败回滚，如果他抛出的异常被ServiceA.methodA捕获，ServiceA.methodA事务仍然可能提交</p>\n</li>\n<li><p><strong>MANDATORY</strong>: 支持当前事务，如果当前没有事务，则抛出异常</p>\n</li>\n<li><strong>SUPPORTS</strong>： 支持当前事务，如果当前没有事务，就以非事务方式执行</li>\n<li><strong>NOT_SUPPORTED</strong>： 以非事务方式执行，如果当前存在事务，则挂起</li>\n<li><strong>NEVER</strong>： 以非事务方式执行，如果当前存在事务，则抛出异常</li>\n</ul>\n<h3 id=\"6-Spring如何管理事务的\"><a href=\"#6-Spring如何管理事务的\" class=\"headerlink\" title=\"6. Spring如何管理事务的\"></a>6. Spring如何管理事务的</h3><p>Spring事务管理主要包括三个接口：<br>1) PlatformTransactionManager: 事务管理器，主要包括commit()、rollback()、getTransaction()<br>2) TransactionDefinition: 事务定义信息。主要包括getIsolationLevel()、getPropagationBehavior()、getTimeout()、isReadOnly()<br>3) TransactionStatus: 事务具体运行状态。主要包括hasSavepoint()、isCompleted()、isNewTransaction()</p>\n<h3 id=\"7-Spring怎么配置事务-具体说出一些关键的xml元素\"><a href=\"#7-Spring怎么配置事务-具体说出一些关键的xml元素\" class=\"headerlink\" title=\"7. Spring怎么配置事务(具体说出一些关键的xml元素)\"></a>7. Spring怎么配置事务(具体说出一些关键的xml元素)</h3><p>配置事务的方式有两种：<br>1）基于XML的事务配置<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- from the file 'context.xml' --&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span>  </span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>  </span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">xmlns:aop</span>=<span class=\"string\">\"http://www.springframework.org/schema/aop\"</span>  </span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">xmlns:tx</span>=<span class=\"string\">\"http://www.springframework.org/schema/tx\"</span>  </span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"  </span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  </span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">     http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd  </span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">     http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd\"</span>&gt;</span>  </span><br><span class=\"line\">      </span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 数据元信息 --&gt;</span>  </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.apache.commons.dbcp.BasicDataSource\"</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">\"close\"</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driverClassName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"oracle.jdbc.driver.OracleDriver\"</span>/&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"jdbc:oracle:thin:@rj-t42:1521:elvis\"</span>/&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"root\"</span>/&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"root\"</span>/&gt;</span>  </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 管理事务的类,指定我们用谁来管理我们的事务--&gt;</span>  </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"txManager\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span>/&gt;</span>  </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span>   </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 首先我们要把服务对象声明成一个bean  例如HelloService --&gt;</span>  </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"helloService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.yintong.service.HelloService\"</span>/&gt;</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 然后是声明一个事物建议tx:advice,spring为我们提供了事物的封装，这个就是封装在了&lt;tx:advice/&gt;中 --&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- &lt;tx:advice/&gt;有一个transaction-manager属性，我们可以用它来指定我们的事物由谁来管理。</span></span><br><span class=\"line\"><span class=\"comment\">      默认：事务传播设置是 REQUIRED，隔离级别是DEFAULT --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">tx:advice</span> <span class=\"attr\">id</span>=<span class=\"string\">\"txAdvice\"</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">\"txManager\"</span>&gt;</span>  </span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 配置这个事务建议的属性 --&gt;</span>  </span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">tx:attributes</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定所有get开头的方法执行在只读事务上下文中 --&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"get*\"</span> <span class=\"attr\">read-only</span>=<span class=\"string\">\"true\"</span>/&gt;</span>  </span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 其余方法执行在默认的读写上下文中 --&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"*\"</span>/&gt;</span>  </span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">tx:attributes</span>&gt;</span>  </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">tx:advice</span>&gt;</span>  </span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 我们定义一个切面，它匹配FooService接口定义的所有操作 --&gt;</span>  </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">aop:config</span>&gt;</span>  </span><br><span class=\"line\">     <span class=\"comment\">&lt;!-- &lt;aop:pointcut/&gt;元素定义AspectJ的切面表示法，这里是表示com.yintong.service.helloService包下的任意方法。 --&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">aop:pointcut</span> <span class=\"attr\">id</span>=<span class=\"string\">\"helloServiceOperation\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\"execution(* com.yintong.service.helloService.*(..))\"</span>/&gt;</span>  </span><br><span class=\"line\">     <span class=\"comment\">&lt;!-- 然后我们用一个通知器：&lt;aop:advisor/&gt;把这个切面和tx:advice绑定在一起，表示当这个切面：fooServiceOperation执行时tx:advice定义的通知逻辑将被执行 --&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">aop:advisor</span> <span class=\"attr\">advice-ref</span>=<span class=\"string\">\"txAdvice\"</span> <span class=\"attr\">pointcut-ref</span>=<span class=\"string\">\"helloServiceOperation\"</span>/&gt;</span>  </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span>  </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>2）基于注解的事务配置</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span>  </span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>  </span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">xmlns:aop</span>=<span class=\"string\">\"http://www.springframework.org/schema/aop\"</span>  </span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">xmlns:tx</span>=<span class=\"string\">\"http://www.springframework.org/schema/tx\"</span>  </span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"  </span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  </span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">     http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd  </span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">     http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd\"</span>&gt;</span>  </span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"helloService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.yintong.service.HelloService\"</span>/&gt;</span>  </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"txManager\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"</span>&gt;</span>  </span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span>/&gt;</span>  </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 配置注解事务 --&gt;</span>  </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">\"txManager\"</span>/&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"8-说说你对Spring的的理解，非单例注入的原理？它的生命周期？循环注入的原理\"><a href=\"#8-说说你对Spring的的理解，非单例注入的原理？它的生命周期？循环注入的原理\" class=\"headerlink\" title=\"8. 说说你对Spring的的理解，非单例注入的原理？它的生命周期？循环注入的原理?\"></a>8. 说说你对Spring的的理解，非单例注入的原理？它的生命周期？循环注入的原理?</h3><p><strong>谈谈对Spring的理解</strong><br>1) Srping是一个开源框架，主要为简化企业级应用开发而生</p>\n<ul>\n<li>控制反转(IOC): Spring容器使用了工厂模式为我们创建了所需的对象，我们使用时不需要自己创建，直接调用Spring为我们提供的对象即可，这就是控制反转的思想</li>\n<li>依赖注入(DI): Spring使用Java Bean的Set方法或者带参数的构造方法为我们创建所需对象时将其属性自动设置所需值得过程就是依赖注入的思想</li>\n<li>面向切面编程(AOP): 在面向切面编程中，我们将一个个对象某些类似方面抽象成一个切面，对这个切面进行权限验证、事务管理、记录日志等公共操作<br>2) 在Spring中所有管理的都是JavaBean对象，而BeanFactory和ApplicationContext就是Spring框架的IOC容器，一般使用ApplicationContext,不仅包含BeanFacotry,同时还行了很多扩展<br><strong>非单例注入的原理</strong></li>\n</ul>\n<p>问题描述：singleton类型的bean A方法，需要调用prototype类型的bean B方法，对于bean A来说，容器只会调用一次，这样就没法在需要的时候每次让容器为bean A提供一个新的bean B实例<br>解决方案：<br>1) 放弃控制反转： 通过实现ApplicationContextAware接口<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommandManager</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationContextAware</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApplicationContext applicationContext;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Command <span class=\"title\">createCommand</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (Command) <span class=\"keyword\">this</span>.applicationContext.getBean(<span class=\"string\">\"asyncCommand\"</span>);  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.applicationContext = applicationContext; </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2) 采用Lookup方法注入<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span>  </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>  </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 通过scope=\"prototype\"界定该bean是多例的 --&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"asyncCommand\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"learn.frame.spring.scope.dropioc.AsyncCommand\"</span>  </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">scope</span>=<span class=\"string\">\"prototype\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span>  </span><br><span class=\"line\">          </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"commandManager\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"learn.frame.spring.scope.lookup.CommandManager\"</span>&gt;</span>    </span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">lookup-method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"createCommand\"</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"asyncCommand\"</span>/&gt;</span>    </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>[辅助理解]  </p>\n<ol>\n<li>被注入方法不一定是抽象的，如果被注入方法是抽象的，动态生成的子类(这里就是动态生成的CommandManager的子类)会实现该方法。否则，动态生成的子类会覆盖类里的具体方法</li>\n<li>为了让这个动态子类得以正常工作，需要把CGLIB的jar文件放在classpath里，这就是我们引用cglib包的原因</li>\n<li>Spring容器要子类化的类(CommandManager)不能是final的，要覆盖的方法(createCommand)也不能是final的</li>\n</ol>\n<p><strong>Spring生命周期</strong><br><a href=\"https://shenjian.online/2019/01/20/Spring%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/#6-%E8%A7%A3%E9%87%8ASpring%E6%A1%86%E6%9E%B6%E4%B8%ADbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\" target=\"_blank\" rel=\"noopener\">Spring Bean生命周期</a></p>\n<h3 id=\"9-SpringMVC中DispatcherServlet初始化过程\"><a href=\"#9-SpringMVC中DispatcherServlet初始化过程\" class=\"headerlink\" title=\"9. SpringMVC中DispatcherServlet初始化过程\"></a>9. SpringMVC中DispatcherServlet初始化过程</h3><h3 id=\"10-Netty的线程模型，-netty如何基于reactor模型上实现的\"><a href=\"#10-Netty的线程模型，-netty如何基于reactor模型上实现的\" class=\"headerlink\" title=\"10. Netty的线程模型， netty如何基于reactor模型上实现的\"></a>10. Netty的线程模型， netty如何基于reactor模型上实现的</h3><h3 id=\"11-为什么选择netty\"><a href=\"#11-为什么选择netty\" class=\"headerlink\" title=\"11. 为什么选择netty\"></a>11. 为什么选择netty</h3><h3 id=\"12-谈谈TCP三次握手，四次挥手\"><a href=\"#12-谈谈TCP三次握手，四次挥手\" class=\"headerlink\" title=\"12. 谈谈TCP三次握手，四次挥手\"></a>12. 谈谈TCP三次握手，四次挥手</h3><h3 id=\"13-什么是TCP粘包、拆包，解决方式是什么\"><a href=\"#13-什么是TCP粘包、拆包，解决方式是什么\" class=\"headerlink\" title=\"13. 什么是TCP粘包、拆包，解决方式是什么\"></a>13. 什么是TCP粘包、拆包，解决方式是什么</h3><p>TCP是基于字节流的，且首部没有表示数据长度的字段，因此才有粘包、拆包现象发生。<br>具体表现形式为：客户端向服务端发送包packet1与packet2,如果服务端接收到了一个包，由于TCP是不会丢包的，则发生了粘包；<br>如果服务器接收到了两个包，其中一个多出来一块，一个少了一块，则发生了粘包与拆包</p>\n<p><strong>粘包、拆包原因</strong>[辅助理解，可不回答]</p>\n<ol>\n<li>要发送数据大于TCP发送缓冲区剩余空间大小，则发生拆包</li>\n<li>待发送的数据大于MSS(最大报文长度)，则在传输前进行拆包</li>\n<li>要发送的数据小于TCP发送缓冲区剩余空间大小，TCP将多次写入的数据一次发送出去，则发生粘包</li>\n<li>接收数据端的应用层没有及时接收缓冲区中的数据，将发生粘包</li>\n</ol>\n<p><strong>解决方法</strong></p>\n<ol>\n<li>发送端给每个数据包添加包首部，首部中至少包含数据包的长度</li>\n<li>发送端将数据端封装 成固定长度（不够的可以通过补0填充）</li>\n<li>可以在数据包之间设置边界，如添加特殊符号</li>\n</ol>\n<p>扩展：UDP是基于报文发送的，首部采用16bit来指示UDP数据报文长度，因此不会发生粘包、拆包</p>\n<h3 id=\"14-Netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决\"><a href=\"#14-Netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决\" class=\"headerlink\" title=\"14. Netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决\"></a>14. Netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决</h3><h3 id=\"15-Netty的心跳处理在弱网下怎么办\"><a href=\"#15-Netty的心跳处理在弱网下怎么办\" class=\"headerlink\" title=\"15. Netty的心跳处理在弱网下怎么办\"></a>15. Netty的心跳处理在弱网下怎么办</h3><h3 id=\"16-Netty的通许协议是什么样的\"><a href=\"#16-Netty的通许协议是什么样的\" class=\"headerlink\" title=\"16. Netty的通许协议是什么样的\"></a>16. Netty的通许协议是什么样的</h3><h3 id=\"17-SpringMVC用到的注解，作用是什么，原理\"><a href=\"#17-SpringMVC用到的注解，作用是什么，原理\" class=\"headerlink\" title=\"17. SpringMVC用到的注解，作用是什么，原理\"></a>17. SpringMVC用到的注解，作用是什么，原理</h3><p><strong>SpringMVC运行原理</strong><br>1) Http请求: 客户端请求提交到DispatcherServlet<br>2) 寻找处理器: 由DispatcherServlet查询一个或多个HandlerMapping,找到处理请求的Controller<br>3) 调用处理器: DispatcherServlet将请求提交到Controller<br>4) 调用业务处理和返回结果: Controller调用业务处理后，返回ModelAndView<br>5) 处理视图映射并返回模型: DispatcherServlet查询一个或多个ViewResolver，找到ModelAndView指定的视图<br>6) Http响应: 视图将结果显示到客户端</p>\n<p><strong>主要注解</strong><br>@Controller 用于注解控制层<br>@RestController: 相当于@Controller与@ResponseBody<br>@Component 泛指组件<br>@Repository 用于注解dao层<br>@Service 用于注解业务层</p>\n<p>@RequestBody @RequestMapping @Autowired @PathVariable @RequestParam @RequestHeader等</p>\n<h3 id=\"18-SpringBoot启动机制\"><a href=\"#18-SpringBoot启动机制\" class=\"headerlink\" title=\"18. SpringBoot启动机制\"></a>18. SpringBoot启动机制</h3><h3 id=\"19-SpringBoot与Spring区别\"><a href=\"#19-SpringBoot与Spring区别\" class=\"headerlink\" title=\"19. SpringBoot与Spring区别\"></a>19. SpringBoot与Spring区别</h3><p>SpringBoot实现了自动配置，降低了项目搭建的复杂度<br>SpringBoot集成了大量常用第三方库，几乎零配置或少配置开箱即用  </p>\n","categories":["JAVA"],"tags":["面试","JAVA"]},{"title":"腾讯篇之JVM","url":"http://www.shenjian.online/2019/11/03/腾讯篇之JVM/","content":"<h3 id=\"1-什么情况下会发生栈内存溢出\"><a href=\"#1-什么情况下会发生栈内存溢出\" class=\"headerlink\" title=\"1. 什么情况下会发生栈内存溢出\"></a>1. 什么情况下会发生栈内存溢出</h3><p>栈分配空间太小，或执行的方法递归层数太多创建了太多的栈帧导致溢出<br>解决方案：配置-Xss参数增加线程栈大小，优化程序也至关重要</p>\n<h3 id=\"2-JVM的内存结构，Eden和Survivor的比例\"><a href=\"#2-JVM的内存结构，Eden和Survivor的比例\" class=\"headerlink\" title=\"2. JVM的内存结构，Eden和Survivor的比例\"></a>2. JVM的内存结构，Eden和Survivor的比例</h3><p>内存结构：</p>\n<ul>\n<li>堆：存放对象</li>\n<li>方法区： 存放类和变量</li>\n<li>JAVA虚拟机栈：存放运行时栈帧</li>\n<li>本地方法栈</li>\n<li>程序计数器</li>\n</ul>\n<p>Eden区是一块，Survivor是两块，均属于堆中的新生代<br>Eden和Survivor的比例是8：1：1，可以通过-XX:SurvivorRatio来设定</p>\n<p>JDK1.8后取消了方法区，将永久代放到了本地内存里面</p>\n<h3 id=\"3-JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor\"><a href=\"#3-JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor\" class=\"headerlink\" title=\"3. JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor\"></a>3. JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor</h3><ul>\n<li>共享内存区 = 持久代 + 堆</li>\n<li>持久代 = 方法区 + 其他</li>\n<li>堆 = 新生代 + 老年代 （1:2通过-XX:NewRatio设置）</li>\n<li>新生代 = Eden + S0 + S1(8:1:1通过-XX:SurvivorRatio设置)</li>\n</ul>\n<p>Survivor具有预筛选保证，只有对象经历了16次Minor GC才会被送到老年代，Survivor可以减少被送到老年代的对象，进而减少Full GC发生<br>有两个Survivor，在Minor GC后，可以保证一个为空，另一个非空且无内存碎片</p>\n<h3 id=\"4-JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数\"><a href=\"#4-JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数\" class=\"headerlink\" title=\"4. JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数\"></a>4. JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数</h3><p>完整GC流程：</p>\n<ul>\n<li>当Eden区满了，JVM触发一次Minor GC，以收集新生代的垃圾，存活下来的对象，会被转移到Survivor区</li>\n<li>大对象(如很长的字符串)直接进入老年代</li>\n<li>如果对象在Eden出生，每经历过一次MinorGC，并且被Survivor容纳的话，年龄加1，直到年龄超过15，就会进入老年代</li>\n<li>Major GC发生在老年代，通常会伴随着至少一次Minor GC，比Minor GC慢10倍以上</li>\n</ul>\n<p>-Xss: 栈容量<br>-Xms：设置最小堆内存<br>-Xmx：设置最大堆内存<br>-Xmn10M：设置新生代10M<br>-XX:SurvivorRatio=8：设置Eden、Survivor比例8:1<br>-XX:PermSize=32M：永久代最小内存32M<br>-XX:MaxPermSize=64M：永久代最大扩展内存64M<br>-XX:+HeapDumpOnOutOfMemoryError：堆内存溢出时Dump出当前的内存堆转储快照以便事后分析</p>\n<h3 id=\"5-你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点\"><a href=\"#5-你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点\" class=\"headerlink\" title=\"5. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点\"></a>5. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点</h3><ul>\n<li>Serial收集器：新生代单线程的收集器，收集垃圾时，必须stop the world,使用复制算法</li>\n<li>ParNew收集器：新生代Serial多线程版本收集器，也需要stop the world,使用复制算法</li>\n<li><p>Paraller Scavenge收集器：新生代并发的多线程收集器，目标达到一个可控的吞吐量，使用复制算法</p>\n</li>\n<li><p>Serial Old收集器： 是Serial收集器的老年代版本，单线程，使用标记整理算法</p>\n</li>\n<li>Parallel Old收集器: Parallel Scavenge收集器的老年代版本，多线程，使用标记整理算法</li>\n<li>CMS收集器：是一种以最短回收停顿时间为目标的老年代收集器，使用标记清除算法，运行过程:初始标记-并发标记-重新标记-并发清除，收集后会产生大量空间碎片</li>\n<li>G1收集器： 可作用于新生代与老年代，是标记整理算法，运行过程:初始标记-并发标记-最终标记-筛选标记，不会产生碎片，可以精确的控制停顿</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>CMS收集器</th>\n<th>G1收集器</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>算法类型</td>\n<td>标记-清除</td>\n<td>标记-整理</td>\n</tr>\n<tr>\n<td>收集范围</td>\n<td>老年代</td>\n<td>新生代、老年代</td>\n</tr>\n<tr>\n<td>目标</td>\n<td>最短的停顿时间为目标</td>\n<td>可预测的垃圾回收时间</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"6-垃圾回收算法的实现原理\"><a href=\"#6-垃圾回收算法的实现原理\" class=\"headerlink\" title=\"6. 垃圾回收算法的实现原理\"></a>6. 垃圾回收算法的实现原理</h3><ul>\n<li>引用计数法 堆中每个对象拥有一个引用计数。被引用一次，计数加1，被引用变量值变为null,则计数减1，直到计算为0，则表示变为无用对象。缺点是无法识别循环引用对象</li>\n<li>引用可达法(根搜索算法) 从一个节点<a href=\"https://shenjian.online/2020/02/05/SAP%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/#12-1-GC-ROOT%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\" target=\"_blank\" rel=\"noopener\">GC ROOT</a>开始，寻找一个引用的节点，找到后，继续寻找这个节点的引用节点，寻找完毕后，剩余的节点则认为是没有被引用的对象</li>\n</ul>\n<h3 id=\"7-当出现了内存溢出，你怎么排错\"><a href=\"#7-当出现了内存溢出，你怎么排错\" class=\"headerlink\" title=\"7. 当出现了内存溢出，你怎么排错\"></a>7. 当出现了内存溢出，你怎么排错</h3><p>JVM除了程序计数器其他区域都可能发生内存溢出</p>\n<p><strong>堆溢出OutOfMemoryError</strong><br>用visualVM工具分析堆快照(-XX:+HeapDumpOnOutOfMemoryError)<br>如果发生内存泄漏<br>1) 找到泄漏的对象 2）找到泄漏对象的GC ROOT 3)根据泄漏对象和GC ROOT找到导致内存泄漏的代码 4) 设法排除泄漏对象和GC ROOT的连接<br>如果不存在内存泄漏，看下能否增大JVM堆的容量</p>\n<p><strong>栈溢出</strong><br>一般由于递归，导致栈空间不足，发生OutOfMemoryError：Java heap space说明运行时常量池移到了堆中</p>\n<p><strong>方法区溢出</strong><br>方法区是存放类的地方。如果多个项目有多个相同jar,且都在WEB-INF/lib下，则每个项目都会加载一遍jar,会导致方法区有大量相同类，又不会被GC,则可建立共享lib库，否则尝试增加-XX:MaxPermSize</p>\n<h3 id=\"8-JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等\"><a href=\"#8-JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等\" class=\"headerlink\" title=\"8. JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等\"></a>8. JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等</h3><p>思路： 先画出Java内存模型图，结合例子volatile ，说明什么是重排序，内存屏障，最好能给面试官写以下demo说明。</p>\n<p>1）Java内存模型图：<br>Java模型规定了所有的变量都存储在主内存中，每个线程线程有自己的工作内存，线程的工作内存保存了所使用变量主内存的副本拷贝。<br>线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。<br>不同线程之间无法访问对方工作内存的变量，线程间变量传递依赖于主内存。</p>\n<p>2）指令重排<br>处理器将指令乱序执行，可以大大提高执行效率，这就是指令重排</p>\n<p>3）内存屏障<br>内存屏障，也叫内存栅栏，是一种CPU指令，用于控制特定条件下的重排序与内存可见性问题</p>\n<ul>\n<li>LoadLoad屏障： 对于语句Load1;LoadLoad;Load2,在Load2及后续读取操作要读取的数据被访问前，保证load1要读取的数据被读取完毕</li>\n<li>StoreStore屏障：对于语句Store1;StoreStore;Store2,在Store2及后续写入操作执行时，保证Store的写入操作对其他处理器可见</li>\n<li>LoadStore屏障： 对于语句Load1;LoadStore;Store2,在Store2及后续写入操作执行时，保证Load要读取的数据被读取完毕</li>\n<li>StoreLoad屏障： 对于语句Store1;StoreLoad;Load1,在Load及以后所有的读取操作执行前，保证Store1的写入操作对所有处理器可见。它的开销是最大的，这个屏障是个万能屏障，兼具其他三种屏障的功能</li>\n</ul>\n<p>4）happen-before原则</p>\n<p><a href=\"https://shenjian.online/2019/06/16/happens-before%E8%A7%84%E5%88%99/\" target=\"_blank\" rel=\"noopener\">happens-before规则</a></p>\n<h3 id=\"9-简单说说你了解的类加载器，可以打破双亲委派么，怎么打破\"><a href=\"#9-简单说说你了解的类加载器，可以打破双亲委派么，怎么打破\" class=\"headerlink\" title=\"9. 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破\"></a>9. 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破</h3><p>思路： 先说明一下什么是类加载器，可以给面试官画个图，再说一下类加载器存在的意义，说一下双亲委派模型，最后阐述怎么打破双亲委派模型。</p>\n<p>1) 什么是类加载器<br>类加载器就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象</p>\n<ul>\n<li>启动类加载器（Bootstrap ClassLoader）: 由C++语言实现(针对HotSpot),负责将存放在&lt;JAVA_HOME&gt;\\lib目录或-Xbootclasspath参数指定路径中的类库</li>\n<li>其他类加载器：由Java语言实现，继承自抽象类ClassLoader<ul>\n<li>扩展类加载器（Extension ClassLoader）: 负责加载&lt;JAVA_HOME&gt;\\lib\\ext或java.ext.dirs系统变量指定路径类库</li>\n<li>应用程序类加载器（Application ClassLoader）: 负责加载用户路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况下，如果我们没有自定义类加载器就默认使用这个加载器</li>\n</ul>\n</li>\n</ul>\n<p>2）双亲委派模型<br>    如果一个类加载器收到类加载请求时，首先不会尝试自己加载这个类，而是把这个请求委派给父加载器完成。每个加载器都是如此，只有当父加载器在自己的搜索范围找不到指定的类时（即ClassNotFoundException）,子加载器才会尝试自己去加载</p>\n<p>3）为什么需要双亲委派模型<br>    如果没有双亲委派，那么用户自定义一个java.lang.Object, java.lang.String类，并把它放在classpath中，那么类之间的比较结果及类的唯一性将无法保证。双亲委派模型，防止内存中出现多份同样的字节码</p>\n<p>4）怎么打破双亲委派模型<br>    继承ClassLoader类，重写loadClass和findClass方法</p>\n<h3 id=\"10-你们线上应用的JVM参数有哪些\"><a href=\"#10-你们线上应用的JVM参数有哪些\" class=\"headerlink\" title=\"10. 你们线上应用的JVM参数有哪些\"></a>10. 你们线上应用的JVM参数有哪些</h3><p>思路： 可以说一下堆栈配置相关的，垃圾收集器相关的，还有一下辅助信息相关的。</p>\n<p>1) 堆栈配置相关</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k</span><br><span class=\"line\">-XX:MaxPermSize=16m -XX:NewRatio=4 -XX:SurviorRatio=4 -XX:MaxTenuringThreshold=0</span><br></pre></td></tr></table></figure>\n<p>-Xmx3550m: 最大堆大小为3550m<br>-Xms3550m: 最小堆大小为3550m<br>-Xmn2g: 设置新生代大小为2g<br>-Xss128k: 设置每个线程的栈大小为128K<br>-XX:MaxPermSize: 设置永久代的大小为16m<br>-XX:NewRatio: 设置新生代（包括Eden和两个Survivor区）与老年代的比值(除去永久代)<br>-XX:SurvivorRatio: 设置新生代Eden与Survivor区的大小比值，设置为4，则两个Survivor区与Eden区比值为2：4，一个Survivor区占整个年轻代的1/6<br>-XX:MaxTenuringThreshold: 设置垃圾最大年龄。如果设置为0的话，则新生代不经过Survivor区，直接进入老年代</p>\n<p>2）垃圾收集器相关</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:+UseParallelGC <span class=\"comment\"># 选择垃圾收集器为并行收集器</span></span><br><span class=\"line\">-XX:ParallelGCThreads=20 <span class=\"comment\"># 配置并行收集器的线程数</span></span><br><span class=\"line\">-XX:+UseConcMarkSweepGC <span class=\"comment\"># 设置老年代为并发收集</span></span><br><span class=\"line\">-XX:CMSFullGCsBeforeCompaction=5 <span class=\"comment\"># 由于CMS收集器不对内存空间进行压缩整理，所有会产生内存碎片。此值设置运行5次Full GC后对内存空间压缩整理</span></span><br><span class=\"line\">-XX:+UseCMSCompactAtFullCollection <span class=\"comment\"># 打开对老年代的压缩，可能会影响性能，但是可以消除碎片</span></span><br></pre></td></tr></table></figure>\n<p>3）辅助信息相关</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:+PrintGC</span><br><span class=\"line\">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>\n<p>-XX:+PrintGC 输出形式:<br>[GC 118250K-&gt;113543K(130112K), 0.0094143 secs] [Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</p>\n<p>-XX:+PrintGCDetails 输出形式:<br>[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs]<br>[GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs</p>\n<h3 id=\"11-g1和cms区别-吞吐量优先和响应优先的垃圾收集器选择\"><a href=\"#11-g1和cms区别-吞吐量优先和响应优先的垃圾收集器选择\" class=\"headerlink\" title=\"11. g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择\"></a>11. g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择</h3><p><a href=\"#5. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点\">详见5</a></p>\n<h3 id=\"12-怎么打出线程栈信息\"><a href=\"#12-怎么打出线程栈信息\" class=\"headerlink\" title=\"12. 怎么打出线程栈信息\"></a>12. 怎么打出线程栈信息</h3><p>思路： 可以说一下jps，top ，jstack这几个命令，再配合一次排查线上问题进行解答。</p>\n<ul>\n<li>首先执行<code>jps</code>,获取进程号</li>\n<li>然后执行<code>top -Hp pid</code>，获取本进程所有线程的CPU耗时性能</li>\n<li><code>jstack pid</code>,查看当前java进程的堆栈信息</li>\n<li>或者 <code>jstack -l /tmp/output.txt</code> 把堆栈信息打到一个txt文件</li>\n<li>可以使用<a href=\"https://fastthread.io/\" target=\"_blank\" rel=\"noopener\">fastthread</a>进行堆栈定位</li>\n</ul>\n","categories":["JVM"],"tags":["面试","JVM"]},{"title":"33_搜索旋转排序数组_leetcode","url":"http://www.shenjian.online/2019/11/02/33-搜索旋转排序数组-leetcode/","content":"<h2 id=\"33-搜索旋转排序数组\"><a href=\"#33-搜索旋转排序数组\" class=\"headerlink\" title=\"33. 搜索旋转排序数组\"></a>33. 搜索旋转排序数组</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。<br>你可以假设数组中不存在重复的元素。<br>你的算法时间复杂度必须是 O(log n) 级别。</p>\n<blockquote>\n<p>输入: nums = [4,5,6,7,0,1,2], target = 0<br>输出: 4<br>输入: nums = [4,5,6,7,0,1,2], target = 3<br>输出: -1</p>\n</blockquote>\n<p><strong>题解：</strong> 时间复杂度O(log n),我们可以想到二分查找，由于存在旋转点，故二分点要么在旋转点左侧，要么在其右侧(这里的右侧假定包含旋转点)，则<br>可分为两种情况讨论：<br>1）在左侧即0~mid有序(因为不含有旋转点)<br>2）在右侧即0~mid无序(因为包含旋转点)<br>找出这两种情况low=mid+1的条件即可，详见代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> high = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (low &lt; high) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> mid = (low + high) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (nums[mid] == target) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 把数组大致分为两组，一组为左侧未旋转有序数组，一组为右侧旋转有序数组</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如[3 4 5 1 2]， [3，4，5]称为左侧，[1，2]称为右侧</span></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 0~mid有序，向后规约条件</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// nums[mid] &gt;= nums[0] 表示0~mid有序</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// target &gt; nums[mid] 表示target位于左侧且大于nums[mid],向后规约</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// target &lt; nums[0] 表示target位于右侧，向后规约</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (nums[mid] &gt;= nums[<span class=\"number\">0</span>] &amp;&amp; (target &gt; nums[mid] || target &lt; nums[<span class=\"number\">0</span>])) &#123;</span><br><span class=\"line\">\t\t\t\tlow = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; nums[<span class=\"number\">0</span>] &amp;&amp; target &gt; nums[mid] &amp;&amp; target &lt; nums[<span class=\"number\">0</span>]) &#123; <span class=\"comment\">// 0~mid无序(即包含翻转点)，向后规约条件</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// nums[mid] &lt; nums[0] 表示nums[mid]位于右侧</span></span><br><span class=\"line\">\t\t\t\tlow = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\thigh = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> low == high &amp;&amp; nums[low] == target ? low : -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"腾讯篇之JAVA基础","url":"http://www.shenjian.online/2019/11/01/腾讯篇之JAVA基础/","content":"<h2 id=\"JAVA基础\"><a href=\"#JAVA基础\" class=\"headerlink\" title=\"JAVA基础\"></a>JAVA基础</h2><h3 id=\"1-JAVA中的几种基本数据类型是什么，各自占用多少字节。\"><a href=\"#1-JAVA中的几种基本数据类型是什么，各自占用多少字节。\" class=\"headerlink\" title=\"1. JAVA中的几种基本数据类型是什么，各自占用多少字节。\"></a>1. JAVA中的几种基本数据类型是什么，各自占用多少字节。</h3><table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>字节</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>byte</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>short</td>\n<td>2</td>\n<td>0</td>\n</tr>\n<tr>\n<td>char</td>\n<td>2</td>\n<td>‘\\u0000’</td>\n</tr>\n<tr>\n<td>int</td>\n<td>4</td>\n<td>0</td>\n</tr>\n<tr>\n<td>float</td>\n<td>4</td>\n<td>0.0f</td>\n</tr>\n<tr>\n<td>long</td>\n<td>8</td>\n<td>0</td>\n</tr>\n<tr>\n<td>double</td>\n<td>8</td>\n<td>0.0d</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>4</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n<p>PS: JVM规范中，boolean当做int处理，也就是4字节，而boolean数组当做byte数组处理，即boolean类型的数组里面每一个元素占一个字节             </p>\n<h3 id=\"2-String类能被继承吗，为什么\"><a href=\"#2-String类能被继承吗，为什么\" class=\"headerlink\" title=\"2. String类能被继承吗，为什么\"></a>2. String类能被继承吗，为什么</h3><p>不可以，因为String类有final，而final修饰的类是不能被继承的</p>\n<h3 id=\"3-String，StringBuffer，StringBuilder的区别及扩容机制\"><a href=\"#3-String，StringBuffer，StringBuilder的区别及扩容机制\" class=\"headerlink\" title=\"3. String，StringBuffer，StringBuilder的区别及扩容机制\"></a>3. String，StringBuffer，StringBuilder的区别及扩容机制</h3><ul>\n<li>String：不可变，每次对String进行操作都会产生新对象，效率低且浪费内存空间</li>\n<li>StringBuffer： 可变字符序列，效率低，线程安全</li>\n<li>StringBuilder: 可变字符序列，效率高，线程不安全  </li>\n</ul>\n<p>StringBuilder、 StringBuffer继承AbstractStringBuilder，无参数默认初始容量为16，<br>追加字符串的时候长度超过16则扩容:增加自身长度一倍再加2,如果还放不下，则扩容为所需长度minCapacity<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">newCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = (value.length &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            newCapacity = minCapacity;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-ArrayList和LinkedList有什么区别\"><a href=\"#4-ArrayList和LinkedList有什么区别\" class=\"headerlink\" title=\"4. ArrayList和LinkedList有什么区别\"></a>4. ArrayList和LinkedList有什么区别</h3><ul>\n<li>ArrayList: 基于数组实现的非线程安全的集合。查询速度快，插入、删除中间元素速度慢</li>\n<li>LinkedList: 基于链表实现的非线程安全的集合。查询速度慢，插入、删除中间元素快</li>\n<li>Vector: 基于数组实现的线程安全的集合。采用synchronize加锁,性能比ArrayList差</li>\n<li>CopyOnWriteArrayList: 基于数组实现的线程安全的写时复制集合，采用ReentrantLock加锁，性能比Vector高，适合读多写少的场景</li>\n</ul>\n<h3 id=\"5-讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。\"><a href=\"#5-讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。\" class=\"headerlink\" title=\"5. 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。\"></a>5. 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。</h3><p>父类静态变量<br>父类静态代码块<br>子类静态变量<br>子类静态代码块</p>\n<p>父类非静态变量(父类实例成员变量)<br>父类构造函数<br>子类非静态变量(子类实例成员变量)<br>子类构造函数</p>\n<h3 id=\"6-用过哪些Map类，都有什么区别，HashMap是线程安全的吗-并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。\"><a href=\"#6-用过哪些Map类，都有什么区别，HashMap是线程安全的吗-并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。\" class=\"headerlink\" title=\"6. 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。\"></a>6. 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。</h3><p>HashMap、ConcurrentHashMap、TreeMap、 LinkedHashMap</p>\n<p>HashMap线程不安全，由数组(Node数组)+链表+红黑树(链表长度大于8转换为红黑树)实现，采用hash表来存储,key采用hashcode,数量超过threshold时进行2倍扩容，默认容量16，负载因子0.75，桶的数量11,<br>采用链地址法解决hash冲突,简单来说,就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上<br><a href=\"https://zhuanlan.zhihu.com/p/21673805\" target=\"_blank\" rel=\"noopener\">Java 8系列之重新认识HashMap</a></p>\n<p>大量采用CAS操作，JDK1.7对Segment进行加锁，JDK1.8对桶中的头结点进行加锁<br><a href=\"https://shenjian.online/2019/02/14/ConcurrentHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/\" target=\"_blank\" rel=\"noopener\">ConcurrentHashMap的实现原理</a></p>\n<p>TreeMap和LinkedHashMap有序的（TreeMap默认升序，LinkedHashMap记录插入的顺序）</p>\n<h3 id=\"6-1-为什么HashMap是非线程安全的？什么情况下会出现线程安全问题？\"><a href=\"#6-1-为什么HashMap是非线程安全的？什么情况下会出现线程安全问题？\" class=\"headerlink\" title=\"6.1 为什么HashMap是非线程安全的？什么情况下会出现线程安全问题？\"></a>6.1 为什么HashMap是非线程安全的？什么情况下会出现线程安全问题？</h3><p>HashMap会进行resize操作，在resize操作的时候会造成线程不安全<br>1）put的时候导致多线程数据不一致<br>2）get操作可能因为resize而引起死循环(cpu100%)</p>\n<h3 id=\"7-JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计\"><a href=\"#7-JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计\" class=\"headerlink\" title=\"7. JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计\"></a>7. JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计</h3><p>Segment继承ReentrantLock,每个锁控制一段，当每个Segment越来越大时，锁定粒度则变大，性能会下降<br>ConcurrentHashMap底层采用数组+链表+红黑树，大量采用CAS操作，加锁采用synchronized，只对桶的头节点进行加锁，粒度较小。</p>\n<p>减少内存开销。如果采用ReentrantLock需要节点继承AQS来获得同步支持，增加内存开销,<br>内部优化。synchronized是有JVM直接支持的，JVM能够在运行时做相应优化如，锁粗化、锁消除、锁自旋等</p>\n<h3 id=\"8-有没有有顺序的Map实现类，如果有，他们是怎么保证有序的\"><a href=\"#8-有没有有顺序的Map实现类，如果有，他们是怎么保证有序的\" class=\"headerlink\" title=\"8. 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的\"></a>8. 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的</h3><p>TreeMap和LinkedHashMap有序的（TreeMap默认升序，LinkedHashMap记录插入的顺序）<br>TreeMap是基于比较器Comparator实现有序的，LinkedHashMap是基于链表实现数据插入有序的</p>\n<h3 id=\"9-抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么\"><a href=\"#9-抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么\" class=\"headerlink\" title=\"9. 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么\"></a>9. 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么</h3><ul>\n<li>接口只能做方法声明，抽象类既可以做方法声明也可以做方法实现</li>\n<li>接口里定义的变量只能是公共的静态常量，抽象类中变量是普通变量</li>\n<li>抽象类里可以没有抽象类，如果一个类中有抽象方法，则一定是抽象类</li>\n<li>抽象方法要被实现，所以不能是静态的，也不能是私有的</li>\n<li>接口继承接口，并可多继承接口，但类只能单继承</li>\n</ul>\n<p>类不能继承多个类<br>接口可以继承多个接口<br>类可以实现多个接口</p>\n<h3 id=\"10-继承、组合、聚合有什么区别\"><a href=\"#10-继承、组合、聚合有什么区别\" class=\"headerlink\" title=\"10. 继承、组合、聚合有什么区别\"></a>10. 继承、组合、聚合有什么区别</h3><p>继承: is-a的关系，指一个类继承另一个类 <code>public class A extends B{}</code></p>\n<p>聚合：has-a, A可以有B <code>public class A {List&lt;B&gt; b}</code></p>\n<p>组合：contains-a，强聚合，A一定有B <code>public class A {B b}</code></p>\n<h3 id=\"11-IO模型有哪些，讲讲你理解的nio-，他和bio，aio的区别是啥，谈谈reactor模型\"><a href=\"#11-IO模型有哪些，讲讲你理解的nio-，他和bio，aio的区别是啥，谈谈reactor模型\" class=\"headerlink\" title=\"11. IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型\"></a>11. IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型</h3><p><strong>BIO、NIO、AIO</strong></p>\n<p>BIO: 同步并阻塞 客户端有一个IO请求，服务端就需要启动一个线程进行处理。适用于连接数比较少，tomcat采用传统的BIO+线程池模式<br>NIO: 同步非阻塞 客户端的IO请求会注册到多路复用器上，多路复用器轮询到有IO请求时才启动一个线程处理。适用于连接数多且连接比较短(轻操作)的架构，比如聊天服务器<br>AIO: 异步非阻塞 客户端的IO请求都是有OS完成后，在通知服务器启动线程处理。适用于连接数多且连接比较长(重操作)的架构，如相册服务器</p>\n<p><strong>Reactor模型</strong></p>\n<ul>\n<li>事件驱动</li>\n<li>可以处理一个或多个输入源</li>\n<li>通过Service Handle同步的将输入事件采用多路复用分发给相应的Request Handler(一个或多个)处理</li>\n</ul>\n<h3 id=\"12-反射的原理，反射创建类实例的三种方式是什么\"><a href=\"#12-反射的原理，反射创建类实例的三种方式是什么\" class=\"headerlink\" title=\"12. 反射的原理，反射创建类实例的三种方式是什么\"></a>12. 反射的原理，反射创建类实例的三种方式是什么</h3><p>所谓的反射机制就是JAVA语言在运行时拥有一项自观的能力</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class class1 = HelloWorld.class;</span><br><span class=\"line\">Class class2 = helloWorld.getClass();</span><br><span class=\"line\">Class class3 = Class.forName(&quot;online.shenjian.HelloWorld&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">class1.newInstance();</span><br></pre></td></tr></table></figure>\n<h3 id=\"13-反射中，Class-forName和ClassLoader区别\"><a href=\"#13-反射中，Class-forName和ClassLoader区别\" class=\"headerlink\" title=\"13. 反射中，Class.forName和ClassLoader区别\"></a>13. 反射中，Class.forName和ClassLoader区别</h3><p>Class.forName(className)内部实际调用的是Class.forName(className, true, classLoader), 其中true表示表示初始化，静态变量与静态代码块执行<br>ClassLoader.loadClass(className)内部实际调用的是ClassLoader.loadClass(className, false), false表示目标对象不进行链接(即验证、准备、解析)，意味着也不进行初始化工作，静态变量与静态代码块不执行</p>\n<h3 id=\"14-描述动态代理的几种实现方式，分别说出相应的优缺点\"><a href=\"#14-描述动态代理的几种实现方式，分别说出相应的优缺点\" class=\"headerlink\" title=\"14. 描述动态代理的几种实现方式，分别说出相应的优缺点\"></a>14. 描述动态代理的几种实现方式，分别说出相应的优缺点</h3><p><strong>JAVA动态代理</strong> 借助JAVA内部反射机制来生成代理接口匿名类，在调用具体方法前调用InvocationHandler，反射机制在生成类的过程中比较高效，应用前提必须为目标类基于统一的接口<br><strong>CGLIB动态代理</strong> 借助ASM来实现,对代理对象的class文件加载进来，通过修改其字节码生成子类来处理，ASM在生成类后执行过程中比较高效</p>\n<p>实现示例详见<a href=\"https://github.com/SJshenjian/web-project/tree/master/proxy\" target=\"_blank\" rel=\"noopener\">代理实现方式</a></p>\n<h3 id=\"15-为什么CGlib方式可以对接口实现代理\"><a href=\"#15-为什么CGlib方式可以对接口实现代理\" class=\"headerlink\" title=\"15. 为什么CGlib方式可以对接口实现代理\"></a>15. 为什么CGlib方式可以对接口实现代理</h3><p>对接口进行代理的CGLIB,最后的源码是实现了该接口和Factory接口<br>对实现类进行代理的CGLIB,最后的源码时继承了实现类并实现了Factory接口</p>\n<h3 id=\"16-final的用途\"><a href=\"#16-final的用途\" class=\"headerlink\" title=\"16. final的用途\"></a>16. final的用途</h3><p>final修饰符既可以修饰类、方法，也可以修饰变量</p>\n<ul>\n<li>用final修饰的类不能被继承</li>\n<li>用final修饰的方法不能被重写</li>\n<li>用final修饰的变量只能赋值一次且不可修改，静态、实例、局部变量必须被明确赋值</li>\n</ul>\n<h3 id=\"17，-写出单例模式的三种实现方式\"><a href=\"#17，-写出单例模式的三种实现方式\" class=\"headerlink\" title=\"17， 写出单例模式的三种实现方式\"></a>17， 写出单例模式的三种实现方式</h3><p><a href=\"https://github.com/SJshenjian/design-pattern/tree/master/src/main/java/singleton\" target=\"_blank\" rel=\"noopener\">单例的三种实现方式</a></p>\n<h3 id=\"18-如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣\"><a href=\"#18-如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣\" class=\"headerlink\" title=\"18. 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣\"></a>18. 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣</h3><p>父类的equals方法不一定满足子类equals的需求，比如所有的对象都继承Object,默认使用其equals方法，比较两个对象的时候，看他们是否指向同一个地址<br>但我们的需求是对象的某个属性相同，就相同，此时需要重写equals方法与hashcode方法，否则会降低map等集合的索引速度</p>\n<h3 id=\"18-请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。\"><a href=\"#18-请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。\" class=\"headerlink\" title=\"18. 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。\"></a>18. 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。</h3><p> OO设计理念：封装、继承、多态</p>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>类内部</th>\n<th>本包</th>\n<th>子类</th>\n<th>外部包</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> public</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td> protected</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>×</td>\n</tr>\n<tr>\n<td> default</td>\n<td>√</td>\n<td>√</td>\n<td>×</td>\n<td>×</td>\n</tr>\n<tr>\n<td> private</td>\n<td>√</td>\n<td>×</td>\n<td>×</td>\n<td>×</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"19-深拷贝和浅拷贝区别\"><a href=\"#19-深拷贝和浅拷贝区别\" class=\"headerlink\" title=\"19. 深拷贝和浅拷贝区别\"></a>19. 深拷贝和浅拷贝区别</h3><p> 如果一个对象内部只有基本数据类型，呢么clone()方法获取到的就是这个对象的深拷贝，而如果其内部还有引用数据类型，那么clone()方法</p>\n<p> <strong>浅拷贝</strong> 对基本数据类型进行值拷贝，对引用数据类型进行引用传递般的拷贝，此为浅拷贝</p>\n<p> <strong>深拷贝</strong> 对基本数据类型进行值拷贝，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝</p>\n<ul>\n<li>序列化</li>\n<li>clone方法 对其内部引用类型的变量，在进行一次clone</li>\n</ul>\n<h3 id=\"20-数组和链表数据结构描述，各自的时间复杂度\"><a href=\"#20-数组和链表数据结构描述，各自的时间复杂度\" class=\"headerlink\" title=\"20. 数组和链表数据结构描述，各自的时间复杂度\"></a>20. 数组和链表数据结构描述，各自的时间复杂度</h3><p><strong>数组：</strong> 元素在内存中连续存放，可以通过下标迅速访问数组中任何元素。但是如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。<br><strong>链表：</strong> 元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。比如：上一个元素有个指针指到下一个元素，以此类推，直到最后一个元素。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表数据结构了。</p>\n<p><strong>数组和链表的区别：</strong><br>1、从逻辑结构角度来看：<br>数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费。<br>链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。（数组中插入、删除数据项时，需要移动其它数据项）<br>2、数组元素在栈区，链表元素在堆区；<br>3、从内存存储角度来看：<br>(静态)数组从栈中分配空间, 对于程序员方便快速,但自由度小。<br>链表从堆中分配空间, 自由度大但申请管理比较麻烦。<br>数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；<br>数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。</p>\n<h3 id=\"21-error和exception的区别，CheckedException，RuntimeException的区别\"><a href=\"#21-error和exception的区别，CheckedException，RuntimeException的区别\" class=\"headerlink\" title=\"21. error和exception的区别，CheckedException，RuntimeException的区别\"></a>21. error和exception的区别，CheckedException，RuntimeException的区别</h3><p>Error: 程序无法处理的错误，如OutOfMemory<br>Exception: 程序可以处理的异常</p>\n<p>RuntimeException表示虚拟机运行时可能遇到的错误，只要程序设计的没有问题通常不会发生。如空指针、数组下标越界异常<br>CheckedException与运行的上下文环境有关，即使程序设计无误，仍然可能因为使用问题而发生。<br>编译器不要求声明抛出RuntimeException，要求必须声明抛出CheckedException,</p>\n<h3 id=\"22-请列出5个运行时异常\"><a href=\"#22-请列出5个运行时异常\" class=\"headerlink\" title=\"22. 请列出5个运行时异常\"></a>22. 请列出5个运行时异常</h3><p>ClassCastException、IndexOutOfBoundsException、NullPointerException、ArrayStoreException、BufferOverflowException</p>\n<h3 id=\"23-在自己的代码中，如果创建一个java-lang-String类，这个类是否可以被类加载器加载？为什么\"><a href=\"#23-在自己的代码中，如果创建一个java-lang-String类，这个类是否可以被类加载器加载？为什么\" class=\"headerlink\" title=\"23. 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么\"></a>23. 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么</h3><p>不能。由于双亲委派模型限制，先从父加载器加载，依次为引导类加载器 &gt; 扩展类加载器 &gt; 应用程序类加载器，父加载器找不到，才从子加载器加载，依次类推</p>\n<h3 id=\"24-在jdk1-5中，引入了泛型，泛型的存在是用来解决什么问题-太保面试题\"><a href=\"#24-在jdk1-5中，引入了泛型，泛型的存在是用来解决什么问题-太保面试题\" class=\"headerlink\" title=\"24. 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题(太保面试题)\"></a>24. 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题(太保面试题)</h3><p>泛型主要针对向下转型时带来的安全隐患，其核心组成是在声明类或接口时，不设置参数或属性的类型</p>\n<p>类型擦除: 编译器声明的类型擦除并替换为Object(如果设置了上限如 T extend List)则替换为上限，最后插入强制转换，代码才能正常运行</p>\n<h3 id=\"25-这样的a-hashcode-有什么用，与a-equals-b-有什么关系\"><a href=\"#25-这样的a-hashcode-有什么用，与a-equals-b-有什么关系\" class=\"headerlink\" title=\"25. 这样的a.hashcode() 有什么用，与a.equals(b)有什么关系\"></a>25. 这样的a.hashcode() 有什么用，与a.equals(b)有什么关系</h3><p>hashcode()提供了对象的hashcode值，是一个native函数，返回的默认值与System.identityHashCode(obj)一致<br>作用是用一个数字标识对象，比如HashMap中的key就是基于hashcode, hashcode只能说是标识对象，在hash算法中可以将对象相对离散些，但不是唯一的，根据hashcode定位到具体的链表后，需要循环链表，然后通过equals()方法来对比key是否是一致的。<br>equals相等的两个对象，hashcode一定相等；hashcode相等的两个对象不一定equals相等</p>\n<h3 id=\"26-有没有可能2个不相等的对象有相同的hashcode\"><a href=\"#26-有没有可能2个不相等的对象有相同的hashcode\" class=\"headerlink\" title=\"26. 有没有可能2个不相等的对象有相同的hashcode\"></a>26. 有没有可能2个不相等的对象有相同的hashcode</h3><p>有。同25</p>\n<h3 id=\"27-Java中的HashSet内部是如何工作的\"><a href=\"#27-Java中的HashSet内部是如何工作的\" class=\"headerlink\" title=\"27. Java中的HashSet内部是如何工作的\"></a>27. Java中的HashSet内部是如何工作的</h3><p>HashSet内部采用HashMap实现。实现了Set接口，不允许有重复的值，只允许有一个null key</p>\n<h3 id=\"28-什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决\"><a href=\"#28-什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决\" class=\"headerlink\" title=\"28. 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决\"></a>28. 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决</h3><p><strong>什么是序列化</strong></p>\n<ul>\n<li>序列化 把对象转换为字节序列的过程称为序列化</li>\n<li>反序列化 把字节序列转化为对象的过程称为序列化</li>\n</ul>\n<p><strong>为什么序列化</strong><br>内存对象保存到文件或数据库时需要序列化；<br>用套接字在网络上传输对象的时需要序列化;<br>通过RMI传输对象的时候需要序列化</p>\n<p><strong>怎么序列化</strong><br>对象实现Serializable接口，然后通过ObjectOutputStream.writeObject进行序列化，通过ObjectInputStream.readObject进行反序列化</p>\n<p><strong>问题及解决方式</strong><br>serialVersionUID未定义,导致反序列化报InvalidClassException,这是由于在反序列化时Java会自动为serialVersionUI赋值，导致两边不一致找不到旧数据报错<br>当属性是对象时，也需要实现serializable接口，不然会报NotSerializableException</p>\n<p>ps:<br>transient修饰的属性不参与序列化；静态属性不参与序列化</p>\n<h3 id=\"29-java8的新特性\"><a href=\"#29-java8的新特性\" class=\"headerlink\" title=\"29.  java8的新特性\"></a>29.  java8的新特性</h3><ul>\n<li>接口提供默认方法</li>\n<li>Lambda表达式</li>\n<li>函数式接口</li>\n<li>方法与构造函数引用</li>\n<li>扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream</li>\n<li>在包java.time下包含了一组全新的时间日期API</li>\n</ul>\n","categories":["JAVA"],"tags":["面试","JAVA"]},{"title":"31_下一个排列_leetcode","url":"http://www.shenjian.online/2019/10/22/31-下一个排列-leetcode/","content":"<h2 id=\"31-下一个排列\"><a href=\"#31-下一个排列\" class=\"headerlink\" title=\"31. 下一个排列\"></a>31. 下一个排列</h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。<br>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。<br>必须原地修改，只允许使用额外常数空间。</p>\n<blockquote>\n<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>\n</blockquote>\n<p><strong>题解：</strong> 1. 从右到左，找打第一个非降序的值，为待交换目标</p>\n<ol start=\"2\">\n<li>从右到左，找到第一个大于待交换目标的值，作为交换值</li>\n<li>交换</li>\n<li>在1中位置处后的数据必定降序，故反转，从而得到下一个排列</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">nextPermutation</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 1 3 2 1</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 1. 从右到左，找打第一个非降序的值，为待交换目标</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i = nums.length - <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i &gt;= <span class=\"number\">0</span> &amp;&amp; nums[i + <span class=\"number\">1</span>] &lt;= nums[i]) &#123;</span><br><span class=\"line\">\t\t\ti--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 2.从右到左，找到第一个大于待交换目标的值，作为交换值</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> j = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (j &gt;= <span class=\"number\">0</span> &amp;&amp; nums[j] &lt;= nums[i]) &#123;</span><br><span class=\"line\">\t\t\t\tj--;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 3.交换</span></span><br><span class=\"line\">\t\t\tswap(nums, i, j);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 4.nums[i]后数据必定降序，故反转为正序</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 在1中nums[i]之后为降序，在2中交换值后，也为降序[自己简单逻辑思考下奥]</span></span><br><span class=\"line\">\t\treverse(nums, i + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> start)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i = start, j = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">\t\t\tswap(nums, i, j);</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t\tj--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> temp = nums[i];</span><br><span class=\"line\">\t\tnums[i] = nums[j];</span><br><span class=\"line\">\t\tnums[j] = temp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/next-permutation/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"29_两数相除_leetcode","url":"http://www.shenjian.online/2019/10/16/29-两数相除-leetcode/","content":"<h2 id=\"29-两数相除\"><a href=\"#29-两数相除\" class=\"headerlink\" title=\"29. 两数相除\"></a>29. 两数相除</h2><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。<br>返回被除数 dividend 除以除数 divisor 得到的商。</p>\n<blockquote>\n<p>输入: dividend = 10, divisor = 3<br>输出: 3<br>输入: dividend = 7, divisor = -3<br>输出: -2<br>说明:<br>被除数和除数均为 32 位有符号整数。<br>除数不为 0。<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1</p>\n</blockquote>\n<p><strong>题解</strong>：这题是除法，所以先普及下除法术语商，公式是：(被除数-余数)÷除数=商，记作：被除数÷除数=商…余数，是一种数学术语。在一个除法算式里，被除数、余数、除数和商的关系为：(被除数-余数)÷除数=商，记作：被除数÷除数=商…余数，进而推导得出：商×除数+余数=被除数。要求商，我们首先想到的是减法，能被减多少次，那么商就为多少，</p>\n<p>但是明显减法的效率太低那么我们可以用<strong>位移法</strong>，因为计算机在做位移时效率特别高，向左移1相当于乘以2，向右位移1相当于除以2。我们可以把一个dividend（被除数）先除以2^n，n最初为31，不断减小n去试探,当某个n满足dividend/2^n&gt;=divisor时，表示我们找到了一个足够大的数，这个数乘以divisor是不大于dividend的，所以我们就可以减去2^n个divisor，以此类推</p>\n<p>我们可以以100/3为例2^n是1，2，4，8…2^31这种数，当n为31时，这个数特别大，100/2^n是一个很小的数，肯定是小于3的，所以循环下来，当n=5时，100/32=3, 刚好是大于等于3的，这时我们将100-32*3=4，也就是减去了32个3，接下来我们再处理4，同样手法可以再减去一个3，所以一共是减去了33个3，所以商就是33</p>\n<p>这其中得处理一些特殊的数，比如divisor是不能为0的，Integer.MIN_VALUE和Integer.MAX_VALUE</p>\n<p><a href=\"https://github.com/foxleezh/leetcode-java\" target=\"_blank\" rel=\"noopener\">题解来源</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">divide</span><span class=\"params\">(<span class=\"keyword\">int</span> dividend, <span class=\"keyword\">int</span> divisor)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (divisor == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Integer.MAX_VALUE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> negative = (dividend ^ divisor) &lt; <span class=\"number\">0</span>; <span class=\"comment\">// 异或判断符号是否相等</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> dividendAbs = Math.abs((<span class=\"keyword\">long</span>)dividend);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> divisorAbs = Math.abs((<span class=\"keyword\">long</span>)divisor);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">31</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((dividendAbs &gt;&gt; i ) &gt;= divisorAbs) &#123;</span><br><span class=\"line\">                result += <span class=\"number\">1</span> &lt;&lt; i;</span><br><span class=\"line\">                dividendAbs -= divisorAbs &lt;&lt; i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> negative ? -result : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/divide-two-integers/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"MongoDB面试篇","url":"http://www.shenjian.online/2019/10/14/MongoDB面试篇/","content":"<h2 id=\"MongoDB面试篇\"><a href=\"#MongoDB面试篇\" class=\"headerlink\" title=\"MongoDB面试篇\"></a>MongoDB面试篇</h2><h3 id=\"1-什么是MongoDB\"><a href=\"#1-什么是MongoDB\" class=\"headerlink\" title=\"1. 什么是MongoDB\"></a>1. 什么是MongoDB</h3><p>MongoDB是一个文档数据库，提供好的性能，领先的非关系型数据库，采用BSON存储文档数据[引申问题BSON与JSON的区别]</p>\n<h3 id=\"2-MongoDB是由哪种语言写的\"><a href=\"#2-MongoDB是由哪种语言写的\" class=\"headerlink\" title=\"2. MongoDB是由哪种语言写的\"></a>2. MongoDB是由哪种语言写的</h3><p>MongoDB是用C++写的，MySQL也是用C++写的</p>\n<h3 id=\"3-MongoDB的优势有哪些\"><a href=\"#3-MongoDB的优势有哪些\" class=\"headerlink\" title=\"3. MongoDB的优势有哪些\"></a>3. MongoDB的优势有哪些</h3><p>面向文档的存储：文档存储以BSON格式(有大小限制，最大16M), 内置GridFS文件系统(一般存储大于16M的文件)。</p>\n<ul>\n<li>任何属性都可以建立索引</li>\n<li>复制及高扩展性</li>\n<li>自动分片</li>\n<li>丰富的查询功能</li>\n<li>快速的及时更新</li>\n<li>来自MongoDB的专业支持</li>\n</ul>\n<h3 id=\"4-什么是集合\"><a href=\"#4-什么是集合\" class=\"headerlink\" title=\"4. 什么是集合\"></a>4. 什么是集合</h3><p>集合是一组MongoDB文档，类似于关系型数据库中表的概念。一个集合中的多个文档可以有多个不同的字段。一般来说，集合中的文档有着相同或相关的目的</p>\n<h3 id=\"5-什么是文档\"><a href=\"#5-什么是文档\" class=\"headerlink\" title=\"5. 什么是文档\"></a>5. 什么是文档</h3><p>文档是由一组key-value组成。文档是动态模式，意味着集合中的每个文档不需要有相同的字段或结构。非关系型数据库表中的一条记录相当于一个文档</p>\n<h3 id=\"6-什么是mongod-常用参数有什么\"><a href=\"#6-什么是mongod-常用参数有什么\" class=\"headerlink\" title=\"6. 什么是mongod,常用参数有什么\"></a>6. 什么是mongod,常用参数有什么</h3><p>mongod是处理MongoDB的主要进程。它处理数据请求，管理数据存储，执行后台管理操作。当我们运行mongod命令意味着MongoDB正在启动并且在后台运行。</p>\n<p><code>mongod --dbpath /data/db --port 27017 #默认数据库路径与端口</code></p>\n<h3 id=\"7-什么是mongo\"><a href=\"#7-什么是mongo\" class=\"headerlink\" title=\"7. 什么是mongo\"></a>7. 什么是mongo</h3><p>mongo是一个命令行工具用于连接特定的mongod实例。当我们没有指定参数时，则使用默认的端口与localhost进行连接</p>\n<h3 id=\"8-MongoDB常用命令\"><a href=\"#8-MongoDB常用命令\" class=\"headerlink\" title=\"8. MongoDB常用命令\"></a>8. MongoDB常用命令</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># MongoDB用use+数据库名称的方式来切换数据库，无该数据库，则自动创建后切换</span></span><br><span class=\"line\">user database_name</span><br><span class=\"line\"></span><br><span class=\"line\">show dbs <span class=\"comment\"># 查看数据库列表</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.dropDatabase() <span class=\"comment\"># 删除当前数据库</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.createCollection(name, options) <span class=\"comment\"># 创建集合</span></span><br><span class=\"line\"></span><br><span class=\"line\">show collections <span class=\"comment\"># 查看创建的集合</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.collection.drop() <span class=\"comment\"># 删除集合</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.collection.createIndex() <span class=\"comment\"># 创建索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.collection.find() <span class=\"comment\"># 查询集合中的索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.collection.find().pretty() <span class=\"comment\"># 查询集合中的索引并格式化输出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用\"AND\"或\"OR\"条件循环查询集合中的文档</span></span><br><span class=\"line\">db.collection.find(</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"variable\">$or</span>: &#123;</span><br><span class=\"line\">\t\t\t&#123;key1: value1&#125;, &#123;key2: value2&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新数据</span></span><br><span class=\"line\">db.collection.update(</span><br><span class=\"line\">\t&#123;key: value&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"variable\">$set</span>: &#123;newKey: newValue&#125;&#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">db.collection.remove(&#123;key: value&#125;) <span class=\"comment\"># 删除文档</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.collection.find(&#123;key: value&#125;).sort(&#123;columnName: -1&#125;) <span class=\"comment\"># 在MongoDB中排序 1|升序 -1|降序</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.collection.aggregate(aggregate_operation) <span class=\"comment\"># 聚合</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"9-什么是非关系型数据库\"><a href=\"#9-什么是非关系型数据库\" class=\"headerlink\" title=\"9. 什么是非关系型数据库\"></a>9. 什么是非关系型数据库</h3><p>非关系型数据库是相对于传统关系型数据库的统称，显著特点是不使用SQL作为查询语言，数据存储不需要特定的表格存储。由于其简单的设计与非常好的性能被广泛应用于大数据与Web Apps等</p>\n<h3 id=\"10-非关系型数据库有哪些类型\"><a href=\"#10-非关系型数据库有哪些类型\" class=\"headerlink\" title=\"10. 非关系型数据库有哪些类型\"></a>10. 非关系型数据库有哪些类型</h3><ul>\n<li>Key-Value存储 eg: Redis</li>\n<li>图表 eg: Neo4J</li>\n<li>文档存储： MongoDB ElasticSearch</li>\n<li>基于列储存： Cassandra</li>\n</ul>\n<h3 id=\"11-为什么用MongoDB\"><a href=\"#11-为什么用MongoDB\" class=\"headerlink\" title=\"11. 为什么用MongoDB\"></a>11. 为什么用MongoDB</h3><ul>\n<li>架构简单</li>\n<li>没有复杂的连接查询</li>\n<li>深度查询能力，支持动态查询</li>\n<li>容易调试、扩展</li>\n<li>不需要转化/映射应用对象到数据库对象</li>\n<li>使用内部内存作为存储工作区，更快的存取数据</li>\n</ul>\n<h3 id=\"12-在哪些场景使用MongoDB\"><a href=\"#12-在哪些场景使用MongoDB\" class=\"headerlink\" title=\"12. 在哪些场景使用MongoDB\"></a>12. 在哪些场景使用MongoDB</h3><ul>\n<li>大数据</li>\n<li>内存管理系统</li>\n<li>移动Apps</li>\n<li>数据管理</li>\n</ul>\n<h3 id=\"13-MongoDB的命名空间是什么意思\"><a href=\"#13-MongoDB的命名空间是什么意思\" class=\"headerlink\" title=\"13. MongoDB的命名空间是什么意思\"></a>13. MongoDB的命名空间是什么意思</h3><p>MongoDB存储BSON对象在丛集(collection)中,数据库名字与丛集以点号连接起来叫命名空间(namespace)<br>一个集合命名空间包含多个数据域(extend),集合命名空间存储着集合的元数据，如集合名称、第一个数据域的位置与最后一个数据域的位置。<br>而一个数据域由若干条文档(document)组成，每个数据域都有一个头部，记录这第一个文档和最后一个文档的位置，以及该数据库的一些元数据。<br>extend之间、document之间以双向链表连接<br>索引的数据结构是B树，索引命名空间存储B树根节点的指针</p>\n<h3 id=\"14-MongoDB中的分片是什么意思\"><a href=\"#14-MongoDB中的分片是什么意思\" class=\"headerlink\" title=\"14. MongoDB中的分片是什么意思\"></a>14. MongoDB中的分片是什么意思</h3><p>分片将数据水平切分到不同的物理节点。当应用数据越来越大时，数据量也会越来越大。当数据量增长时，单台机器有可能无法存储数据或者可接受的读写吞吐量。利用分片技术，可以添加更多的机器来应对数据量增加与读写操作的要求</p>\n<h3 id=\"15-如何查看使用MongoDB中的连接\"><a href=\"#15-如何查看使用MongoDB中的连接\" class=\"headerlink\" title=\"15. 如何查看使用MongoDB中的连接\"></a>15. 如何查看使用MongoDB中的连接</h3><p><code>db.adminCommand({&quot;connPoolStats&quot;: 1})</code></p>\n<h3 id=\"16-什么是复制\"><a href=\"#16-什么是复制\" class=\"headerlink\" title=\"16. 什么是复制\"></a>16. 什么是复制</h3><p>MongoDB复制是将数据同步到多个服务器的过程</p>\n<ul>\n<li>保障数据的安全性</li>\n<li>数据高可用</li>\n<li>数据灾难恢复</li>\n<li>无需停机维护(如备份、重建索引、压缩)</li>\n<li>分布式读取数据</li>\n</ul>\n<h3 id=\"17-为什么要在MongoDB中使用分析器\"><a href=\"#17-为什么要在MongoDB中使用分析器\" class=\"headerlink\" title=\"17. 为什么要在MongoDB中使用分析器\"></a>17. 为什么要在MongoDB中使用分析器</h3><p>分析器用于显示每个操作性能特点，通过分析器可以找到比预期慢的查询或写操作，利用这一信息，比如可以确定是否需要添加索引</p>\n<h3 id=\"18-MongoDB支持主键外键关系吗\"><a href=\"#18-MongoDB支持主键外键关系吗\" class=\"headerlink\" title=\"18. MongoDB支持主键外键关系吗\"></a>18. MongoDB支持主键外键关系吗</h3><p>默认MongoDB不支持主键外键关系。用MongoDB本身的API硬编码才能实现外键关联，不够直观且难度较大</p>\n<h3 id=\"19-MongoDB支持哪些数据类型\"><a href=\"#19-MongoDB支持哪些数据类型\" class=\"headerlink\" title=\"19. MongoDB支持哪些数据类型\"></a>19. MongoDB支持哪些数据类型</h3><ul>\n<li>String </li>\n<li>Integer </li>\n<li>Double </li>\n<li>Boolean</li>\n<li>Object</li>\n<li>Object ID </li>\n<li>Arrays </li>\n<li>Min/Max Keys</li>\n<li>Datetime</li>\n<li>Code</li>\n<li>Regular Expression等</li>\n</ul>\n<h3 id=\"20-为什么在MongoDB中使用Code数据类型\"><a href=\"#20-为什么在MongoDB中使用Code数据类型\" class=\"headerlink\" title=\"20. 为什么在MongoDB中使用Code数据类型\"></a>20. 为什么在MongoDB中使用Code数据类型</h3><p>“Code”类型用于在文档中存储Javascript代码</p>\n<h3 id=\"21-为什么要在MongoDB中用”Regular-Expression”数据类型\"><a href=\"#21-为什么要在MongoDB中用”Regular-Expression”数据类型\" class=\"headerlink\" title=\"21. 为什么要在MongoDB中用”Regular Expression”数据类型\"></a>21. 为什么要在MongoDB中用”Regular Expression”数据类型</h3><p>“Regular Expression”类型用于在文档中存储正则表达式</p>\n<h3 id=\"22-为什么在MongoDB中使用”Object-ID”数据类型\"><a href=\"#22-为什么在MongoDB中使用”Object-ID”数据类型\" class=\"headerlink\" title=\"22. 为什么在MongoDB中使用”Object ID”数据类型\"></a>22. 为什么在MongoDB中使用”Object ID”数据类型</h3><p>“Object ID”类型用于存储文档id</p>\n<h3 id=\"23-“Object-ID”有哪些部分组成\"><a href=\"#23-“Object-ID”有哪些部分组成\" class=\"headerlink\" title=\"23. “Object ID”有哪些部分组成\"></a>23. “Object ID”有哪些部分组成</h3><p>一共有四部分组成：时间戳、客户端ID、客户进程ID、三个字节的增量计数器</p>\n<h3 id=\"24-MongoDB中什么是索引\"><a href=\"#24-MongoDB中什么是索引\" class=\"headerlink\" title=\"24. MongoDB中什么是索引\"></a>24. MongoDB中什么是索引</h3><p>索引用于高效的执行查询，没有索引的MongoDB将扫描集合的所有文档，这种扫描效率很低，需要处理大量的数据。<br>索引的数据结构是B树，能够存储某种特殊字段或字段集的值，并按照索引指定的方式将字段值排序</p>\n<h3 id=\"25-在MongoDB中什么是副本集\"><a href=\"#25-在MongoDB中什么是副本集\" class=\"headerlink\" title=\"25. 在MongoDB中什么是副本集\"></a>25. 在MongoDB中什么是副本集</h3><p>副本集由一组MongoDB实例组成，包括一个主节点多个从节点，客户端所有数据都写入主节点，从节点从主节点同步写入数据，避免单点故障，数据高可用</p>\n","categories":["MongoDB"],"tags":["面试","MongoDB"]},{"title":"28_实现strStr_leetcode","url":"http://www.shenjian.online/2019/10/13/28-实现strStr()-leetcode/","content":"<h2 id=\"28-实现strStr\"><a href=\"#28-实现strStr\" class=\"headerlink\" title=\"28. 实现strStr()\"></a>28. 实现strStr()</h2><p>实现 strStr() 函数。<br>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>\n<blockquote>\n<p>输入: haystack = “hello”, needle = “ll”<br>输出: 2<br>输入: haystack = “aaaaa”, needle = “bba”<br>输出: -1</p>\n</blockquote>\n<p>题解： <strong>Sunday算法</strong> </p>\n<ul>\n<li>设originIndex为待查找串index,aimIndex为目标串index.</li>\n<li>从左向右依次匹配</li>\n<li>若匹配则index均加1继续匹配，直到目标串全部匹配完，则找到</li>\n<li>若不匹配则查看(originIndex - aimIndex + 目标串长度 )的字符是否在目标串中存在</li>\n<li>特别注意[originIndex - aimIndex 的意义为当前匹配中第一次开始匹配的index, 理解这一点非常重要 !!!!]</li>\n<li>若不存在，则originIndex设置为距离当前查看字符的下一次字符，aimIndex设置为0，继续循环匹配</li>\n<li>若存在，则在当前查看字符处按其在aim中最后一次出现的位置处对其，aimIndex设置为0，继续循环匹配</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(String origin, String aim)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (origin == <span class=\"keyword\">null</span> || aim == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (origin.length() &lt; aim.length()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> originIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> aimIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 成功匹配完终止条件：所有aim均成功匹配</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (aimIndex &lt; aim.length()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 针对origin匹配完，但aim未匹配完情况处理 如 mississippi sippia    </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (originIndex &gt; origin.length() - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (origin.charAt(originIndex) == aim.charAt(aimIndex)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 匹配则index均加1</span></span><br><span class=\"line\">                originIndex++;</span><br><span class=\"line\">                aimIndex++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取当前不匹配的下一个距离源index即(originIndex - aimIndex)长度为aim.length()的字符</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> nextCharIndex = originIndex - aimIndex + aim.length();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nextCharIndex &lt; origin.length()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 判断是否该字符在aim中存在，若存在，返回最后一个匹配的index</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> loc = aim.lastIndexOf(origin.charAt(nextCharIndex));  </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loc == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 该字符不存在于aim中则设置originIndex为该字符的下一个字符</span></span><br><span class=\"line\">                        originIndex = nextCharIndex + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 该字符存在于aim中则设置originIndex使其在aim中该字符处对齐 </span></span><br><span class=\"line\">                        originIndex = nextCharIndex - loc;</span><br><span class=\"line\">                    &#125;               </span><br><span class=\"line\">                    aimIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> originIndex - aimIndex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/implement-strstr/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"27_移除元素_leetcode","url":"http://www.shenjian.online/2019/10/13/27-移除元素-leetcode/","content":"<h2 id=\"27-移除元素\"><a href=\"#27-移除元素\" class=\"headerlink\" title=\"27. 移除元素\"></a>27. 移除元素</h2><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>\n<blockquote>\n<p>给定 nums = [3,2,2,3], val = 3,<br>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,<br>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>注意这五个元素可为任意顺序。<br>你不需要考虑数组中超出新长度后面的元素。</p>\n<p>题解： 简单题，给AC加点心</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">if</span> (nums[i] != val) &#123;</span><br><span class=\"line\">        \t\tnums[length++] = nums[i];</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> length;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/remove-element/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"二分查找","url":"http://www.shenjian.online/2019/10/13/二分查找/","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 二分查找</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 要在有序的数组里查找元素x,先取中间元素与x比较，</span></span><br><span class=\"line\"><span class=\"comment\"> * 若小于中间元素，则在左边查找，反之，在右边查找，直到找到x或子数组为0</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Jian Shen</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@version</span> V1.0.0</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2019/10/13</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinarySearch</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(@NotNull  T[] arr, T x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> high = arr.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = (low + high) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[mid].compareTo(x) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (arr[mid].compareTo(x) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>; <span class=\"comment\">// 未查找到</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["算法与数据结构"],"tags":["算法与数据结构"]},{"title":"26_删除排序数组中的重复项_leetcode","url":"http://www.shenjian.online/2019/10/10/26-删除排序数组中的重复项-leetcode/","content":"<h2 id=\"26-删除排序数组中的重复项\"><a href=\"#26-删除排序数组中的重复项\" class=\"headerlink\" title=\"26. 删除排序数组中的重复项\"></a>26. 删除排序数组中的重复项</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>\n<blockquote>\n<p>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<blockquote>\n<p>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<p>题解： 简单题，给AC加点心</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span> || nums.length &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">int</span> length = <span class=\"number\">1</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">if</span> (nums[i] != nums[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">    \t\t\tnums[length] = nums[i];</span><br><span class=\"line\">    \t\t\tlength++;   \t\t\t</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> length;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"24_两两交换链表中的节点_leetcode","url":"http://www.shenjian.online/2019/10/08/24-两两交换链表中的节点-leetcode/","content":"<h2 id=\"24-两两交换链表中的节点\"><a href=\"#24-两两交换链表中的节点\" class=\"headerlink\" title=\"24. 两两交换链表中的节点\"></a>24. 两两交换链表中的节点</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>\n<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>\n<blockquote>\n<p>示例:<br>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p>\n</blockquote>\n<p>题解： 三个主要节点： temp用于遍历，start end用于交换</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">swapPairs</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">    \tListNode prev = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">    \tprev.next = head;</span><br><span class=\"line\">    \tListNode temp = prev;</span><br><span class=\"line\">    \t</span><br><span class=\"line\">    \t<span class=\"keyword\">while</span> (temp.next != <span class=\"keyword\">null</span> &amp;&amp; temp.next.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t\tListNode start = temp.next;</span><br><span class=\"line\">    \t\tListNode end = temp.next.next;</span><br><span class=\"line\">    \t\ttemp.next = end;</span><br><span class=\"line\">    \t\tstart.next = end.next;</span><br><span class=\"line\">    \t\tend.next = start;</span><br><span class=\"line\">    \t\ttemp = start;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> prev.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/swap-nodes-in-pairs/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"Redis面试篇","url":"http://www.shenjian.online/2019/10/08/Redis面试篇/","content":"<h2 id=\"Redis常见问题总结\"><a href=\"#Redis常见问题总结\" class=\"headerlink\" title=\"Redis常见问题总结\"></a>Redis常见问题总结</h2><h3 id=\"1-使用redis有哪些好处？\"><a href=\"#1-使用redis有哪些好处？\" class=\"headerlink\" title=\"1. 使用redis有哪些好处？\"></a>1. 使用redis有哪些好处？</h3><ul>\n<li>速度快 基于内存，查找操作时间复杂度O(1)</li>\n<li>支持多种数据类型存储 string/list/set/sorted set/hash</li>\n<li>支持事务 操作都是原子性，要么全部执行，要么全部不执行</li>\n<li>可用于缓存、消息、按key设置过期时间，过期自动删除 </li>\n</ul>\n<h3 id=\"2-Redis与memcached有哪些优势？\"><a href=\"#2-Redis与memcached有哪些优势？\" class=\"headerlink\" title=\"2. Redis与memcached有哪些优势？\"></a>2. Redis与memcached有哪些优势？</h3><ul>\n<li>memcached值仅为string,redis支持多种数据类型</li>\n<li>redis速度比memcached快很多</li>\n<li>redis可持久化其数据</li>\n</ul>\n<h3 id=\"3-Redis常见性能问题与解决方案？\"><a href=\"#3-Redis常见性能问题与解决方案？\" class=\"headerlink\" title=\"3. Redis常见性能问题与解决方案？\"></a>3. Redis常见性能问题与解决方案？</h3><ul>\n<li>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志记录<br>[可选回答]Master写内存快照，save命令调度rdbSave函数,会阻塞主线程工作，当快照比较大时，会间断性暂停服务; Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度，Master调用BGREWRITEAOF重写AOF文件，会占大量的CPU与内存资源，导致服务load过高，出现短暂服务暂停现象</li>\n<li>如果数据比较重要，某个Slave设置AOF备份数据,策略设置每秒同步一次</li>\n<li>为了主从复制的速度与连接的稳定性，Master与Slave最好在同一个局域网内</li>\n<li>尽量避免在压力很大的主库上增加从库</li>\n<li>主从复制不要用图状结构，用单向链表结构更为稳定。如Master &lt;- Slave1 &lt;- Slave2</li>\n</ul>\n<h3 id=\"4-MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？\"><a href=\"#4-MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？\" class=\"headerlink\" title=\"4. MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？\"></a>4. MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</h3><p>redis内存数据集上升到一定大小的时候，就会执行数据淘汰策略。redis有6种数据淘汰策略</p>\n<ul>\n<li>volatile-lru 从已设置过期时间的数据集挑选最近最少使用的数据淘汰</li>\n<li>volatile-ttl 从已设置过期时间的数据集挑选即将过期的数据淘汰</li>\n<li>volatile-random 从已设置过期的数据集任意选择数据淘汰</li>\n<li>allkeys-lru 从数据集挑选最近最少使用的数据淘汰</li>\n<li>allkeys-random 从数据集任意选择数据淘汰</li>\n<li>no-enviction 禁止驱逐数据</li>\n</ul>\n<h3 id=\"5-Zookeeper四种类型的znode？\"><a href=\"#5-Zookeeper四种类型的znode？\" class=\"headerlink\" title=\"5. Zookeeper四种类型的znode？\"></a>5. Zookeeper四种类型的znode？</h3><ul>\n<li>PERSISTENT:客户端与zookeeper断开连接后，节点不会删除</li>\n<li>PERSISTENT_SEQUENTIAL: 客户端与zookeeper断开连接后，节点不会删除且进行顺序编号</li>\n<li>EPHEMERAL: 客户端与zookeeper断开连接后，节点删除</li>\n<li>EPHEMERAL_SEQUENTIAL: 客户端与zookeeper断开连接后，节点删除且顺序编号</li>\n</ul>\n<h3 id=\"6-Redis与Memcache的区别都有哪些？\"><a href=\"#6-Redis与Memcache的区别都有哪些？\" class=\"headerlink\" title=\"6. Redis与Memcache的区别都有哪些？\"></a>6. Redis与Memcache的区别都有哪些？</h3><ul>\n<li>存储方式 memcache数据全部存在于内存中，断电丢失;redis支持数据持久化</li>\n<li>数据支持类型 memcache数据类型简单；redis支持五种数据类型</li>\n<li>使用底层模型不同 redis直接使用自己的构建的VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动与请求</li>\n<li>value大小<br>redis最大可达到1GB,而memcache只有1MB</li>\n</ul>\n<h3 id=\"7-Redis最适合的场景？\"><a href=\"#7-Redis最适合的场景？\" class=\"headerlink\" title=\"7. Redis最适合的场景？\"></a>7. Redis最适合的场景？</h3><p>redis最适合所有数据in-memory的场景，虽然也提供了持久化功能，但更多的是disk-back的功能<br>实际项目使用场景： 存储JWT,用户授权验证；定时模块分布式执行控制(在多台设备中仅执行一次)</p>\n<h3 id=\"8-Redis的同步机制了解吗？\"><a href=\"#8-Redis的同步机制了解吗？\" class=\"headerlink\" title=\"8. Redis的同步机制了解吗？\"></a>8. Redis的同步机制了解吗？</h3><p>主从同步。第一次同步时，主节点做一次bgsave,并同时将后续修改操作记录至内存buffer,待完成后将rdb文件全量同步到复制节点，复制节点接收完成后将rdb镜像加载到内存，加载完成后，在通知主节点将期间修改的操作记录过来进行重放就完成了同步过程</p>\n<h3 id=\"9-是否使用过Redis集群，集群的原理是什么？\"><a href=\"#9-是否使用过Redis集群，集群的原理是什么？\" class=\"headerlink\" title=\"9. 是否使用过Redis集群，集群的原理是什么？\"></a>9. 是否使用过Redis集群，集群的原理是什么？</h3><p>Redis Sentinel着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。<br>Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p>\n<p>参考来源：<br><a href=\"https://github.com/0voice/interview_internal_reference/blob/master/10.Redis%E7%AF%87\" target=\"_blank\" rel=\"noopener\">interview_internal_reference/10.Redis篇</a></p>\n","categories":["Redis"],"tags":["面试","Redis"]},{"title":"22_括号生成_leetcode","url":"http://www.shenjian.online/2019/10/07/22-括号生成-leetcode/","content":"<h2 id=\"22-括号生成\"><a href=\"#22-括号生成\" class=\"headerlink\" title=\"22. 括号生成\"></a>22. 括号生成</h2><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>\n<blockquote>\n<p>例如，给出 n = 3，生成结果为：<br>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p>\n</blockquote>\n<p>题解： 动态规划： dp(n) = dp(n - 1) + 第n个括号所在的位置<br>考虑在dp(n)的结果中,最左边一定为左括号,假定该括号对为第n个括号，则以上公式可考虑为<br>dp(n) = 第n个括号(该左括号位于最左边) + dp(n-1)相对第n个括号的位置(一定在第n个括号的里面或者右边)<br>公式表示为：dp(n) = “(“ + dp(p) + “)” + dp(q) 其中 p + q = n - 1, 0 &lt; p &lt; n<br>参考： <a href=\"https://leetcode-cn.com/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">generateParenthesis</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LinkedList&lt;&gt;(Arrays.asList(<span class=\"string\">\"()\"</span>));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tList&lt;List&lt;String&gt;&gt; dp = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">\t\tdp.add(Arrays.asList(<span class=\"string\">\"\"</span>));</span><br><span class=\"line\">\t\tdp.add(<span class=\"keyword\">new</span> LinkedList&lt;&gt;(Arrays.asList(<span class=\"string\">\"()\"</span>)));</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">\t\t\tList&lt;String&gt; dpI = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (String p : dp.get(j)) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> (String q : dp.get(i - <span class=\"number\">1</span> - j)) &#123;\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t\tdpI.add(<span class=\"string\">\"(\"</span> + p + <span class=\"string\">\")\"</span> + q);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;\t\t\t\t</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tdp.add(dpI);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> dp.get(n);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/generate-parentheses/submissions/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"21_合并两个有序链表_leetcode","url":"http://www.shenjian.online/2019/09/25/21-合并两个有序链表-leetcode/","content":"<h2 id=\"21-合并两个有序链表\"><a href=\"#21-合并两个有序链表\" class=\"headerlink\" title=\"21. 合并两个有序链表\"></a>21. 合并两个有序链表</h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>\n<blockquote>\n<p>示例：<br>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>\n</blockquote>\n<p>题解： 送分题奥，请看代码吧</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123; </span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (l1 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (l2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">    \t</span><br><span class=\"line\">    \tListNode pre = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">    \tListNode temp = pre;</span><br><span class=\"line\">    \t<span class=\"keyword\">while</span> (l1 != <span class=\"keyword\">null</span> &amp;&amp; l2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class=\"line\">    \t\t\ttemp.next = l1;</span><br><span class=\"line\">    \t\t\tl1 = l1.next;</span><br><span class=\"line\">    \t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    \t\t\ttemp.next = l2;</span><br><span class=\"line\">    \t\t\tl2 = l2.next;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t\ttemp = temp.next;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t</span><br><span class=\"line\">    \ttemp.next = l1 != <span class=\"keyword\">null</span> ? l1 : l2;    \t</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> pre.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"20_有效的括号_leetcode","url":"http://www.shenjian.online/2019/09/24/20-有效的括号-leetcode/","content":"<h2 id=\"20-有效的括号\"><a href=\"#20-有效的括号\" class=\"headerlink\" title=\"20. 有效的括号\"></a>20. 有效的括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>\n<p>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>\n<blockquote>\n<p>输入: “()[]{}”<br>输出: true<br>输入: “(]”<br>输出: false<br>输入: “([)]”<br>输出: false<br>输入: “{[]}”<br>输出: true</p>\n</blockquote>\n<p>题解： 利用栈的先入后出特性,遍历至左括号则入栈，右括号则取栈顶元素(此时栈为空则直接false)看是否为对应左括号,<br>若为是，则继续遍历，若为否，则false</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValid</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.length() &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Stack&lt;Character&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : s.toCharArray()) &#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">if</span> (c == <span class=\"string\">'('</span> || c == <span class=\"string\">'['</span> || c== <span class=\"string\">'&#123;'</span>) &#123;</span><br><span class=\"line\">        \t\tstack.push(c);</span><br><span class=\"line\">        \t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">')'</span> || c == <span class=\"string\">']'</span> || c== <span class=\"string\">'&#125;'</span>) &#123;</span><br><span class=\"line\">        \t\t<span class=\"keyword\">if</span> (stack.isEmpty()) &#123;     \t\t</span><br><span class=\"line\">        \t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        \t\t&#125;</span><br><span class=\"line\">        \t\t<span class=\"keyword\">if</span> (c == <span class=\"string\">')'</span> &amp;&amp; stack.peek() != <span class=\"string\">'('</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\t&#125;\t</span><br><span class=\"line\">        \t\t<span class=\"keyword\">if</span> (c == <span class=\"string\">']'</span> &amp;&amp; stack.peek() != <span class=\"string\">'['</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\t&#125;\t</span><br><span class=\"line\">        \t\t<span class=\"keyword\">if</span> (c == <span class=\"string\">'&#125;'</span> &amp;&amp; stack.peek() != <span class=\"string\">'&#123;'</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">        \t\tstack.pop();</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> stack.isEmpty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/valid-parentheses/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"19_删除链表的倒数第N个节点_leetcode","url":"http://www.shenjian.online/2019/09/23/19-删除链表的倒数第N个节点-leetcode/","content":"<h2 id=\"19-删除链表的倒数第N个节点\"><a href=\"#19-删除链表的倒数第N个节点\" class=\"headerlink\" title=\"19. 删除链表的倒数第N个节点\"></a>19. 删除链表的倒数第N个节点</h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>\n<blockquote>\n<p>示例：<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p>\n</blockquote>\n<p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>说明：<br>给定的 n 保证是有效的。</p>\n<p>题解： 双指针节点一次遍历法<br>第1个指针向前走n步，然后1与2一起向前走，直到1到达尾节点<br>这保证了1与2指针间据为n,此时指针2的下一个节点为待删除节点，删除即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">      ListNode pre = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">       pre.next = head;</span><br><span class=\"line\">       ListNode first = pre;</span><br><span class=\"line\">       ListNode second = pre;</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 第1个指针向前走n步</span></span><br><span class=\"line\">    \t   first = first.next;</span><br><span class=\"line\">    \t   n--;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"keyword\">while</span> (first.next != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 1与2一起向前走，直到1到达尾节点</span></span><br><span class=\"line\">    \t   first = first.next;</span><br><span class=\"line\">    \t   second = second.next;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       second.next = second.next.next; <span class=\"comment\">// 删除节点</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> pre.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"18_四数之和_leetcode","url":"http://www.shenjian.online/2019/09/21/18-四数之和-leetcode/","content":"<h2 id=\"18-四数之和\"><a href=\"#18-四数之和\" class=\"headerlink\" title=\"18. 四数之和\"></a>18. 四数之和</h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>\n<p>注意：<br>答案中不可以包含重复的四元组。</p>\n<blockquote>\n<p>示例：<br>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。<br>满足要求的四元组集合为：<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p>\n</blockquote>\n<p>题解： 指针 + 双指针法 (四数之和转换为三数之和求解)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">    \tList&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span> || nums.length &lt; <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t</span><br><span class=\"line\">    \tArrays.sort(nums);</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123; </span><br><span class=\"line\">    \t\t<span class=\"keyword\">if</span> (isDuplicate(i, <span class=\"number\">0</span>, nums)) &#123; <span class=\"comment\">// 去重  </span></span><br><span class=\"line\">    \t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t\t<span class=\"comment\">// 以下转换为3数求和</span></span><br><span class=\"line\">    \t\tthreeSum(nums, i, target - nums[i], result);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">threeSum</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> target, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = index + <span class=\"number\">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">if</span> (isDuplicate(j, index + <span class=\"number\">1</span>, nums)) &#123; <span class=\"comment\">// 去重 </span></span><br><span class=\"line\">    \t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> value = nums[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> left = j + <span class=\"number\">1</span>; <span class=\"comment\">// 左指针</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> right = nums.length - <span class=\"number\">1</span>; <span class=\"comment\">// 右指针</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> sum = value + nums[left] + nums[right];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (sum == target) &#123;</span><br><span class=\"line\">\t\t\t\t\tresult.add(Arrays.asList(nums[index], nums[j], nums[left], nums[right]));</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 去重，如 -7 3 4 4 4  ,结果仅为 -7,3,4</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tleft++;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tright--;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tleft++;</span><br><span class=\"line\">\t\t\t\t\tright--;</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum &gt; target) &#123;</span><br><span class=\"line\">\t\t\t\t\tright--;</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tleft++;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isDuplicate</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Index must greater than zero\"</span>);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (i &gt; index &amp;&amp; nums[i] == nums[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/4sum/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"17_电话号码的字母组合_leetcode","url":"http://www.shenjian.online/2019/09/18/17-电话号码的字母组合-leetcode/","content":"<h2 id=\"17-电话号码的字母组合\"><a href=\"#17-电话号码的字母组合\" class=\"headerlink\" title=\"17. 电话号码的字母组合\"></a>17. 电话号码的字母组合</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>\n<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>\n<p><img src=\"/2019/09/18/17-电话号码的字母组合-leetcode/17_telephone_keypad.png\" alt=\"电话号码的字母组合\"></p>\n<blockquote>\n<p>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>\n</blockquote>\n<p>题解： 利用队列先进先出特性求解，类似二叉树的层次遍历求解方式,建议断点调试理解求解过程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">letterCombinations</span><span class=\"params\">(String digits)</span> </span>&#123;</span><br><span class=\"line\">\t\tLinkedList&lt;String&gt; result = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (digits == <span class=\"keyword\">null</span> || digits.isEmpty()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 数字为下标,值为数字可对应的字母</span></span><br><span class=\"line\">\t\tString[] mapping = &#123;<span class=\"string\">\"0\"</span>, <span class=\"string\">\"1\"</span>, <span class=\"string\">\"abc\"</span>, <span class=\"string\">\"def\"</span>, <span class=\"string\">\"ghi\"</span>, <span class=\"string\">\"jkl\"</span>, <span class=\"string\">\"mno\"</span>, <span class=\"string\">\"pqrs\"</span>, <span class=\"string\">\"tuv\"</span>, <span class=\"string\">\"wxyz\"</span>&#125;;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tresult.add(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; digits.length(); i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> digit = Character.getNumericValue(digits.charAt(i));</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 控制出入队列内容, 长度为i+1的数字组合依赖于长度为i的组合 + 该数字可对应的字母</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (result.peek().length() == i) &#123;</span><br><span class=\"line\">\t\t\t\tString prevValue = result.remove(); <span class=\"comment\">// 长度为i的组合出队列</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : mapping[digit].toCharArray()) &#123; <span class=\"comment\">// 该数字可对应的字母</span></span><br><span class=\"line\">\t\t\t\t\tresult.add(prevValue + c); <span class=\"comment\">// 长度为i+1的数字组合入队列</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"16_最接近的三数之和_leetcode","url":"http://www.shenjian.online/2019/09/16/16-最接近的三数之和-leetcode/","content":"<h2 id=\"16-最接近的三数之和\"><a href=\"#16-最接近的三数之和\" class=\"headerlink\" title=\"16. 最接近的三数之和\"></a>16. 最接近的三数之和</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>\n<blockquote>\n<p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.<br>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p>\n</blockquote>\n<p>题解： 排序+双指针(leetcode15三数之和也是用该思想奥)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">threeSumClosest</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span> || nums.length &lt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         Arrays.sort(nums);</span><br><span class=\"line\">         <span class=\"keyword\">int</span> result = nums[<span class=\"number\">0</span>] + nums[<span class=\"number\">1</span>] + nums[<span class=\"number\">2</span>];</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">int</span> value = nums[i];</span><br><span class=\"line\">             <span class=\"keyword\">int</span> left = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">             <span class=\"keyword\">int</span> right = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">             <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">int</span> threeSum = value + nums[left]+ nums[right];</span><br><span class=\"line\">                 <span class=\"comment\">// 更新</span></span><br><span class=\"line\">                 <span class=\"keyword\">if</span> (Math.abs(threeSum - target) &lt; Math.abs(result - target)) &#123;</span><br><span class=\"line\">                     result = threeSum;</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">                 <span class=\"comment\">// 指针移动向目标值靠拢，大则right--，小则left++</span></span><br><span class=\"line\">                 <span class=\"keyword\">if</span> (threeSum &gt; target) &#123;</span><br><span class=\"line\">                     right--;</span><br><span class=\"line\">                 &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (threeSum &lt; target) &#123;</span><br><span class=\"line\">                     left++;</span><br><span class=\"line\">                 &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                     <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/3sum-closest/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"15_三数之和_leetcode","url":"http://www.shenjian.online/2019/09/13/15-三数之和-leetcode/","content":"<h2 id=\"15-三数之和\"><a href=\"#15-三数之和\" class=\"headerlink\" title=\"15. 三数之和\"></a>15. 三数之和</h2><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>\n<p>注意：答案中不可以包含重复的三元组。</p>\n<blockquote>\n<p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>\n</blockquote>\n<p>题解： 排序+双指针(截至目前，leetcode11盛最多水的容器也采用双针法)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">\t\tList&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span> || nums.length &lt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tArrays.sort(nums);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (nums[i] &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 有序的数组中第一个数大于0,则不存在三数之和等于0，结束循环</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 去重，如-7 -7 3 4 4 4</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> current = nums[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> left = i + <span class=\"number\">1</span>; <span class=\"comment\">// 左指针</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> right = nums.length - <span class=\"number\">1</span>; <span class=\"comment\">// 右指针</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> sum = current + nums[left] + nums[right];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (sum == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tresult.add(Arrays.asList(current, nums[left], nums[right]));</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 去重，如 -7 3 4 4 4  ,结果仅为 -7,3,4</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tleft++;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tright--;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tleft++;</span><br><span class=\"line\">\t\t\t\t\tright--;</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 和过大则右指针较小(右指针处值较大)，反之，增大左指针</span></span><br><span class=\"line\">\t\t\t\t\tright--;</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tleft++;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/3sum/submissions/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"14_最长公共前缀_leetcode","url":"http://www.shenjian.online/2019/09/08/14-最长公共前缀-leetcode/","content":"<h2 id=\"14-最长公共前缀\"><a href=\"#14-最长公共前缀\" class=\"headerlink\" title=\"14. 最长公共前缀\"></a>14. 最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>\n<p>如果不存在公共前缀，返回空字符串 “”。</p>\n<blockquote>\n<p>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”</p>\n</blockquote>\n<blockquote>\n<p>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。<br>说明:所有输入只包含小写字母 a-z 。</p>\n</blockquote>\n<p>题解： 二分查找求解最长公共前缀</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(String[] strs)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (strs == <span class=\"keyword\">null</span> || strs.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> len = Integer.MAX_VALUE;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (String str : strs) &#123;</span><br><span class=\"line\">\t\t\tlen = Math.min(len, str.length());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> high = len;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> middle  = (low + high) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (isCommonPrefix(strs, middle)) &#123;</span><br><span class=\"line\">\t\t\t\tlow = middle + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\thigh = middle - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>].substring(<span class=\"number\">0</span>, (low + high) / <span class=\"number\">2</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isCommonPrefix</span><span class=\"params\">(String[] strs, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">\t\tString str = strs[<span class=\"number\">0</span>].substring(<span class=\"number\">0</span>, len);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!strs[i].startsWith(str)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/longest-common-prefix/submissions/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"13_罗马数字转整数_leetcode","url":"http://www.shenjian.online/2019/09/06/13-罗马数字转整数-leetcode/","content":"<h2 id=\"13-罗马数字转整数\"><a href=\"#13-罗马数字转整数\" class=\"headerlink\" title=\"13. 罗马数字转整数\"></a>13. 罗马数字转整数</h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>\n<blockquote>\n<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</p>\n</blockquote>\n<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>\n<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>\n<blockquote>\n<p>输入: “III”<br>输出: 3<br>输入: “IV”<br>输出: 4<br>输入: “IX”<br>输出: 9<br>输入: “LVIII”<br>输出: 58<br>解释: L = 50, V= 5, III = 3.<br>输入: “MCMXCIV”<br>输出: 1994<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>\n</blockquote>\n<p>题解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">romanToInt</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> value = getValue(s.charAt(i));</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 通常情况下，罗马数字中小的数字在大的数字的右边。</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 对于特例，例如 4 不写做 IIII，而是 IV，只需 -1 + 5即可</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i == s.length() - <span class=\"number\">1</span> || value &gt;= getValue(s.charAt(i + <span class=\"number\">1</span>))) &#123;</span><br><span class=\"line\">\t\t\t\tresult += value;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tresult -= value;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span>(c) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">'I'</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">'V'</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">'X'</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">'L'</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">50</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">'C'</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">'D'</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">500</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">'M'</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">1000</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/roman-to-integer/submissions/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"12_整数转罗马数字_leetcode","url":"http://www.shenjian.online/2019/09/05/12-整数转罗马数字-leetcode/","content":"<h2 id=\"12-整数转罗马数字\"><a href=\"#12-整数转罗马数字\" class=\"headerlink\" title=\"12. 整数转罗马数字\"></a>12. 整数转罗马数字</h2><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M</p>\n<blockquote>\n<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</p>\n</blockquote>\n<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>\n<ul>\n<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>\n<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li>\n<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>\n</ul>\n<p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>\n<blockquote>\n<p>示例 1:<br>输入: 3<br>输出: “III”<br>示例 2:<br>输入: 4<br>输出: “IV”<br>示例 3:<br>输入: 9<br>输出: “IX”<br>示例 4:<br>输入: 58<br>输出: “LVIII”<br>解释: L = 50, V = 5, III = 3.<br>示例 5:<br>输入: 1994<br>输出: “MCMXCIV”<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">intToRoman</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1000</span>, <span class=\"number\">900</span>, <span class=\"number\">500</span>, <span class=\"number\">400</span>, <span class=\"number\">100</span>, <span class=\"number\">90</span>, <span class=\"number\">50</span>, <span class=\"number\">40</span>, <span class=\"number\">10</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">        String[] b = &#123;<span class=\"string\">\"M\"</span>, <span class=\"string\">\"CM\"</span>, <span class=\"string\">\"D\"</span>, <span class=\"string\">\"CD\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"XC\"</span>, <span class=\"string\">\"L\"</span>, <span class=\"string\">\"XL\"</span>, <span class=\"string\">\"X\"</span>, <span class=\"string\">\"IX\"</span>, <span class=\"string\">\"V\"</span>, <span class=\"string\">\"IV\"</span>, <span class=\"string\">\"I\"</span>&#125;;</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (num &gt; <span class=\"number\">0</span> &amp;&amp; i &lt; b.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (num &gt;= a[i]) &#123;</span><br><span class=\"line\">                num -= a[i];</span><br><span class=\"line\">                sb.append(b[i]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/integer-to-roman/submissions/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"11_盛最多水的容器_leetcode","url":"http://www.shenjian.online/2019/09/03/11-盛最多水的容器-leetcode/","content":"<h2 id=\"11-盛最多水的容器\"><a href=\"#11-盛最多水的容器\" class=\"headerlink\" title=\"11. 盛最多水的容器\"></a>11. 盛最多水的容器</h2><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>\n<p>说明：你不能倾斜容器，且 n 的值至少为 2</p>\n<blockquote>\n<p>示例:<br>输入: [1,8,6,2,5,4,8,3,7]<br>输出: 49</p>\n</blockquote>\n<p>题解： 双指针法。宽度一定时，木桶容量受限于最左最右高度，故取0与height.length-1为最左最右开始(保证了宽度初始化最大)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"keyword\">int</span>[] height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = height.length - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> capacity = (right - left) * Math.min(height[left], height[right]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (capacity &gt; max) &#123;</span><br><span class=\"line\">                max = capacity;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 移动短的一端，虽然宽度减小，但可能新的高度使得容量最大</span></span><br><span class=\"line\">            <span class=\"comment\">// 若移动长的一端，木桶容量仍然受限于最短端，且宽度减小，故容量不可能出现更大者</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/container-with-most-water/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"9_回文数_leetcode","url":"http://www.shenjian.online/2019/09/01/9-回文数-leetcode/","content":"<h2 id=\"9-回文数\"><a href=\"#9-回文数\" class=\"headerlink\" title=\"9. 回文数\"></a>9. 回文数</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>\n<blockquote>\n<p>输入: 121<br>输出: true<br>输入: -121<br>输出: false<br>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>输入: 10<br>输出: false<br>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p>\n</blockquote>\n<p>题解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// -32等等均不是</span></span><br><span class=\"line\">        <span class=\"comment\">// 120 100等均不是</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span> || (x % <span class=\"number\">10</span> == <span class=\"number\">0</span> &amp;&amp; x != <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 采用字符串反转方式简单粗暴</span></span><br><span class=\"line\">        <span class=\"comment\">// 进阶采用整数方式解决，回文数只需反转数字长度的1/2即可</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> newX = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( x &gt; newX) &#123;</span><br><span class=\"line\">            newX = newX * <span class=\"number\">10</span> + x % <span class=\"number\">10</span>;</span><br><span class=\"line\">            x /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 返回结果需考虑奇数情况</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x == newX || newX / <span class=\"number\">10</span> == x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/palindrome-number/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"8_字符串转换整数_leetcode","url":"http://www.shenjian.online/2019/08/30/8-字符串转换整数-leetcode/","content":"<h2 id=\"8-字符串转换整数\"><a href=\"#8-字符串转换整数\" class=\"headerlink\" title=\"8. 字符串转换整数\"></a>8. 字符串转换整数</h2><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>\n<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。<br>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。<br>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>\n<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。<br>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>\n<p>说明：<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。</p>\n<blockquote>\n<p>输入: “42”<br>输出: 42<br>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。<br>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−2^31) 。</p>\n</blockquote>\n<p>题解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">myAtoi</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tstr = str != <span class=\"keyword\">null</span> ? str.trim() : <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (str.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> c = str.charAt(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> sign = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (c == <span class=\"string\">'+'</span>) &#123;</span><br><span class=\"line\">\t\t\tstart++;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">'-'</span>) &#123;</span><br><span class=\"line\">\t\t\tstart++;</span><br><span class=\"line\">\t\t\tsign = -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start; i &lt; str.length(); i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!Character.isDigit(str.charAt(i))) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>)res * sign;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tres = res * <span class=\"number\">10</span> + str.charAt(i) - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (res &gt; Integer.MAX_VALUE) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (sign == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> Integer.MAX_VALUE;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> Integer.MIN_VALUE;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>) (res * sign);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/string-to-integer-atoi/submissions/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"7_整数反转_leetcode","url":"http://www.shenjian.online/2019/08/29/7-整数反转-leetcode/","content":"<h2 id=\"7-整数反转\"><a href=\"#7-整数反转\" class=\"headerlink\" title=\"7. 整数反转\"></a>7. 整数反转</h2><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>\n<blockquote>\n<p>输入: 123<br>输出: 321<br>输入: -123<br>输出: -321<br>输入: 120<br>输出: 21<br>注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>\n</blockquote>\n<p>题解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (x != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> theUnit = x % <span class=\"number\">10</span>; <span class=\"comment\">// x的个位</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// [-2147483648,2147483647]</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (result &gt; Integer.MAX_VALUE / <span class=\"number\">10</span> || (result == Integer.MAX_VALUE / <span class=\"number\">10</span> &amp;&amp; theUnit &gt; <span class=\"number\">7</span>)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (result &lt; Integer.MIN_VALUE / <span class=\"number\">10</span> || (result == Integer.MIN_VALUE / <span class=\"number\">10</span> &amp;&amp; theUnit &lt; -<span class=\"number\">8</span>) ) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\tresult = result * <span class=\"number\">10</span> + theUnit;</span><br><span class=\"line\">\t\t\tx /= <span class=\"number\">10</span>; <span class=\"comment\">// 剔除x最后一位</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/reverse-integer/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"6_Z 字形变换_leetcode","url":"http://www.shenjian.online/2019/08/27/6-Z 字形变换-leetcode/","content":"<h2 id=\"6-Z-字形变换\"><a href=\"#6-Z-字形变换\" class=\"headerlink\" title=\"6. Z 字形变换\"></a>6. Z 字形变换</h2><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>\n<p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>\n<blockquote>\n<p>L   C   I   R<br>E T O E S I I G<br>E   D   H   N</p>\n</blockquote>\n<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p>\n<p>请你实现这个将字符串进行指定行数变换的函数：</p>\n<p>string convert(string s, int numRows);</p>\n<blockquote>\n<p>输入: s = “LEETCODEISHIRING”, numRows = 3<br>输出: “LCIRETOESIIGEDHN”<br>输入: s = “LEETCODEISHIRING”, numRows = 4<br>输出: “LDREOEIIECIHNTSG”<br>解释:</p>\n</blockquote>\n<blockquote>\n<p>L     D     R<br>E   O E   I I<br>E C   I H   N<br>T     S     G</p>\n</blockquote>\n<p>题解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">convert</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> numRows)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numRows &lt;= <span class=\"number\">1</span> || s.length() &lt;= numRows) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        String[] rows = <span class=\"keyword\">new</span> String[numRows];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows.length; i++) &#123;</span><br><span class=\"line\">            rows[i] = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> down = <span class=\"keyword\">false</span>; <span class=\"comment\">// 用来表示向下或者向上移动</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; <span class=\"comment\">// 用来表示rows下标</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            rows[index] += s.charAt(i);</span><br><span class=\"line\">            <span class=\"comment\">// 改变移动方向,为定位当前值该存储的rows下标</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index == <span class=\"number\">0</span> || index == numRows - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                down = !down;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            index += down ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        String result = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String row : rows) &#123;</span><br><span class=\"line\">            result += row;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/zigzag-conversion/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"5_最长回文子串_leetcode","url":"http://www.shenjian.online/2019/08/26/5-最长回文子串-leetcode/","content":"<h2 id=\"5-最长回文子串\"><a href=\"#5-最长回文子串\" class=\"headerlink\" title=\"5. 最长回文子串\"></a>5. 最长回文子串</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>\n<blockquote>\n<p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>输入: “cbbd”<br>输出: “bb”</p>\n</blockquote>\n<p>题解： 中心化扩展算法 回文中心两侧互为镜像，以当前位置为中心，向外扩展查找设start为当前位置回文串最左侧, end为当前位置回文串最右侧,<br>时间复杂度 O(n^2) 空间复杂度 O(1),感兴趣读者可尝试采用Manacher算法，时间复杂度 O(n)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.length() &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> end = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 回文串中心与两侧数值不相等 即aba形式</span></span><br><span class=\"line\">            <span class=\"comment\">// 回文串中心与右侧数值相等 即abba形式</span></span><br><span class=\"line\">            <span class=\"comment\">// 由于i从0开始遍历，故回文串中心与左侧数值相等无需考虑</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> lengthOne = expandAroundCenter(s, i, i); <span class=\"comment\">// aba</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> lengthTwo = expandAroundCenter(s, i, i + <span class=\"number\">1</span>); <span class=\"comment\">// abba</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = Math.max(lengthOne, lengthTwo);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (len &gt; end - start) &#123;</span><br><span class=\"line\">                start = i - (len - <span class=\"number\">1</span>) / <span class=\"number\">2</span>; <span class=\"comment\">// 更新回文串最左侧</span></span><br><span class=\"line\">                end = i + len / <span class=\"number\">2</span>; <span class=\"comment\">// 更新回文串最右侧</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.substring(start, end + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">expandAroundCenter</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> L = left, R = right;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (L &gt;= <span class=\"number\">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向两边扩展</span></span><br><span class=\"line\">            L--;</span><br><span class=\"line\">            R++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> R - L - <span class=\"number\">1</span>; <span class=\"comment\">// 返回当前最大长度</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"3_无重复字符的最长子串_leetcode","url":"http://www.shenjian.online/2019/08/18/3-无重复字符的最长子串-leetcode/","content":"<h2 id=\"3-无重复字符的最长子串\"><a href=\"#3-无重复字符的最长子串\" class=\"headerlink\" title=\"3. 无重复字符的最长子串\"></a>3. 无重复字符的最长子串</h2><p>给定一个字符串，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p>\n<blockquote>\n<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>\n</blockquote>\n<p>题解： end遍历字符串,更新start[更新采用的方式决定了算法的效率],更新longestLength</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> start = <span class=\"number\">0</span>; <span class=\"comment\">// 设定不重复元素左边界</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> end = <span class=\"number\">0</span>; <span class=\"comment\">// 设定不重复元素右边界</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> longestLength = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// key为当前遍历的元素,value为当前</span></span><br><span class=\"line\">        <span class=\"comment\">// end为不重复右边界，end+1在遍历时可能重复，可能不重复</span></span><br><span class=\"line\">        <span class=\"comment\">// 若下一次遍历时，重复，则更新start</span></span><br><span class=\"line\">        Map&lt;Character, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (end = <span class=\"number\">0</span>; end &lt; s.length(); end++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = s.charAt(end);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(c)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 需要仔细理解此处，由于之前的设定，[start, end]间为最长结果值，即end-start+1,</span></span><br><span class=\"line\">                <span class=\"comment\">// 由于map中包含c值，故在[start,end]间必定存在元素与c值相同，</span></span><br><span class=\"line\">                <span class=\"comment\">// 最好情况为start与c值相同，即最大长度为end-start+1，换言之，在(start,end]间，最大长度一定小于end-start+1</span></span><br><span class=\"line\">                <span class=\"comment\">// 故start为以下取值方式</span></span><br><span class=\"line\">                start = Math.max(map.get(c) + <span class=\"number\">1</span>, start);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            longestLength = Math.max(end - start + <span class=\"number\">1</span>, longestLength);</span><br><span class=\"line\">            map.put(c, end); <span class=\"comment\">// 存储当前的不重复最大end边界</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> longestLength;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"2_两数之加_leetcode","url":"http://www.shenjian.online/2019/08/13/2-两数之加-leetcode/","content":"<h2 id=\"2-两数之加\"><a href=\"#2-两数之加\" class=\"headerlink\" title=\"2. 两数之加\"></a>2. 两数之加</h2><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n<p>题解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> carry = <span class=\"number\">0</span>; <span class=\"comment\">// 存储进位</span></span><br><span class=\"line\">        ListNode resultNode = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode firstNode = l1;</span><br><span class=\"line\">        ListNode secondNode = l2;</span><br><span class=\"line\">        ListNode currentNode = resultNode;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (firstNode != <span class=\"keyword\">null</span> || secondNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> firstNodeValue = firstNode != <span class=\"keyword\">null</span> ? firstNode.val : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> secondNodeValue = secondNode != <span class=\"keyword\">null</span> ? secondNode.val : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = carry + firstNodeValue + secondNodeValue;</span><br><span class=\"line\"></span><br><span class=\"line\">            currentNode.next = <span class=\"keyword\">new</span> ListNode(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">            carry = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            currentNode = currentNode.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (firstNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                firstNode = firstNode.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (secondNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                secondNode = secondNode.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (carry &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 最后一位也可能进位</span></span><br><span class=\"line\">            currentNode.next = <span class=\"keyword\">new</span> ListNode(carry);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> resultNode.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">      ListNode next;</span><br><span class=\"line\">      ListNode(<span class=\"keyword\">int</span> x) &#123; val = x; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/add-two-numbers/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"1_两数之和_leetcode","url":"http://www.shenjian.online/2019/08/11/1-两数之和-leetcode/","content":"<h2 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1. 两数之和\"></a>1. 两数之和</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>\n<blockquote>\n<p>示例:<br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>\n</blockquote>\n<p>题解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 以nums元素为key,下标为value，</span></span><br><span class=\"line\"><span class=\"comment\">     * 若遍历时存在target - nums[i]的key, 则找到输出即可</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;map.get(target - nums[i]), i&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            map.put(nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"No two sum solution\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/two-sum/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"快速排序","url":"http://www.shenjian.online/2019/07/23/快速排序/","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 快速排序</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 快速排序通过一个切分元素将数组分为左右两个数组，</span></span><br><span class=\"line\"><span class=\"comment\"> * 左数组元素小于等于切分元素，右数组大于等于切分元素，</span></span><br><span class=\"line\"><span class=\"comment\"> * 将左右子数组排序，整个数组也就有序了</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 平均情况为O(nlog(n)),最差情况O(n~2),存储空间O(log(n))</span></span><br><span class=\"line\"><span class=\"comment\"> * V1.1.0 sort、partition写法参照&lt;&lt;程序员面试金典&gt;&gt;重写</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Jian Shen</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@version</span> V1.1.0</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2019/7/23</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuitSort</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Sort</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(@NotNull T[] arr)</span> </span>&#123;</span><br><span class=\"line\">        shuffle(arr);</span><br><span class=\"line\">        sort(arr, <span class=\"number\">0</span> , arr.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] arr, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = partition(arr, left, right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt; index - <span class=\"number\">1</span>) &#123; <span class=\"comment\">// 排序左半部分</span></span><br><span class=\"line\">            sort(arr, left, index - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; right) &#123; <span class=\"comment\">// 排序右半部分</span></span><br><span class=\"line\">            sort(arr, index, right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(T[] arr, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        T pivot = arr[(left + right) / <span class=\"number\">2</span>]; <span class=\"comment\">// 挑选一个基准点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 找到左边应被放到右边的元素</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (arr[left].compareTo(pivot) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 找到右边应被放到左边的元素</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (arr[right].compareTo(pivot) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left &lt;= right) &#123;</span><br><span class=\"line\">                swap(arr, left, right); <span class=\"comment\">// 交换元素</span></span><br><span class=\"line\">                left++;</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">shuffle</span><span class=\"params\">(T[] arr)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Comparable&gt; list = Arrays.asList(arr);</span><br><span class=\"line\">        Collections.shuffle(list); <span class=\"comment\">// 防止最坏的情况，第一次从最小的元素切分，第二次从次小的元素切分。时间复杂度N^2</span></span><br><span class=\"line\">        list.toArray(arr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Sort sort = <span class=\"keyword\">new</span> QuitSort();</span><br><span class=\"line\">        Integer[] arr = <span class=\"keyword\">new</span> Integer[]&#123;<span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">        sort.sort(arr);</span><br><span class=\"line\">        System.out.println(Arrays.asList(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多排序算法见<a href=\"https://github.com/SJshenjian/algorithm/blob/master/base/src/main/java/sort\" target=\"_blank\" rel=\"noopener\">github</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构"]},{"title":"归并排序","url":"http://www.shenjian.online/2019/07/21/归并排序/","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 归并排序</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Jian Shen</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@version</span> V1.0.0</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2019/7/21</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MergeSort</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Sort</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> T[] assist; <span class=\"comment\">// 辅助数组</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将数组中已经排好序的两个部分[左侧部分、右侧部分]合并</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> left</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> middle</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> right</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(@NotNull T[] array, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> middle, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = left;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = middle + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = left; k &lt;= right; k++) &#123;</span><br><span class=\"line\">            assist[k] = array[k];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = left; k &lt;= right; k++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; middle) &#123; <span class=\"comment\">// 说明左侧部分已经完成合并，仅需合并右侧部分</span></span><br><span class=\"line\">                array[k] = assist[j++];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j &gt; right) &#123; <span class=\"comment\">// 说明右侧部分已经完成合并，仅需合并左侧部分</span></span><br><span class=\"line\">                array[k] = assist[i++];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (assist[i].compareTo(assist[j]) &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                array[k] = assist[i++];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                array[k] = assist[j++];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 自顶向下归并排序</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 将数组分成两个部分，分别进行排序，然后归并起来</span></span><br><span class=\"line\"><span class=\"comment\"> * 这种对半分的复杂度为O(NlogN)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Jian Shen</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@version</span> V1.0.0</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2019/7/21</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Up2DownMergeSort</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt; <span class=\"keyword\">extends</span> <span class=\"title\">MergeSort</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] array)</span> </span>&#123;</span><br><span class=\"line\">        assist = (T[]) <span class=\"keyword\">new</span> Comparable[array.length];</span><br><span class=\"line\">        sort(array, <span class=\"number\">0</span>, array.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] array, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &gt;= right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> middle = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        sort(array, left, middle);</span><br><span class=\"line\">        sort(array, middle + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">        merge(array, left, middle, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Sort sort = <span class=\"keyword\">new</span> Up2DownMergeSort();</span><br><span class=\"line\">        Integer[] array = <span class=\"keyword\">new</span> Integer[]&#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">        sort.sort(array);</span><br><span class=\"line\">        System.out.println(Arrays.asList(array));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多排序算法见<a href=\"https://github.com/SJshenjian/algorithm/blob/master/base/src/main/java/sort\" target=\"_blank\" rel=\"noopener\">github</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构"]},{"title":"希尔排序","url":"http://www.shenjian.online/2019/07/21/希尔排序/","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 希尔排序</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 对于大规模的数组，插入排序很慢，因为每次只能将逆序数量减1，</span></span><br><span class=\"line\"><span class=\"comment\"> * 希尔排序交换不相邻的元素，每次可以将逆序数量减少大于1</span></span><br><span class=\"line\"><span class=\"comment\"> * 希尔排序使用插入排序对间隔h的序列进行排序，通过不断减小h至1，就可以使得数组是有序的</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Jian Shen</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@version</span> V1.0.0</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2019/7/21</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShellSort</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Sort</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(@NotNull T[] array)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = array.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> h = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (h &lt; length / <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            h = <span class=\"number\">3</span> * h + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (h &gt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = h; i &lt; length; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt;= h; j -= h) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (less(array[j], array[j - h])) &#123;</span><br><span class=\"line\">                        swap(array, j, j - h);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            h /= <span class=\"number\">3</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Sort sort = <span class=\"keyword\">new</span> ShellSort();</span><br><span class=\"line\">        Integer[] array = <span class=\"keyword\">new</span> Integer[]&#123;<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">        sort.sort(array);</span><br><span class=\"line\">        System.out.println(Arrays.asList(array));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多排序算法见<a href=\"https://github.com/SJshenjian/algorithm/blob/master/base/src/main/java/sort\" target=\"_blank\" rel=\"noopener\">github</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构"]},{"title":"插入排序","url":"http://www.shenjian.online/2019/07/20/插入排序/","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 插入排序</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 每次将当前元素插入到左侧已经排序的数组中，插入之后左侧数组依然有序。</span></span><br><span class=\"line\"><span class=\"comment\"> * 对于数组 &#123;3, 5, 2, 4, 1&#125;，它具有以下逆序：(3, 2), (3, 1), (5, 2), (5, 4), (5, 1), (2, 1), (4, 1)，</span></span><br><span class=\"line\"><span class=\"comment\"> * 插入排序每次只能交换相邻元素，令逆序数量减少 1，因此插入排序需要交换的次数为逆序数量</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Jian Shen</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@version</span> V1.0.0</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2019/7/20</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InsertSort</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Sort</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] array)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = array.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt; <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (less(array[j], array[j - <span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">                    swap(array, j, j -<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Sort sort = <span class=\"keyword\">new</span> InsertSort();</span><br><span class=\"line\">        Integer[] array = <span class=\"keyword\">new</span> Integer[]&#123;<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">        sort.sort(array);</span><br><span class=\"line\">        System.out.println(Arrays.asList(array));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多排序算法见<a href=\"https://github.com/SJshenjian/algorithm/blob/master/base/src/main/java/sort\" target=\"_blank\" rel=\"noopener\">github</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构"]},{"title":"冒泡排序","url":"http://www.shenjian.online/2019/07/20/冒泡排序/","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 冒泡排序</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * 从左到右不断交换相邻逆序的元素，在一轮循环后，可以让未排序的最大元素上浮至最右侧</span></span><br><span class=\"line\"><span class=\"comment\"> * 在一轮循环中，如果没有发生交换，则说明此时数组已经有序，可以直接退出</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Jian Shen</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@version</span> V1.0.0</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2019/7/20</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BubbleSort</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Sort</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(@NotNull T[] array)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = array.length;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> sorted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = length - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span> &amp;&amp; !sorted; i--) &#123;</span><br><span class=\"line\">            sorted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (less(array[j + <span class=\"number\">1</span>], array[j])) &#123;</span><br><span class=\"line\">                    sorted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    swap(array, j, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Sort sort = <span class=\"keyword\">new</span> BubbleSort();</span><br><span class=\"line\">        Integer[] array = <span class=\"keyword\">new</span> Integer[]&#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">        sort.sort(array);</span><br><span class=\"line\">        System.out.println(Arrays.asList(array));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多排序算法见<a href=\"https://github.com/SJshenjian/algorithm/blob/master/base/src/main/java/sort\" target=\"_blank\" rel=\"noopener\">github</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构"]},{"title":"选择排序","url":"http://www.shenjian.online/2019/07/20/选择排序/","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 选择排序</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 从数组中第一个位置开始循环数组选择最小的一个元素放于数组第一个位置，然后</span></span><br><span class=\"line\"><span class=\"comment\"> * 从数组中第二个位置开始循环数组选择最小的一个元素放于数组的第二个位置，</span></span><br><span class=\"line\"><span class=\"comment\"> * 依此类推，直到整个数组排序</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Jian Shen</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@version</span> V1.0.0</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2019/7/20</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SelectSort</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Sort</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(@NotNull T[] array)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = array.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> min = i;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (less(array[j], array[min])) &#123;</span><br><span class=\"line\">                    min = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            swap(array, i, min);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Sort sort = <span class=\"keyword\">new</span> SelectSort();</span><br><span class=\"line\">        Integer[] array = <span class=\"keyword\">new</span> Integer[]&#123;<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">        sort.sort(array);</span><br><span class=\"line\">        System.out.println(Arrays.asList(array));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多排序算法见<a href=\"https://github.com/SJshenjian/algorithm/blob/master/base/src/main/java/sort\" target=\"_blank\" rel=\"noopener\">github</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构"]},{"title":"Docker快速部署kibana","url":"http://www.shenjian.online/2019/07/07/Docker快速部署kibana/","content":"<p>基于CentOS7，VMWare虚拟机给其分配了2G内存, <strong>防火墙已关闭</strong></p>\n<h2 id=\"1-编写docker-compose-yml\"><a href=\"#1-编写docker-compose-yml\" class=\"headerlink\" title=\"1. 编写docker-compose.yml\"></a>1. 编写docker-compose.yml</h2><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">'2'</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\"><span class=\"attr\">  kibana:</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">docker.elastic.co/kibana/kibana:7.2.0</span></span><br><span class=\"line\"><span class=\"attr\">    ports:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">\"5601:5601\"</span> <span class=\"comment\"># 再次强调，一定要做端口映射,否则无法远程访问</span></span><br><span class=\"line\">    <span class=\"comment\">#volumes: 先注释挂载，后面后讲到原因</span></span><br><span class=\"line\">    <span class=\"comment\">#  - ./kibana.yml:/usr/share/kibana/config/kibana.yml</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-启动kibana并复制kibana-yml文件\"><a href=\"#2-启动kibana并复制kibana-yml文件\" class=\"headerlink\" title=\"2. 启动kibana并复制kibana.yml文件\"></a>2. 启动kibana并复制kibana.yml文件</h2><p><code>docker-compose up -d</code>启动kibana后，<code>docker ps -a</code>查看启动后的容器ID为0481b574ce11</p>\n<p>执行复制命令<br>将容器中的kibana.yml文件复制到本机/opt/kibana/kibana.yml<br><strong>这样避免因为不同版本的差异导致配置文件不同，从网络上搜索的配置文件与版本不兼容问题</strong></p>\n<p><code>docker cp 04:/usr/share/kibana/config/kibana.yml /opt/kibana/kibana.yml</code></p>\n<h2 id=\"3-修改docekr-compose-yml文件与kibana-yml文件-kibana版本为7-2-0\"><a href=\"#3-修改docekr-compose-yml文件与kibana-yml文件-kibana版本为7-2-0\" class=\"headerlink\" title=\"3.修改docekr-compose.yml文件与kibana.yml文件(kibana版本为7.2.0)\"></a>3.修改docekr-compose.yml文件与kibana.yml文件(kibana版本为7.2.0)</h2><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">'2'</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\"><span class=\"attr\">  kibana:</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">docker.elastic.co/kibana/kibana:7.2.0</span></span><br><span class=\"line\"><span class=\"attr\">    ports:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">\"5601:5601\"</span></span><br><span class=\"line\"><span class=\"attr\">    volumes:</span> <span class=\"comment\"># 放开注释，配置文件挂载</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">./kibana.yml:/usr/share/kibana/config/kibana.yml</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">server.name:</span> <span class=\"string\">kibana</span></span><br><span class=\"line\"><span class=\"string\">server.host:</span> <span class=\"string\">\"0.0.0.0\"</span></span><br><span class=\"line\"><span class=\"string\">elasticsearch.hosts:</span> <span class=\"string\">[</span> <span class=\"string\">\"http://192.168.153.151:9200\"</span> <span class=\"string\">]</span> <span class=\"comment\"># kibana依赖于elasticsearch,请先确保其正常启动，修改IP地址为elasticsearch地址</span></span><br><span class=\"line\"><span class=\"string\">elasticsearch.requestTimeout:</span> <span class=\"number\">90000</span> <span class=\"comment\"># 默认30000</span></span><br><span class=\"line\"><span class=\"string\">xpack.monitoring.ui.container.elasticsearch.enabled:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-重新启动，远程访问\"><a href=\"#4-重新启动，远程访问\" class=\"headerlink\" title=\"4. 重新启动，远程访问\"></a>4. 重新启动，远程访问</h3><p><code>docker-compose down</code><br><code>docker-compose up -d</code></p>\n<p><a href=\"http://192.168.153.151:5601开始kibana之旅吧\" target=\"_blank\" rel=\"noopener\">http://192.168.153.151:5601开始kibana之旅吧</a></p>\n","categories":["Docker"],"tags":["Docker","Kibana"]},{"title":"Docker快速部署elasticsearch","url":"http://www.shenjian.online/2019/06/30/Docker快速部署elasticsearch/","content":"<p>基于CentOS7，VMWare虚拟机给其分配了2G内存, <strong>防火墙已关闭</strong></p>\n<h2 id=\"1-编写docker-compose-yml\"><a href=\"#1-编写docker-compose-yml\" class=\"headerlink\" title=\"1. 编写docker-compose.yml\"></a>1. 编写docker-compose.yml</h2><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">'2.2'</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\"><span class=\"attr\">  es01:</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"attr\">elasticsearch:7.2.0</span></span><br><span class=\"line\"><span class=\"attr\">    container_name:</span> <span class=\"string\">es01</span></span><br><span class=\"line\"><span class=\"attr\">    environment:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">node.name=es01</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">discovery.seed_hosts=es02</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">cluster.initial_master_nodes=es01,es02</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">cluster.name=docker-cluster</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">bootstrap.memory_lock=true</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">\"ES_JAVA_OPTS=-Xms256m -Xmx256m\"</span></span><br><span class=\"line\"><span class=\"attr\">    ulimits:</span></span><br><span class=\"line\"><span class=\"attr\">      memlock:</span></span><br><span class=\"line\"><span class=\"attr\">        soft:</span> <span class=\"bullet\">-1</span></span><br><span class=\"line\"><span class=\"attr\">        hard:</span> <span class=\"bullet\">-1</span></span><br><span class=\"line\"><span class=\"attr\">    volumes:</span></span><br><span class=\"line\"><span class=\"attr\">      - esdata01:</span><span class=\"string\">/usr/share/elasticsearch/data</span></span><br><span class=\"line\"><span class=\"attr\">    ports:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"number\">9200</span><span class=\"string\">:9200</span></span><br><span class=\"line\"><span class=\"attr\">    networks:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">esnet</span></span><br><span class=\"line\"><span class=\"attr\">  es02:</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"attr\">elasticsearch:7.2.0</span></span><br><span class=\"line\"><span class=\"attr\">    container_name:</span> <span class=\"string\">es02</span></span><br><span class=\"line\"><span class=\"attr\">    environment:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">node.name=es02</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">discovery.seed_hosts=es01</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">cluster.initial_master_nodes=es01,es02</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">cluster.name=docker-cluster</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">bootstrap.memory_lock=true</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">\"ES_JAVA_OPTS=-Xms256m -Xmx256m\"</span></span><br><span class=\"line\"><span class=\"attr\">    ulimits:</span></span><br><span class=\"line\"><span class=\"attr\">      memlock:</span></span><br><span class=\"line\"><span class=\"attr\">        soft:</span> <span class=\"bullet\">-1</span></span><br><span class=\"line\"><span class=\"attr\">        hard:</span> <span class=\"bullet\">-1</span></span><br><span class=\"line\"><span class=\"attr\">    volumes:</span></span><br><span class=\"line\"><span class=\"attr\">      - esdata02:</span><span class=\"string\">/usr/share/elasticsearch/data</span></span><br><span class=\"line\"><span class=\"attr\">    networks:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">esnet</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\"><span class=\"attr\">  esdata01:</span></span><br><span class=\"line\"><span class=\"attr\">    driver:</span> <span class=\"string\">local</span></span><br><span class=\"line\"><span class=\"attr\">  esdata02:</span></span><br><span class=\"line\"><span class=\"attr\">    driver:</span> <span class=\"string\">local</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\"><span class=\"attr\">  esnet:</span></span><br></pre></td></tr></table></figure>\n<p>PS: <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html\" target=\"_blank\" rel=\"noopener\">Elasticsearch官方docker-compose.yml</a></p>\n<h2 id=\"2-设置vm-max-map-count\"><a href=\"#2-设置vm-max-map-count\" class=\"headerlink\" title=\"2. 设置vm.max_map_count\"></a>2. 设置vm.max_map_count</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># vm.max_map_count： 一个进程可以拥有的VMA(虚拟内存区域)的数量</span></span><br><span class=\"line\"><span class=\"comment\"># 单个JVM能开启的最大线程数为vm.max_map_count的一半，即10W线程</span></span><br><span class=\"line\"><span class=\"comment\"># 临时性修改 本质262144写入文件/proc/sys/vm/max_map_count中</span></span><br><span class=\"line\">sysctl -w vm.max_map_count=262144</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># [建议]永久性无法修改/proc/sys/vm/max_map_count文件，但linux中允许直接修改/etc/sysctl.conf,故直接在该文件末添加参数并查看</span></span><br><span class=\"line\">sysctl -p <span class=\"comment\"># 使得修改立即生效，即使重启也生效</span></span><br><span class=\"line\">grep vm.max_map_count /etc/sysctl.conf</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html\" target=\"_blank\" rel=\"noopener\">官网</a>说明：<br>The vm.max_map_count kernel setting needs to be set to at least 262144 for production use. </p>\n<h2 id=\"3-启动并查看相关信息\"><a href=\"#3-启动并查看相关信息\" class=\"headerlink\" title=\"3. 启动并查看相关信息\"></a>3. 启动并查看相关信息</h2><p>执行<code>docker-compose up -d</code>启动</p>\n<p>[root@centos7 elasticsearch]# docker container ls<br>CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                              NAMES<br>ccd713fa8ff6        elasticsearch:7.2.0   “/usr/local/bin/dock…”   55 seconds ago      Up 51 seconds       0.0.0.0:9200-&gt;9200/tcp, 9300/tcp   es01<br>7d1ff4a506d0        elasticsearch:7.2.0   “/usr/local/bin/dock…”   55 seconds ago      Up 51 seconds       9200/tcp, 9300/tcp                 es02</p>\n<p><a href=\"http://192.168.153.151:9200/\" target=\"_blank\" rel=\"noopener\">http://192.168.153.151:9200/</a><br>{<br>  “name” : “es01”,<br>  “cluster_name” : “docker-cluster”,<br>  “cluster_uuid” : “1FJ55641T7ignLt7APzQVQ”,<br>  “version” : {<br>    “number” : “7.2.0”,<br>    “build_flavor” : “default”,<br>    “build_type” : “docker”,<br>    “build_hash” : “508c38a”,<br>    “build_date” : “2019-06-20T15:54:18.811730Z”,<br>    “build_snapshot” : false,<br>    “lucene_version” : “8.0.0”,<br>    “minimum_wire_compatibility_version” : “6.8.0”,<br>    “minimum_index_compatibility_version” : “6.0.0-beta1”<br>  },<br>  “tagline” : “You Know, for Search”<br>}</p>\n<p><a href=\"http://192.168.153.151:9200/_cat/health\" target=\"_blank\" rel=\"noopener\">http://192.168.153.151:9200/_cat/health</a><br>1561904921 14:28:41 docker-cluster green 2 2 0 0 0 0 0 0 - 100.0%</p>\n<p><a href=\"http://192.168.153.151:9200/_cat/nodes\" target=\"_blank\" rel=\"noopener\">http://192.168.153.151:9200/_cat/nodes</a><br>172.18.0.3 55 95 7 0.23 2.63 3.50 mdi * es01<br>172.18.0.2 51 95 7 0.23 2.63 3.50 mdi - es02</p>\n<p>单机多实例启动成功~~~~</p>\n<p><code>docker container stop ccd713fa8ff6</code>停掉es01时，访问：</p>\n<p><a href=\"http://192.168.153.151:9200\" target=\"_blank\" rel=\"noopener\">http://192.168.153.151:9200</a> 显示结果不变</p>\n<p><a href=\"http://192.168.153.151:9200/_cat/health\" target=\"_blank\" rel=\"noopener\">http://192.168.153.151:9200/_cat/health</a><br>1561905162 14:32:42 docker-cluster green 1 1 0 0 0 0 0 0 - 100.0%</p>\n<p><a href=\"http://192.168.153.151:9200/_cat/nodes\" target=\"_blank\" rel=\"noopener\">http://192.168.153.151:9200/_cat/nodes</a><br>172.18.0.3 40 68 0 0.02 0.69 2.26 mdi * es01</p>\n","categories":["Docker"],"tags":["Docker","Elasticsearch"]},{"title":"ELK Stack家族成员及应用场景","url":"http://www.shenjian.online/2019/06/30/ELK-Stack家族成员及应用场景/","content":"<h2 id=\"1-Elastic-Stack生态圈\"><a href=\"#1-Elastic-Stack生态圈\" class=\"headerlink\" title=\"1. Elastic Stack生态圈\"></a>1. Elastic Stack生态圈</h2><p><img src=\"/2019/06/30/ELK-Stack家族成员及应用场景/Elastic-Stack生态圈.png\" alt=\"Elastic Stack生态圈\"></p>\n<h2 id=\"2-Logstash-数据处理管道\"><a href=\"#2-Logstash-数据处理管道\" class=\"headerlink\" title=\"2. Logstash:数据处理管道\"></a>2. Logstash:数据处理管道</h2><h3 id=\"2-1-简介\"><a href=\"#2-1-简介\" class=\"headerlink\" title=\"2.1 简介\"></a>2.1 简介</h3><ul>\n<li>开源的服务器端数据处理工具，支持从不同来源采集数据，转换数据，并将数据发送到不同的存储库中</li>\n<li>最初用来做日志的采集与处理</li>\n</ul>\n<h3 id=\"2-2-特性\"><a href=\"#2-2-特性\" class=\"headerlink\" title=\"2.2 特性\"></a>2.2 特性</h3><ul>\n<li>实时解析与转换数据<ul>\n<li>从IP地址中破译出地理坐标</li>\n<li>将PII数据匿名化，完全排除敏感字段</li>\n</ul>\n</li>\n<li>可扩展性<ul>\n<li>200多个插件(日志/数据库/Arcsigh/Netflow)</li>\n</ul>\n</li>\n<li>可靠安全性<ul>\n<li>Logstash通过持久化队列来保证至少将运行中的事件运行一次</li>\n<li>数据传输加密</li>\n</ul>\n</li>\n<li>监控</li>\n</ul>\n<h2 id=\"3-Kibana-可视化分析利器\"><a href=\"#3-Kibana-可视化分析利器\" class=\"headerlink\" title=\"3. Kibana:可视化分析利器\"></a>3. Kibana:可视化分析利器</h2><p><img src=\"/2019/06/30/ELK-Stack家族成员及应用场景/Kibana.png\" alt=\"Kibana\"></p>\n<h2 id=\"4-BEATS-轻量的数据采集器\"><a href=\"#4-BEATS-轻量的数据采集器\" class=\"headerlink\" title=\"4. BEATS:轻量的数据采集器\"></a>4. BEATS:轻量的数据采集器</h2><p><img src=\"/2019/06/30/ELK-Stack家族成员及应用场景/Beats系列.png\" alt=\"Beats系列\"></p>\n<h2 id=\"5-ELK应用场景\"><a href=\"#5-ELK应用场景\" class=\"headerlink\" title=\"5. ELK应用场景\"></a>5. ELK应用场景</h2><ul>\n<li>网站搜索、垂直搜索、代码搜索</li>\n<li>日志管理与分析、安全指标监控、应用性能监控、WEB抓取舆情分析</li>\n</ul>\n<h3 id=\"5-1-搜索型业务场景\"><a href=\"#5-1-搜索型业务场景\" class=\"headerlink\" title=\"5.1 搜索型业务场景\"></a>5.1 搜索型业务场景</h3><p><img src=\"/2019/06/30/ELK-Stack家族成员及应用场景/与数据库集成.png\" alt=\"与数据库集成\"></p>\n<ul>\n<li>单独使用Elsticserch存储(不推荐)</li>\n<li>以下情况下课考虑与数据库集成<ul>\n<li>与现有系统的集成</li>\n<li>需考虑事务</li>\n<li>数据更新频繁</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-2-日志型业务场景\"><a href=\"#5-2-日志型业务场景\" class=\"headerlink\" title=\"5.2 日志型业务场景\"></a>5.2 日志型业务场景</h3><h4 id=\"5-2-1-日志管理\"><a href=\"#5-2-1-日志管理\" class=\"headerlink\" title=\"5.2.1 日志管理\"></a>5.2.1 日志管理</h4><p><img src=\"/2019/06/30/ELK-Stack家族成员及应用场景/日志管理.png\" alt=\"日志管理\"></p>\n<h4 id=\"5-2-2-指标分析、日志分析\"><a href=\"#5-2-2-指标分析、日志分析\" class=\"headerlink\" title=\"5.2.2 指标分析、日志分析\"></a>5.2.2 指标分析、日志分析</h4><p><img src=\"/2019/06/30/ELK-Stack家族成员及应用场景/指标分析_日志分析.png\" alt=\"指标分析_日志分析\"></p>\n<h4 id=\"5-2-3-安全分析-集成ArcSight\"><a href=\"#5-2-3-安全分析-集成ArcSight\" class=\"headerlink\" title=\"5.2.3 安全分析:集成ArcSight\"></a>5.2.3 安全分析:集成ArcSight</h4><p><img src=\"/2019/06/30/ELK-Stack家族成员及应用场景/集成ArcSight.png\" alt=\"集成ArcSight.png\"></p>\n","categories":["Elasticsearch"],"tags":["Elasticsearch"]},{"title":"Elasticsearch简介","url":"http://www.shenjian.online/2019/06/29/Elasticsearch简介/","content":"<p>Elasticsearch(开源分布式搜索引擎): 近实时、分布式存储/搜索/分析引擎</p>\n<h2 id=\"1-起源\"><a href=\"#1-起源\" class=\"headerlink\" title=\"1. 起源\"></a>1. 起源</h2><p>Elasticsearch起源于Lucene</p>\n<ul>\n<li>基于Java语言开发的搜索引擎类库</li>\n<li>高性能、易扩展</li>\n<li>Lucene的局限性: <ul>\n<li>只能基于Java语言开发</li>\n<li>类库学习曲线陡峭</li>\n<li>原生并不支持水平扩展</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-诞生\"><a href=\"#2-诞生\" class=\"headerlink\" title=\"2. 诞生\"></a>2. 诞生</h2><ul>\n<li>2004年Shay Banon基于Lucene开发了Compass</li>\n<li>2010年Shay Banon重写Compass, 取名为Elasticsearch<ul>\n<li>支持分布式，可水平扩展</li>\n<li>降低全文检索学习曲线，可以被任何语言调用</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-分布式架构\"><a href=\"#3-分布式架构\" class=\"headerlink\" title=\"3. 分布式架构\"></a>3. 分布式架构</h2><p><img src=\"/2019/06/29/Elasticsearch简介/Elasticsearch分布式架构.png\" alt=\"Elasticsearch的分布式架构\"></p>\n<ul>\n<li>集群规模可以从单个扩展到数百个</li>\n<li>高可用&amp;水平扩展<ul>\n<li>服务和数据两个维度</li>\n</ul>\n</li>\n<li>支持不同的节点类型<ul>\n<li>支持Hot&amp;Warm架构</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-支持多种继承方式接入\"><a href=\"#4-支持多种继承方式接入\" class=\"headerlink\" title=\"4. 支持多种继承方式接入\"></a>4. 支持多种继承方式接入</h2><ul>\n<li>多种编程语言的类库</li>\n<li>RESTful API v.s Transport API</li>\n<li>JDBC &amp; ODBC</li>\n</ul>\n<h2 id=\"5-主要功能\"><a href=\"#5-主要功能\" class=\"headerlink\" title=\"5. 主要功能\"></a>5. 主要功能</h2><ul>\n<li>海量数据的分布式存储及集群管理<ul>\n<li>服务与数据两个维度，水平扩展</li>\n</ul>\n</li>\n<li>近实时搜索，性能卓越<ul>\n<li>结构化/全文/地理位置/自动完成</li>\n</ul>\n</li>\n<li>海量数据的近实时分析<ul>\n<li>聚合功能</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"6-版本与新特性\"><a href=\"#6-版本与新特性\" class=\"headerlink\" title=\"6. 版本与新特性\"></a>6. 版本与新特性</h2><h3 id=\"6-1-新特性-5-X\"><a href=\"#6-1-新特性-5-X\" class=\"headerlink\" title=\"6.1 新特性 5.X\"></a>6.1 新特性 5.X</h3><ul>\n<li>Lucene 6.X,性能能提升，默认打分机制从TF-IDF改为BM 25</li>\n<li>支持Ingest节点/Painless Scripting/Completion suggested支持/原生的Java REST客户端</li>\n<li>Type标记成deprecated,新增Keyword类型支持</li>\n<li>性能优化<ul>\n<li>内部引擎移除了避免同一文档并发更新的竞争锁，性能提升15%~20%</li>\n<li>Instant aggregation,支持分片上聚合的缓存</li>\n<li>新增了Profile API</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-2-新特性-6-X\"><a href=\"#6-2-新特性-6-X\" class=\"headerlink\" title=\"6.2 新特性 6.X\"></a>6.2 新特性 6.X</h3><ul>\n<li>Lucene 7.X</li>\n<li>新功能<ul>\n<li>跨集群复制(CCR)</li>\n<li>索引生命周期管理</li>\n<li>SQL的支持</li>\n</ul>\n</li>\n<li>更友好的升级及数据迁移<ul>\n<li>在主要版本间升级更为简化</li>\n<li>全新的基于操作的数据复制框架，可加快恢复数据</li>\n</ul>\n</li>\n<li>性能优化<ul>\n<li>有效存储稀疏字段的新方法，降低了存储成本</li>\n<li>在索引时进行排序，可加快排序的查询性能</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-3-新特性-7-X\"><a href=\"#6-3-新特性-7-X\" class=\"headerlink\" title=\"6.3 新特性 7.X\"></a>6.3 新特性 7.X</h3><ul>\n<li>Lucene 8.0</li>\n<li>重大改进-正式废除单个索引下的多Type的支持</li>\n<li>7.1开始，Security功能免费使用</li>\n<li>ECK - Elasticsearch Operator on Kubernetes</li>\n<li>新功能<ul>\n<li>New Cluster coordition</li>\n<li>Future-Complete High Level REST Client</li>\n<li>Script Score Query</li>\n</ul>\n</li>\n<li>性能优化<ul>\n<li>默认的Primary Shard数从5改为1，避免Over Sharding</li>\n<li>性能优化，更快的Top K</li>\n</ul>\n</li>\n</ul>\n","categories":["Elasticsearch"],"tags":["Elasticsearch"]},{"title":"Docker快速安装kafka","url":"http://www.shenjian.online/2019/06/23/Docker快速安装kafka/","content":"<p>同样基于docker-compose安装，<a href=\"https://shenjian.online/2019/06/09/Docker%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2nginx/\" target=\"_blank\" rel=\"noopener\">Docker快速部署nginx</a>中有讲到，不在重述</p>\n<h2 id=\"1-编写docker-compose-yml\"><a href=\"#1-编写docker-compose-yml\" class=\"headerlink\" title=\"1. 编写docker-compose.yml\"></a>1. 编写docker-compose.yml</h2><p>个人习惯放在/opt/下，如/opt/kafka, /opt/nginx, docker-compose.yml如下</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">'3'</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\"><span class=\"attr\">  zookeeper:</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">wurstmeister/zookeeper</span></span><br><span class=\"line\"><span class=\"attr\">    ports:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">\"2181:2181\"</span> <span class=\"comment\"># 端口不可省略，否则，docker会内部会随机分配端口，造成zk connected refused</span></span><br><span class=\"line\"><span class=\"attr\">  kafka:</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">wurstmeister/kafka</span></span><br><span class=\"line\"><span class=\"attr\">    ports:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">\"9092:9092\"</span></span><br><span class=\"line\"><span class=\"attr\">    environment:</span></span><br><span class=\"line\"><span class=\"attr\">      KAFKA_ADVERTISED_HOST_NAME:</span> <span class=\"number\">192.168</span><span class=\"number\">.153</span><span class=\"number\">.152</span> <span class=\"comment\"># 宿主IP地址，此为我虚拟机地址</span></span><br><span class=\"line\"><span class=\"attr\">      KAFKA_ZOOKEEPER_CONNECT:</span> <span class=\"attr\">zookeeper:2181</span></span><br><span class=\"line\"><span class=\"attr\">    volumes:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">/var/run/docker.sock:/var/run/docker.sock</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-启动kafka\"><a href=\"#2-启动kafka\" class=\"headerlink\" title=\"2. 启动kafka\"></a>2. 启动kafka</h2><p><code>docker-compose up -d</code></p>\n<p>Creating kafka_kafka_1     … done<br>Creating kafka_zookeeper_1 … done</p>\n<h2 id=\"3-消息生产消费验证\"><a href=\"#3-消息生产消费验证\" class=\"headerlink\" title=\"3. 消息生产消费验证\"></a>3. 消息生产消费验证</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">exec</span> -it kafka_kafka_1 /bin/bash <span class=\"comment\"># 进入kafka终端</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建test主题，副本1，分区1</span></span><br><span class=\"line\">kafka-topics.sh --create --topic <span class=\"built_in\">test</span> --zookeeper kafka_zookeeper_1:2181 --replication-factor 1 --partitions 1</span><br><span class=\"line\"></span><br><span class=\"line\">kafka-topics.sh --list --zookeeper kafka_zookeeper_1:2181 <span class=\"comment\"># 查看刚才创建的test分区</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 发布消息，输入几条消息后，按^C退出发布</span></span><br><span class=\"line\">kafka-console-producer.sh --topic=<span class=\"built_in\">test</span> --broker-list kafka_kafka_1:9092</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 接收消息</span></span><br><span class=\"line\">kafka-console-consumer.sh --bootstrap-server kafka_kafka_1:9092 --from-beginning --topic <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<p>如果正常的话，发布的消息能够接收到，开始愉悦的kafka之旅吧~~~</p>\n","categories":["Docker"],"tags":["Docker","Kafka"]},{"title":"AQS队列同步器实现分析","url":"http://www.shenjian.online/2019/06/22/AQS队列同步器实现分析/","content":"<h2 id=\"1-同步队列\"><a href=\"#1-同步队列\" class=\"headerlink\" title=\"1. 同步队列\"></a>1. 同步队列</h2><p>AQS内部依靠同步队列(FIFO双向队列)来管理同步状态，当线程获取同步状态失败时，AQS通过构造Node节点将线程加入同步队列，同步状态释放时，会把首节点的线程唤醒，使其再次尝试获取同步状态。</p>\n<h3 id=\"1-1-Node节点\"><a href=\"#1-1-Node节点\" class=\"headerlink\" title=\"1.1 Node节点\"></a>1.1 Node节点</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">\t    <span class=\"comment\">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CANCELLED =  <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIGNAL    = -<span class=\"number\">1</span>; <span class=\"comment\">// 后继节点的线程处于等待状态</span></span><br><span class=\"line\">        <span class=\"comment\">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CONDITION = -<span class=\"number\">2</span>; <span class=\"comment\">// 表明节点在等待队列中 当其他线程调用了Condition的singnal()方法后，该节点会转移至同步队列</span></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * waitStatus value to indicate the next acquireShared should</span></span><br><span class=\"line\"><span class=\"comment\">         * unconditionally propagate</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PROPAGATE = -<span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> waitStatus; <span class=\"comment\">// 等待状态(CANCELLED、SIGNAL、CONDITION、PROPAGATE) </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">volatile</span> Node prev;  <span class=\"comment\">// 前驱节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">volatile</span> Node next; <span class=\"comment\">// 后继节点</span></span><br><span class=\"line\">\t\tNode nextWaiter; <span class=\"comment\">// 等待队列中的后继节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">volatile</span> Thread thread; <span class=\"comment\">// 获取同步状态的线程</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2-节点加入同步队列\"><a href=\"#1-2-节点加入同步队列\" class=\"headerlink\" title=\"1.2 节点加入同步队列\"></a>1.2 节点加入同步队列</h3><p>线程获取同步状态失败后，构造为Node节点加入同步队列，主要通过CAS compareAndSetTail(Node except, Node update)设置尾节点。</p>\n<h3 id=\"1-3-节点移出同步队列\"><a href=\"#1-3-节点移出同步队列\" class=\"headerlink\" title=\"1.3 节点移出同步队列\"></a>1.3 节点移出同步队列</h3><p>同步队列首节点的线程在释放同步状态时(waitStatus=SINGAL)，将会唤醒后继节点，由于首节点为获取同步状态成功的线程，故无需CAS设置后续节点为首节点即可。</p>\n<h2 id=\"2-独占式同步状态获取与释放\"><a href=\"#2-独占式同步状态获取与释放\" class=\"headerlink\" title=\"2. 独占式同步状态获取与释放\"></a>2. 独占式同步状态获取与释放</h2><h2 id=\"3-共享式同步状态获取与释放\"><a href=\"#3-共享式同步状态获取与释放\" class=\"headerlink\" title=\"3. 共享式同步状态获取与释放\"></a>3. 共享式同步状态获取与释放</h2><h2 id=\"4-独占式超时获取同步状态\"><a href=\"#4-独占式超时获取同步状态\" class=\"headerlink\" title=\"4. 独占式超时获取同步状态\"></a>4. 独占式超时获取同步状态</h2>","categories":["多线程"],"tags":["多线程"]},{"title":"happens-before规则","url":"http://www.shenjian.online/2019/06/16/happens-before规则/","content":"<p>happends-before是JMM最核心的概念，理解happends-befores是理解JMM的关键。</p>\n<h2 id=\"1-happends-before关系定义如下\"><a href=\"#1-happends-before关系定义如下\" class=\"headerlink\" title=\"1. happends-before关系定义如下\"></a>1. happends-before关系定义如下</h2><p>1) 如果一个操作happends-before另一个操作，那么另一个操作执行的结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前<br>2) 两个操作之间存在happends-before关系，并不意味着java平台的具体实现必须要按happends-before关系执行的顺序来执行，如果重排序之后的执行结果，与按happends-before关系来执行的结果一致，那么这种重排序并不非法。</p>\n<h2 id=\"2-happends-before规则\"><a href=\"#2-happends-before规则\" class=\"headerlink\" title=\"2. happends-before规则\"></a>2. happends-before规则</h2><p>1) 程序顺序规则： <em>一个线程的每个操作，happends-before于该线程中任意的后续操作</em><br>2) 监视器锁规则： <em>对一个锁的解锁，happends-before于任意后续对这个锁的加锁</em><br>3) volatile变量规则： <em>对一个volatile的写，happends-before于任意后续对该volatile域的读</em><br>4) 传递性： 如果A happends-before B 且 B happends-before，那么 A happends before C<br>5) start()规则: 如果线程A执行操作ThreadB.start(),那么A线程的ThreadB.start()操作happends before于线程B的任意操作<br>6) join()规则：如果线程A执行操作ThreadB.join()方法并成功返回，则线程B中的任意操作happends before于线程A从ThreadB.join()操作成功返回</p>\n","categories":["多线程"],"tags":["多线程"]},{"title":"JAVA流实现文件批量打包下载","url":"http://www.shenjian.online/2019/06/11/JAVA流实现文件批量打包下载/","content":"<p>话不多说，直接撸代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">downloadFiles</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, String[] filePaths)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (filePaths == <span class=\"keyword\">null</span> || filePaths.length &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 设置响应头</span></span><br><span class=\"line\">       response.reset();</span><br><span class=\"line\">       response.setCharacterEncoding(<span class=\"string\">\"utf-8\"</span>);</span><br><span class=\"line\">       response.setContentType(<span class=\"string\">\"multipart/form-data\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 设置压缩包名称及不同浏览器中文乱码处理</span></span><br><span class=\"line\">       DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class=\"string\">\"yyyyMMddHHmmss\"</span>);</span><br><span class=\"line\">       LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class=\"line\">       String filename = <span class=\"string\">\"电子合同\"</span> + formatter.format(localDateTime) + <span class=\"string\">\".zip\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       String agent = request.getHeader(<span class=\"string\">\"AGENT\"</span>);</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (agent.contains(<span class=\"string\">\"MSIE\"</span>) || agent.contains(<span class=\"string\">\"Trident\"</span>)) &#123;</span><br><span class=\"line\">                   filename = URLEncoder.encode(filename, <span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               filename = <span class=\"keyword\">new</span> String(filename.getBytes(<span class=\"string\">\"UTF-8\"</span>), <span class=\"string\">\"ISO-8859-1\"</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       response.setHeader(<span class=\"string\">\"Content-Disposition\"</span>, <span class=\"string\">\"attachment;filename=\\\"\"</span> + filename  + <span class=\"string\">\"\\\"\"</span>); <span class=\"comment\">// key不区分大小写</span></span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 设置压缩流，直接写入response,实现边压缩边下载</span></span><br><span class=\"line\">           ZipOutputStream zipOutputStream = <span class=\"keyword\">new</span> ZipOutputStream(<span class=\"keyword\">new</span> BufferedOutputStream(response.getOutputStream()));</span><br><span class=\"line\">           zipOutputStream.setMethod(ZipOutputStream.DEFLATED);</span><br><span class=\"line\"></span><br><span class=\"line\">           DataOutputStream dataOutputStream = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">           <span class=\"keyword\">for</span> (String filePath : filePaths) &#123;</span><br><span class=\"line\">               String subFilename = formatter.format(LocalDateTime.now()) + filePath.substring(filePath.lastIndexOf(<span class=\"string\">\"/\"</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">               zipOutputStream.putNextEntry(<span class=\"keyword\">new</span> ZipEntry(subFilename));</span><br><span class=\"line\"></span><br><span class=\"line\">               dataOutputStream = <span class=\"keyword\">new</span> DataOutputStream(zipOutputStream);</span><br><span class=\"line\">               BufferedInputStream bufferedInputStream = <span class=\"keyword\">new</span> BufferedInputStream(<span class=\"keyword\">new</span> FileInputStream(<span class=\"keyword\">new</span> File(filePath)));</span><br><span class=\"line\">               <span class=\"keyword\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">8192</span>];</span><br><span class=\"line\">               <span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"keyword\">while</span> ((length = bufferedInputStream.read(buf)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                   dataOutputStream.write(buf, <span class=\"number\">0</span> , length);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               dataOutputStream.flush();</span><br><span class=\"line\">               <span class=\"comment\">// dataOutputStream.close(); 若在此关闭，对应资源zipOutputStream也将关闭，则压缩包内仅有一个文件</span></span><br><span class=\"line\">               bufferedInputStream.close();</span><br><span class=\"line\">               zipOutputStream.closeEntry();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           dataOutputStream.flush();</span><br><span class=\"line\">           dataOutputStream.close();</span><br><span class=\"line\">           zipOutputStream.close();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>","categories":["工作干货"],"tags":["工作干货"]},{"title":"Docker快速部署nginx","url":"http://www.shenjian.online/2019/06/09/Docker快速部署nginx/","content":"<p>默认读者已经安装好docker</p>\n<p>推荐使用docker-compose方式进行容器运行</p>\n<h1 id=\"1-安装docker-compose\"><a href=\"#1-安装docker-compose\" class=\"headerlink\" title=\"1. 安装docker-compose\"></a>1. 安装docker-compose</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -U docker-compose</span><br></pre></td></tr></table></figure>\n<p>安装后查看版本<code>docker-compose version</code></p>\n<h1 id=\"2-下载nginx\"><a href=\"#2-下载nginx\" class=\"headerlink\" title=\"2. 下载nginx\"></a>2. 下载nginx</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull nginx:stable-alpine <span class=\"comment\"># 建议下载稳定版本</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"3-编写docker-compose-yml文件\"><a href=\"#3-编写docker-compose-yml文件\" class=\"headerlink\" title=\"3.编写docker-compose.yml文件\"></a>3.编写docker-compose.yml文件</h1><p>我所创建文件位置为/opt/nginx/docker-compose.yml(docker-compose.yml文件名不可更改,否则docker-compose命令无法识别)</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">'2'</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\"><span class=\"attr\">  nginx:</span></span><br><span class=\"line\"><span class=\"attr\">    container_name:</span> <span class=\"string\">nginx</span> <span class=\"comment\"># 命名容器名称,便于容器管理</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"attr\">nginx:stable-alpine</span> <span class=\"comment\"># 刚才下载的nginx镜像</span></span><br><span class=\"line\"><span class=\"attr\">    network_mode:</span> <span class=\"string\">host</span></span><br><span class=\"line\"><span class=\"attr\">    restart:</span> <span class=\"string\">always</span> </span><br><span class=\"line\"><span class=\"attr\">    volumes:</span> <span class=\"comment\"># 目录挂载</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">/opt/nginx/nginx.conf:/etc/nginx/nginx.conf</span> </span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">/opt/nginx/conf.d:/etc/nginx/conf.d</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">/opt/nginx/cert:/etc/nginx/cert</span> </span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">/opt/nginx/html:/usr/share/nginx/html</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">/var/log/nginx:/var/log/nginx</span></span><br><span class=\"line\"><span class=\"attr\">    ports:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">\"80:80\"</span></span><br><span class=\"line\"><span class=\"attr\">    environment:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">NGINX_HOST=47.74.188.157</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">NGINX_PORT=80</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"4-下载并修改本地-opt-nginx-nginx-conf文件\"><a href=\"#4-下载并修改本地-opt-nginx-nginx-conf文件\" class=\"headerlink\" title=\"4.下载并修改本地/opt/nginx/nginx.conf文件\"></a>4.下载并修改本地/opt/nginx/nginx.conf文件</h1><p>在docker-compose.yml同级目录/opt/nginx下下载nginx.conf文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/nginx/nginx/blob/master/conf/nginx.conf</span><br></pre></td></tr></table></figure>\n<p>修改配置文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user root; <span class=\"comment\"># 第2行#user nobody修改为user root; 表示以root权限读取本地目录，否则报403错误</span></span><br><span class=\"line\"></span><br><span class=\"line\">include conf.d/*.conf; <span class=\"comment\"># 第16行新增该配置文件,便于多域名配置实现(下面很快说到)</span></span><br><span class=\"line\"></span><br><span class=\"line\">server_name  47.74.188.157 <span class=\"comment\"># 第37行左右修改server_name localhost 为本机IP地址</span></span><br></pre></td></tr></table></figure>\n<p>详情如图所示 <img src=\"/2019/06/09/Docker快速部署nginx/nginx.conf.png\" alt=\"nginx.conf\"></p>\n<h1 id=\"5-配置域名conf文件\"><a href=\"#5-配置域名conf文件\" class=\"headerlink\" title=\"5.配置域名conf文件\"></a>5.配置域名conf文件</h1><p>在/opt/nginx/conf.d目录新建文件shenjian.online.conf,如果有其他域名，则在该目录下新建即可，如996icu.online.conf</p>\n<p>shenjian.online.conf 配置如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> server &#123;</span><br><span class=\"line\">        listen       80;</span><br><span class=\"line\">        server_name  www.shenjian.online; <span class=\"comment\"># 所要使用的域名</span></span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">           root /usr/share/nginx/html; <span class=\"comment\"># 非/opt/nginx/html本地目录，而为docker容器nginx映射目录</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 相关配置请查看具体证书提供商如阿里云配置说明</span></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlisten 443 ssl;</span><br><span class=\"line\">\tserver_name www.shenjian.online; <span class=\"comment\"># localhost修改为您证书绑定的域名。</span></span><br><span class=\"line\">\tssl_certificate cert/shenjian.online.pem;   <span class=\"comment\"># 将domain name.pem替换成您证书的文件名。</span></span><br><span class=\"line\">\tssl_certificate_key cert/shenjian.online.key;   <span class=\"comment\"># 将domain name.key替换成您证书的密钥文件名。</span></span><br><span class=\"line\">\tssl_session_timeout 5m;</span><br><span class=\"line\">\tssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  <span class=\"comment\"># 使用此加密套件。</span></span><br><span class=\"line\">\tssl_protocols TLSv1 TLSv1.1 TLSv1.2;   <span class=\"comment\"># 使用该协议进行配置。</span></span><br><span class=\"line\">\tssl_prefer_server_ciphers on;   </span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\">\t\troot /usr/share/nginx/html; <span class=\"comment\"># 非/opt/nginx/html本地目录，而为docker容器nginx映射目录</span></span><br><span class=\"line\">\t\tindex index.html index.htm;  </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"6-证书文件导入-无则忽略\"><a href=\"#6-证书文件导入-无则忽略\" class=\"headerlink\" title=\"6. 证书文件导入(无则忽略)\"></a>6. 证书文件导入(无则忽略)</h1><p>新建目录,证书放置/opt/nginx/cert下</p>\n<h1 id=\"7-放置静态资源文件服务器\"><a href=\"#7-放置静态资源文件服务器\" class=\"headerlink\" title=\"7. 放置静态资源文件服务器\"></a>7. 放置静态资源文件服务器</h1><p>新建目录/opt/nginx/html，在目录下新建html文件，输入经典Hello World保存</p>\n<h1 id=\"8-运行并验证nginx\"><a href=\"#8-运行并验证nginx\" class=\"headerlink\" title=\"8. 运行并验证nginx\"></a>8. 运行并验证nginx</h1><p>在docker-compose.yml同级目录下运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose up -d <span class=\"comment\"># 以后台进程方式运行</span></span><br><span class=\"line\"></span><br><span class=\"line\">docker container ls <span class=\"comment\"># 查看容器nginx是否成功运行，若失败 `docker-compose logs` 查看失败原因</span></span><br><span class=\"line\"></span><br><span class=\"line\">docker-compose down <span class=\"comment\"># Stop and remove containers, networks, images, and volumes</span></span><br></pre></td></tr></table></figure>\n<p>浏览器输入 <a href=\"http://www.shenjian.online\">www.shenjian.online</a> , 经典的Hello World再次出现~~~~</p>\n<h1 id=\"9-目录结构相关图片\"><a href=\"#9-目录结构相关图片\" class=\"headerlink\" title=\"9. 目录结构相关图片\"></a>9. 目录结构相关图片</h1><p><img src=\"/2019/06/09/Docker快速部署nginx/dir.png\" alt=\"目录赏析\"></p>\n","categories":["Docker"],"tags":["Docker","Nginx"]},{"title":"Java并发机制底层实现原理之原子操作","url":"http://www.shenjian.online/2019/06/02/Java并发机制底层实现原理之原子操作/","content":"<h1 id=\"1-处理器层实现原子操作\"><a href=\"#1-处理器层实现原子操作\" class=\"headerlink\" title=\"1. 处理器层实现原子操作\"></a>1. 处理器层实现原子操作</h1><h2 id=\"1-1-使用总线锁保证原子性\"><a href=\"#1-1-使用总线锁保证原子性\" class=\"headerlink\" title=\"1.1 使用总线锁保证原子性\"></a>1.1 使用总线锁保证原子性</h2><p> 所谓总线锁,就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出该信号时，其他处理器的总线请求将被阻塞，呢么该处理器就可以独占共享内存</p>\n<h2 id=\"1-2-使用缓存锁保证原子性\"><a href=\"#1-2-使用缓存锁保证原子性\" class=\"headerlink\" title=\"1.2 使用缓存锁保证原子性\"></a>1.2 使用缓存锁保证原子性</h2><p> “缓存锁定”指内存区域如果被缓存在缓存行中，并且在Lock操作期间被锁定，呢么执行锁操作回写到内存时，修改内部的内存地址，并允许它的缓存一致性原理保证操作的原子性。</p>\n<p>当操作的数据不能被缓存在处理器内部或数据跨多个缓存行或处理器不支持缓存锁定，则不会使用缓存锁定，而使用总线锁定。</p>\n<p>针对以上两个机制，Inter处理器提供了很多Lock前缀的指令来实现。如位测试和修改指令：BTS、BTR、BTC;交换指令：XADD、CMPXCHG， 被这些指令操作的内存区域会被加锁，导致其他处理器不能访问</p>\n<h1 id=\"2-Java层实现原子操作\"><a href=\"#2-Java层实现原子操作\" class=\"headerlink\" title=\"2. Java层实现原子操作\"></a>2. Java层实现原子操作</h1><p>在Java中可以通过<strong>锁</strong>和<strong>CAS</strong>的方式来实现原子操作</p>\n<h2 id=\"2-1-使用循环CAS来实现原子操作\"><a href=\"#2-1-使用循环CAS来实现原子操作\" class=\"headerlink\" title=\"2.1 使用循环CAS来实现原子操作\"></a>2.1 使用循环CAS来实现原子操作</h2><p>JVM基于CAS操作正式利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路是：循环进行CAS操作直到成功为止</p>\n<h3 id=\"2-1-1-CAS实现原子操作的三大问题\"><a href=\"#2-1-1-CAS实现原子操作的三大问题\" class=\"headerlink\" title=\"2.1.1 CAS实现原子操作的三大问题\"></a>2.1.1 CAS实现原子操作的三大问题</h3><p><strong>ABA问题</strong> 如果一个值原本为A，变成了B，又变成了A，呢么使用CAS进行检查时会发现它的值没有改变。ABA的解决思路是使用版本号。JDK提供AtomicStampedReference解决ABA问题。<br><strong>循环时间长开销大</strong><br><strong>只能保证一个共享变量的原子操作</strong> JDK提供AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里进行CAS操作</p>\n<h2 id=\"2-2-使用锁机制实现原子操作\"><a href=\"#2-2-使用锁机制实现原子操作\" class=\"headerlink\" title=\"2.2 使用锁机制实现原子操作\"></a>2.2 使用锁机制实现原子操作</h2><p>JVM内部实现了偏向锁、轻量级锁、互斥锁。除了偏向锁，JVM实现锁的方式都采用了循环CAS</p>\n<p>ps：术语<br>原子操作： 不可被中断的一个或一系列操作</p>\n","categories":["多线程"],"tags":["多线程"]},{"title":"Java并发机制底层实现原理之synchronized","url":"http://www.shenjian.online/2019/06/01/Java并发机制底层实现原理之synchronized/","content":"<h1 id=\"1-synchronized实现同步的基础\"><a href=\"#1-synchronized实现同步的基础\" class=\"headerlink\" title=\"1. synchronized实现同步的基础\"></a>1. synchronized实现同步的基础</h1><p>java中的每一个对象都可以作为锁。具体有3种表现形式：</p>\n<ul>\n<li>普通的同步方法，锁是当前的实例对象</li>\n<li>静态的同步方法，锁是当前类class对象</li>\n<li>同步方法块，锁是synchronized括号里配置的对象</li>\n</ul>\n<h1 id=\"2-synchronized实现原理\"><a href=\"#2-synchronized实现原理\" class=\"headerlink\" title=\"2. synchronized实现原理\"></a>2. synchronized实现原理</h1><p>JVM基于进入和退出Monitor对象来实现方法同步与代码块同步，代码块同步是使用monitorenter和monitorexit指令来实现，而方法同步实现方式未在JVM规范中指出，但是也可以使用这两个指令实现。</p>\n<h1 id=\"3-synchronized锁存放位置\"><a href=\"#3-synchronized锁存放位置\" class=\"headerlink\" title=\"3. synchronized锁存放位置\"></a>3. synchronized锁存放位置</h1><p>synchronized锁存放在Java对象头里。如果对象是数组类型，则虚拟机用3个字宽(Word)存储对象头，如果对象是非数组类型，则用2个字宽存储对象头。32位虚拟机中，1字宽为4字节，即32bit<br>Java对象头里的Mark Word里默认存放的是HashCode、分代年龄和锁标记位。</p>\n<h1 id=\"4-synchronized锁的升级与对比\"><a href=\"#4-synchronized锁的升级与对比\" class=\"headerlink\" title=\"4. synchronized锁的升级与对比\"></a>4. synchronized锁的升级与对比</h1><p>在JDK1.6及以上，锁共有4中状态，级别从低到高一次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，这几个状态会根据竞争情况逐步升级，但不能降级(目的是为了提高获取锁和释放锁的效率)。</p>\n<h2 id=\"4-1-偏向锁\"><a href=\"#4-1-偏向锁\" class=\"headerlink\" title=\"4.1 偏向锁\"></a>4.1 偏向锁</h2><ul>\n<li><p>加锁： 把对象头与栈帧的锁记录里存储锁偏向的线程ID。以后进入时测试对象头Mark Word中是否存储了指向当前线程的偏向锁，如果成功，可重入，无需CAS操作进行加锁和释放锁；如果失败，则测试Mark Word中偏向锁的标识是否为1(表明当前是偏向锁)：如果没有，则使用CAS竞争，否则，使用CAS将对象头的偏向锁指向当前线程</p>\n</li>\n<li><p>解锁：需要等待全局安全点(在这个时间点上没有执行的字节码)。首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否存活，若否，则将对象头设为无锁状态；否则，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和Mark Word要么重新偏向其他线程，要么恢复为无锁或者标记为不适合为偏向锁，最后唤醒暂停的线程。</p>\n</li>\n<li><p>关闭： JVM参数设置： -XX:BiasedLockingStartupDelay=0 关闭延迟激活偏向锁 -XX UserBiasedLocking=false 关闭偏向锁</p>\n</li>\n</ul>\n<h2 id=\"4-2-轻量级锁\"><a href=\"#4-2-轻量级锁\" class=\"headerlink\" title=\"4.2 轻量级锁\"></a>4.2 轻量级锁</h2><ul>\n<li>加锁： 线程在执行同步代码块之前，会在当前线程栈帧中创建用于存储锁记录的空间，并将Mark Word复制到所记录中，并使用CAS尝试将Mark Word替换为指向所记录的指针。如果成功，当前线程获得锁，如果失败，则自旋获取锁。</li>\n<li>解锁： 使用CAS将Displaced Mark Word替换回对象头，若失败，则会膨胀为重量级锁</li>\n</ul>\n<h2 id=\"4-3-锁优缺点对比\"><a href=\"#4-3-锁优缺点对比\" class=\"headerlink\" title=\"4.3 锁优缺点对比\"></a>4.3 锁优缺点对比</h2><table>\n<thead>\n<tr>\n<th>锁</th>\n<th>优点</th>\n<th>缺点</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>偏向锁</td>\n<td>加锁和解锁不需要额外的消耗</td>\n<td>如果存在竞争，会带来额外解锁消耗</td>\n<td>适用一个线程访问同步块场景</td>\n</tr>\n<tr>\n<td>轻量级锁</td>\n<td>竞争的线程不会阻塞，提高程序响应速度</td>\n<td>始终得不到锁竞争的线程，自旋消耗CPU</td>\n<td>追求响应时间，同步块响应非常快</td>\n</tr>\n<tr>\n<td>重量级锁</td>\n<td>线程竞争不使用自旋，不会消耗CPU</td>\n<td>线程阻塞，响应时间慢</td>\n<td>追求吞吐量，同步块执行速度较长</td>\n</tr>\n</tbody>\n</table>\n","categories":["多线程"],"tags":["多线程"]},{"title":"IDEA常用快捷键","url":"http://www.shenjian.online/2019/05/29/IDEA常用快捷键/","content":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ctrl + F12  <span class=\"comment\"># 类方法查看</span></span><br><span class=\"line\"></span><br><span class=\"line\">Ctrl + H <span class=\"comment\"># 类关系查看</span></span><br><span class=\"line\"></span><br><span class=\"line\">Shift + F6 <span class=\"comment\"># 类重命名</span></span><br><span class=\"line\"></span><br><span class=\"line\">Alt + Enter <span class=\"comment\"># 导入包依赖</span></span><br></pre></td></tr></table></figure>\n","categories":["工具"],"tags":["工具"]},{"title":"ThreadPoolExecutor及ThreadFactory","url":"http://www.shenjian.online/2019/05/23/ThreadPoolExecutor及ThreadFactory/","content":"<h1 id=\"1-线程池工作原理使用场景\"><a href=\"#1-线程池工作原理使用场景\" class=\"headerlink\" title=\"1. 线程池工作原理使用场景\"></a>1. 线程池工作原理使用场景</h1><p><img src=\"/2019/05/23/ThreadPoolExecutor及ThreadFactory/工作原理.png\" alt=\"工作原理\"></p>\n<p>线程池的主要实现类是ThreadPoolExecutor</p>\n<p>使用场景：单个任务处理时间短；需处理的任务数量大</p>\n<h1 id=\"2-ThreadPoolExecutor构造参数详解\"><a href=\"#2-ThreadPoolExecutor构造参数详解\" class=\"headerlink\" title=\"2. ThreadPoolExecutor构造参数详解\"></a>2. ThreadPoolExecutor构造参数详解</h1><h2 id=\"2-1-corePoolSize与maximumPoolSize\"><a href=\"#2-1-corePoolSize与maximumPoolSize\" class=\"headerlink\" title=\"2.1 corePoolSize与maximumPoolSize\"></a>2.1 corePoolSize与maximumPoolSize</h2><p>ThreadPoolExecutor将根据corePoolSize与maximumPoolSize自动调整线程池的大小。当新任务在方法execute(java.lang.Runnable)中提交时<strong>如果池中当前运行线程数量少于corePoolSize,则新创建线程来处理请求，即使其他线程是空闲的;如果池中当前运行线程数量多于corePoolSize而小于maximumPoolSize,则仅当队列满时才新创建线程</strong>(由此可得，若队列无界，maximumPoolSize无效，池中线程数始终为corePoolSize；若队列有界，maximumPoolSize无界，则允许任意数量的并发)</p>\n<h2 id=\"2-2-keepAliveTime与timeUnit\"><a href=\"#2-2-keepAliveTime与timeUnit\" class=\"headerlink\" title=\"2.2 keepAliveTime与timeUnit\"></a>2.2 keepAliveTime与timeUnit</h2><p>池中线程数多于corePoolSize时，线程空闲时间超过以timeUnit为单位的时间keepAliveTime后，则终止，避免资源浪费。默认情况下，保持活动资源策略不应用于corePoolSizeThreads,但是只要keepAliveTime不为0，可以通过allowsCoreThreadTimeOut(boolean)方法将此超时策略应用于核心线程。</p>\n<h2 id=\"2-3-workQueue\"><a href=\"#2-3-workQueue\" class=\"headerlink\" title=\"2.3 workQueue\"></a>2.3 workQueue</h2><p>所有BlockingQueue都可用于传输与保持提交的任务，可以用此队列与池进行交互(以下称交互规则)：</p>\n<ul>\n<li>如果池中当前运行线程数少于corePoolSize,则Executor首选创建线程处理任务，而非将任务入队列</li>\n<li>如果池中当前运行线程数等于或多余corePoolSize,则Executor首选将任务入队列，而非田创建线程处理任务</li>\n<li>如果队列已满且线程数小于maximumPoolSize,则创建线程处理任务，除非线程数超过maximumPoolSize,则新任务被拒绝</li>\n</ul>\n<p>任务排队有三种策略：</p>\n<ul>\n<li>直接提交 工作队列的默认选项 SynchronousQueue，它将任务直接提交给线程而不是加入队列，如果不存在可以立即运行的线程则创建线程，故通常要求无界maximumPoolSizes以避免拒绝新任务。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。</li>\n<li>无界队列 如不具有预定义容量的 LinkedBlockingQueue,由于无界加对队列与池的交互规则，故池中当前运行线程数始终不会超过corePoolSize。在Web页处理器中，此策略可处理瞬态突发情况</li>\n<li>有界队列 如ArrayBlockingQueue有助于防止资源耗尽</li>\n</ul>\n<h2 id=\"2-4-threadFactory\"><a href=\"#2-4-threadFactory\" class=\"headerlink\" title=\"2.4 threadFactory\"></a>2.4 threadFactory</h2><p>使用ThreadFactory创建新线程。如果没有另外说明，则在同一个ThreadGroup中使用Executors.defaultThreadFactory创建线程，并且这些线程拥有相同的NORM_PRIORITY优先级和非守护进程状态。通过提供不同的ThreadGroup,可以改变线程的名称、线程组、优先级、守护进程状态。如果newThread返回null时ThreadFactory未能成功创建线程，则程序继续执行，但不能执行任何任务。</p>\n<h2 id=\"2-5-handler\"><a href=\"#2-5-handler\" class=\"headerlink\" title=\"2.5 handler\"></a>2.5 handler</h2><ul>\n<li>当有界队列已满且池中运行线程数等于maximumPoolSize</li>\n<li>Executor关闭<br>以上两种情况发生后，对于新任务，ThreadPoolExecutor.exceute方法将执行RejectedExecutionHandler的rejectedExecution(Runnable, ThreadPoolExecutor),有以下四种饱和策略：</li>\n</ul>\n<p><strong>中止策略(ThreadPoolExecutor.AbortPolicy):</strong> 该策略抛出未检查的RejectedExecutionException<br><strong>调用者运行策略(ThreadPoolExecutor.CallerRunsPolicy):</strong> 该策略不会抛弃任务，也不会抛出异常，而是把任务回退给调用者执行<br><strong>抛弃策略(ThreadPoolExecutor.DiscardPolicy):</strong> 抛弃任务不执行<br><strong>抛弃最旧策略(ThreadPoolExecutor.DiscardOldestPolicy):</strong> 抛弃队列中下一个被执行的任务。 由于优先队列下一任务为优先级高者，故不可与该策略结合使用</p>\n<h1 id=\"3-自定义ThreadFactory\"><a href=\"#3-自定义ThreadFactory\" class=\"headerlink\" title=\"3. 自定义ThreadFactory\"></a>3. 自定义ThreadFactory</h1><p><strong>在使用ThreadPoolExecutor的时候，建议编写自己的ThreadFactory,这样在使用jstack工具查看内存中线程时，可很容易看出线程所属线程池，这对于在生产环境中解决死锁问题非常有帮助</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NamedThreadFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ThreadFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger poolId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ThreadGroup threadGroup;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger threadId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String threadNamePrefix = <span class=\"string\">\"NamedThreadPool\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NamedThreadFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        poolId = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">        threadGroup = <span class=\"keyword\">new</span> ThreadGroup(<span class=\"string\">\"NamedThreadFactory\"</span>);</span><br><span class=\"line\">        threadId = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">        String name = threadNamePrefix + <span class=\"string\">\"-pool-\"</span> + poolId + <span class=\"string\">\"-thread-\"</span> + threadId.getAndIncrement();</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread(threadGroup, r, name);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> thread;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> corePoolSize = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maximumPoolSize = <span class=\"number\">4</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> keepAliveTime = <span class=\"number\">1000</span>;</span><br><span class=\"line\">        ThreadPoolExecutor threadPoolExecutor = <span class=\"keyword\">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize,</span><br><span class=\"line\">                keepAliveTime, TimeUnit.MILLISECONDS, <span class=\"keyword\">new</span> SynchronousQueue&lt;&gt;());</span><br><span class=\"line\">        threadPoolExecutor.setThreadFactory(<span class=\"keyword\">new</span> NamedThreadFactory());</span><br><span class=\"line\"></span><br><span class=\"line\">        Lock lockOne = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">        Lock lockTwo = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\">        threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">            lockOne.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            lockTwo.lock();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">            lockTwo.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            lockOne.lock();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先jps查看所有进程pid，jstack打印对应pid堆栈信息 jstack 1156 &gt; /opt/temp/dump，结果如下：</p>\n<p><img src=\"/2019/05/23/ThreadPoolExecutor及ThreadFactory/死锁示例.png\" alt=\"死锁示例\"></p>\n","categories":["多线程"],"tags":["多线程"]},{"title":"区块链架构","url":"http://www.shenjian.online/2019/05/19/区块链架构/","content":"<h1 id=\"1-区块链机构与传统IT架构区别\"><a href=\"#1-区块链机构与传统IT架构区别\" class=\"headerlink\" title=\"1. 区块链机构与传统IT架构区别\"></a>1. 区块链机构与传统IT架构区别</h1><p>去中心化</p>\n<h1 id=\"2-区块链架构模型\"><a href=\"#2-区块链架构模型\" class=\"headerlink\" title=\"2. 区块链架构模型\"></a>2. 区块链架构模型</h1><h2 id=\"2-1-区块链系统的共性\"><a href=\"#2-1-区块链系统的共性\" class=\"headerlink\" title=\"2.1 区块链系统的共性\"></a>2.1 区块链系统的共性</h2><p>(1) <strong>共识机制</strong> 我看到的就是你看到的，各个分布节点使用相同的共识算法可以得到对建模对象相同的认识，也可以确信其他人的认识和自己是一致的。<br>(2) <strong>状态可验证性</strong> 系统当前所有的状态都是确定性的，任何币的状态都可以被各自既定的确定性交易或流程规则所验证。<br>(3) <strong>唯一性</strong> 任何状态资产的消费只能发生一次，即区块链的防“双花”的安全性。<br>(4) <strong>不可篡改</strong> 密码学方式组织的区块链确保了已经提交到区块中的交易不可更改，否则会导致全盘修改。<br>(5) <strong>基于公/私钥的验证</strong> 区块链完全采用基于密码学的公/私钥方式通过签名来认证个人身份，所有的资产消费和验证也都围绕公/私钥进行。<br>(6) <strong>区块链治理</strong></p>\n<h2 id=\"2-2-区块链系统的差异性\"><a href=\"#2-2-区块链系统的差异性\" class=\"headerlink\" title=\"2.2 区块链系统的差异性\"></a>2.2 区块链系统的差异性</h2><p>(1) 共识主体不同 (2) 建模对象范围不同 (3) 建模对象操纵能力不同<br>(4) 法律法规支持程度不同 (5) 隐私和匿名性不同 (6) 交易延迟确认的不同<br>(7) 性能和可扩展性不同</p>\n<h1 id=\"3-区块链参考模型\"><a href=\"#3-区块链参考模型\" class=\"headerlink\" title=\"3. 区块链参考模型\"></a>3. 区块链参考模型</h1><h2 id=\"3-1-区块链高阶架构模型\"><a href=\"#3-1-区块链高阶架构模型\" class=\"headerlink\" title=\"3.1 区块链高阶架构模型\"></a>3.1 区块链高阶架构模型</h2><p>面向链合约服务的高阶层次化架构包括三大部分： 业务合约和账本、区块链平台服务、UI界面/API接口</p>\n<p>(1) <strong>业务合约和账本</strong> 整个区块链生态系统的核心就是要能支持各种契约，即业务合约，并在相关参与者间共享交易账本。<br>其分为合约流程、合约服务、合约代码、价值共享账本四大模块。<br>(2) <strong>区块链平台服务</strong> 区块链平台服务提供所有区块链平台层面的公共服务，平台服务同具体的业务无关，是可以为所有业务合约所共享的服务。各种平台服务可以是链上的，也可以是链外的。<br>区块链平台服务主要包括合约合规、安全控制、链上共识、链服务管理、治理(链上、链外)、开发运维。<br>(3) <strong>UI界面/API接口</strong><br>这部分是提供整个区块链服务对外的交互接口，主要包括个性化任务列表、个性化DApp、IoT协议适配和价值锚定、人工智能代理、开放API、业务合约浏览器、区块链浏览器、资产浏览器</p>\n<h2 id=\"3-2-区块链跨链本质与架构模型\"><a href=\"#3-2-区块链跨链本质与架构模型\" class=\"headerlink\" title=\"3.2 区块链跨链本质与架构模型\"></a>3.2 区块链跨链本质与架构模型</h2><p><strong>跨链的本质是价值等价交换</strong></p>\n<h2 id=\"3-3-区块链部署模型\"><a href=\"#3-3-区块链部署模型\" class=\"headerlink\" title=\"3.3 区块链部署模型\"></a>3.3 区块链部署模型</h2><p><strong>服务化、容器化</strong></p>\n<h1 id=\"4-区块链数据模型\"><a href=\"#4-区块链数据模型\" class=\"headerlink\" title=\"4. 区块链数据模型\"></a>4. 区块链数据模型</h1><p>数据模型的设计关乎整个区块链的并发性能</p>\n<p>(1) <strong>账户模型</strong> 账户模型对于建模数据的表达最直接，也形同于传统的“应用+数据库”的结构。账户模型将一个或多个账户实例的所有状态以key-value的形式组织起来，形成一定的存储结构，并以此为基础构建全局状态哈希树。以太坊记录各个账户状态就是采用账户模型。<br>(2) <strong>UTXO模型</strong> UTXO模型以比特币的数据模型为代表，只不过为花费交易状态输出的只有一个值：代币金额，代币金额总数在输入和输出上保持一致<br>UTXO的最大特色在于交易的并行处理能力：属于同一个转出账户的所有交易可以并行执行，只要童话一个交易不出现在同一个区块当中。另一个特点是UTXO数据库不会随着时间而膨胀，新的交易未花输出同时伴随着旧的交易未花输出的消费，所以基本上可以保持相对稳定的状态。<br>(3) <strong>混合模型</strong> 账户模型和UTXO模型可能会被结合起来来应用。以太坊的扩容方案–分区就是在账户模型的基础上使用UTXO模型进行跨分片的通信。</p>\n<h1 id=\"5-区块链能力模型\"><a href=\"#5-区块链能力模型\" class=\"headerlink\" title=\"5. 区块链能力模型\"></a>5. 区块链能力模型</h1><p>(1) 建模能力和业务自由度 (2) 共识主体范围 (3) 法律法规支持度<br>(4) 链安全(博弈经济) (5) 应用隔离 (6) 权限控制<br>(7) 易用性 (8)性能(吞吐量和确认时间) (9) 链治理(自动化程度)<br>(10) 跨链机制 (11) 隐私保护和匿名性</p>\n","categories":["区块链"],"tags":["区块链"]},{"title":"Markdown常用命令","url":"http://www.shenjian.online/2019/05/19/Markdown常用命令/","content":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![<span class=\"built_in\">wait</span>/nofity运行过程](<span class=\"built_in\">wait</span>-notify使用详解/WaitNotify运行过程.png) <span class=\"comment\"># 插入图片 [图片显示标识](图片所在包名/图片名)</span></span><br><span class=\"line\"></span><br><span class=\"line\">[沈健的技术博客](https://shenjian.online) <span class=\"comment\"># 插入链接</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 插入链接</span></span><br></pre></td></tr></table></figure>\n","categories":["工具"],"tags":["工具"]},{"title":"Git常用命令","url":"http://www.shenjian.online/2019/05/18/Git常用命令/","content":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在hexo目录下新建本地仓库(当前处于master分支)</span></span><br><span class=\"line\">$ git init</span><br><span class=\"line\">Initialized empty Git repository <span class=\"keyword\">in</span> D:/Project/java/hexo/.git/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为了便于管理，新建分支source,并从master切换至source分支</span></span><br><span class=\"line\"><span class=\"comment\">## 此步骤为 git branch source(新建分支) git checkout source(切换分支) 的合并</span></span><br><span class=\"line\">$ git checkout -b <span class=\"built_in\">source</span></span><br><span class=\"line\">Switched to a new branch <span class=\"string\">'source'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将当前目录下所有文件加入,以便commit</span></span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">warning: LF will be replaced by CRLF <span class=\"keyword\">in</span> package.json.</span><br><span class=\"line\">The file will have its original line endings <span class=\"keyword\">in</span> your working directory.</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提交所有的改变至本地仓库</span></span><br><span class=\"line\">$ git commit -m <span class=\"string\">'保存博客原文及配置至source分支'</span></span><br><span class=\"line\">[<span class=\"built_in\">source</span> (root-commit) 007ae29] 保存博客原文及配置至<span class=\"built_in\">source</span>分支</span><br><span class=\"line\"> 71 files changed, 7654 insertions(+)</span><br><span class=\"line\"> create mode 100644 .gitignore</span><br><span class=\"line\"> create mode 100644 1.txt</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\"># 查看commit日志</span></span><br><span class=\"line\"> $ git <span class=\"built_in\">log</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\"># 合并最近3条commit</span></span><br><span class=\"line\"> $ git rebase -i HEAD~3</span><br><span class=\"line\"> $ git rebase --<span class=\"built_in\">continue</span> <span class=\"comment\"># 继续rebase</span></span><br><span class=\"line\"> $ git rebase --abort <span class=\"comment\"># 中断本次rebase</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\"># 忽略文件夹下所有修改</span></span><br><span class=\"line\"> $ git update-index --skip-worktree src/main/resource</span><br><span class=\"line\"> <span class=\"comment\"># 查看忽略列表</span></span><br><span class=\"line\"> $ git ls-files -s</span><br><span class=\"line\"> <span class=\"comment\"># 恢复忽略</span></span><br><span class=\"line\"> $ git update-index --skip-worktree src/main/resource</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看本地仓库相关状态</span></span><br><span class=\"line\">$ git status</span><br><span class=\"line\">On branch <span class=\"built_in\">source</span></span><br><span class=\"line\">Changes not staged <span class=\"keyword\">for</span> commit:</span><br><span class=\"line\">  (use <span class=\"string\">\"git add &lt;file&gt;...\"</span> to update what will be committed)</span><br><span class=\"line\">  (use <span class=\"string\">\"git checkout -- &lt;file&gt;...\"</span> to discard changes <span class=\"keyword\">in</span> working directory)</span><br><span class=\"line\">  (commit or discard the untracked or modified content <span class=\"keyword\">in</span> submodules)</span><br><span class=\"line\"></span><br><span class=\"line\">        modified:   <span class=\"string\">\"source/_posts/Git\\345\\270\\270\\347\\224\\250\\345\\221\\275\\344\\273\\244.md\"</span></span><br><span class=\"line\">        modified:   themes/fexo (modified content, untracked content)</span><br><span class=\"line\"></span><br><span class=\"line\">no changes added to commit (use <span class=\"string\">\"git add\"</span> and/or <span class=\"string\">\"git commit -a\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有分支(包括本地分支与远程相关联分支) * 号代表当前所有分支</span></span><br><span class=\"line\">$ git branch -a</span><br><span class=\"line\">* <span class=\"built_in\">source</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将本地仓库与远程仓库相关联，以便push(origin为关联时设置的名称,可任意取值)</span></span><br><span class=\"line\">$ git remote add origin git@github.com:SJshenjian/SJshenjian.github.io.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看关联好的远程分支状态</span></span><br><span class=\"line\">$ git remote</span><br><span class=\"line\">origin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 与远程关联好后，没有执行 git pull，不会看到远程具体分支，如下结果所示(有时不需要pull,仅仅需要push)</span></span><br><span class=\"line\">$ git branch -a</span><br><span class=\"line\">* <span class=\"built_in\">source</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将本地分支source提交至远程仓库source分支</span></span><br><span class=\"line\"><span class=\"comment\">## source:source 第一个source为本地分支 第二个source为远程分支，远程不存在该分支则自动新建</span></span><br><span class=\"line\">$ git push origin <span class=\"built_in\">source</span>:<span class=\"built_in\">source</span></span><br><span class=\"line\">Counting objects: 88, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Delta compression using up to 8 threads.</span><br><span class=\"line\">Compressing objects: 100% (78/78), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Writing objects: 100% (88/88), 890.55 KiB | 1.01 MiB/s, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Total 88 (delta 0), reused 0 (delta 0)</span><br><span class=\"line\">remote:</span><br><span class=\"line\">remote: Create a pull request <span class=\"keyword\">for</span> <span class=\"string\">'source'</span> on GitHub by visiting:</span><br><span class=\"line\">remote:      https://github.com/SJshenjian/SJshenjian.github.io/pull/new/<span class=\"built_in\">source</span></span><br><span class=\"line\">remote:</span><br><span class=\"line\">To github.com:SJshenjian/SJshenjian.github.io.git</span><br><span class=\"line\"> * [new branch]      <span class=\"built_in\">source</span> -&gt; <span class=\"built_in\">source</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 再次查看所有分支状态(仅显示刚才新push的分支，说明远程分支仅在我们pull或者push后才可看到,且仅能看到相关联的，如远程master不涉及，就没有看到)</span></span><br><span class=\"line\">$ git branch -a</span><br><span class=\"line\">* <span class=\"built_in\">source</span></span><br><span class=\"line\">  remotes/origin/<span class=\"built_in\">source</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除误提交的远程文件夹(不删除本地)</span></span><br><span class=\"line\">$ git rm -r --cached 1</span><br><span class=\"line\">rm <span class=\"string\">'1/1.txt'</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ git commit -m <span class=\"string\">'删除错误提交'</span></span><br><span class=\"line\">[<span class=\"built_in\">source</span> 5726033] 删除错误提交</span><br><span class=\"line\"> 1 file changed, 1 deletion(-)</span><br><span class=\"line\"> delete mode 100644 1/1.txt</span><br><span class=\"line\"></span><br><span class=\"line\">$ git push origin <span class=\"built_in\">source</span>:<span class=\"built_in\">source</span></span><br><span class=\"line\">Counting objects: 2, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Delta compression using up to 8 threads.</span><br><span class=\"line\">Compressing objects: 100% (2/2), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Writing objects: 100% (2/2), 244 bytes | 0 bytes/s, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Total 2 (delta 1), reused 0 (delta 0)</span><br><span class=\"line\">remote: Resolving deltas: 100% (1/1), completed with 1 <span class=\"built_in\">local</span> object.</span><br><span class=\"line\">To github.com:SJshenjian/SJshenjian.github.io.git</span><br><span class=\"line\">   007ae29..5726033  <span class=\"built_in\">source</span> -&gt; <span class=\"built_in\">source</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除远程分支(为了测试，新建一个分支test1)</span></span><br><span class=\"line\">$ git push origin <span class=\"built_in\">source</span>:test1</span><br><span class=\"line\"></span><br><span class=\"line\">$ git push origin -d test1</span><br><span class=\"line\">To github.com:SJshenjian/SJshenjian.github.io.git</span><br><span class=\"line\"> - [deleted]         test1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 忽略ssl证书</span></span><br><span class=\"line\">git config --global http.sslVerify <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n","categories":["工具"],"tags":["Git"]},{"title":"区块链技术模型","url":"http://www.shenjian.online/2019/04/23/区块链技术模型/","content":"<p><img src=\"/2019/04/23/区块链技术模型/区块链技术模型.png\" alt=\"区块链技术模型\"></p>\n<p>如图所示，区块链技术模型包括9大部分，其中7层基础技术层和2各贯穿整个7层的共用技术。</p>\n<h2 id=\"1-数据存储层\"><a href=\"#1-数据存储层\" class=\"headerlink\" title=\"1. 数据存储层\"></a>1. 数据存储层</h2><p>区块链就像是一个个分布式账本，账本的账册通过链条链在一起，构成一连串的账本链(即区块链)。账本中的数据通过分布式方式(分布式文件系统或者分布式数据库)存储在不同节点。数据存储层主要包括<strong>数据区块</strong>的逻辑组织方式和使用<strong>链式结构</strong>与<strong>Markle树</strong>进行有效存储</p>\n<h3 id=\"1-1-数据区块\"><a href=\"#1-1-数据区块\" class=\"headerlink\" title=\"1.1 数据区块\"></a>1.1 数据区块</h3><p><img src=\"/2019/04/23/区块链技术模型/比特币区块基本结构.png\" alt=\"比特币区块基本结构\"></p>\n<p>数据区块由区块头和区块体两部分组成。<br>区块头主要包括区块版本号、前一个区块的哈希值、用于验证区块交易的一个总的哈希Merkle树根、时间戳、难度目标及一个用于证明工作量难度的随机数。<br>区块体主要包含该区块的所有交易信息和所用交易信息的Merkle数(树根除外，树根存在区块头内)</p>\n<h3 id=\"1-2-链式结构\"><a href=\"#1-2-链式结构\" class=\"headerlink\" title=\"1.2 链式结构\"></a>1.2 链式结构</h3><p>区块链应用的所有区块之间按照时间先后顺序链接成一个完整的链条。新创建的区块链接在最后一个区块后面。该单向链条被每个节点认可，有人想篡改几乎不可能，每一笔交易都可以向前溯源，找到其历史记录，具有安全和可验证性。</p>\n<h3 id=\"1-3-Merkle树及其基本原理\"><a href=\"#1-3-Merkle树及其基本原理\" class=\"headerlink\" title=\"1.3 Merkle树及其基本原理\"></a>1.3 Merkle树及其基本原理</h3><p>Merkle树是一种典型的二叉树或多叉树，他包含根节点、中间节点、叶子节点。根节点将保存在区块头中。根节点、中间节点、叶子节点是一组哈希值，叶子节点存储了该区块内的所有交易的初始哈希值，一个交易对应一个叶子节点。叶子节点两两哈希，得到上一层中间节点的哈希值，依次类推，得到根节点的哈希值。 只要有任一叶子节点的数据被修改了，则根节点哈希值一定会发生改变。因此，要判断区块体交易数据是否有修改，只需验证Merkle树的根节点即可。</p>\n<h2 id=\"2-网络通信层\"><a href=\"#2-网络通信层\" class=\"headerlink\" title=\"2. 网络通信层\"></a>2. 网络通信层</h2><p>区块链运行在去中心化的分布式网络，一般采用P2P的组网方式。</p>\n<h3 id=\"2-1-P2P网络\"><a href=\"#2-1-P2P网络\" class=\"headerlink\" title=\"2.1 P2P网络\"></a>2.1 P2P网络</h3><p>P2P，即peer-to-peer，又称“对等网络”，直接交换来共享计算机资源和服务。</p>\n<h3 id=\"2-2-链接方式\"><a href=\"#2-2-链接方式\" class=\"headerlink\" title=\"2.2 链接方式\"></a>2.2 链接方式</h3><p>当矿工生成一个有效区块后，且被其他矿工确认有效后，就可以链接到当前区块链的末尾，形成新的区块链主链。由于各计算节点以分布式并行计算来争取记账权的，所以可能会出现链条分叉的现象。<br>针对这种情况，区块链协议规定：当主链分叉时，计算节点总是选择链接到<strong>当前工作量证明最大的分支</strong>上，形成更长的新主链。</p>\n<h3 id=\"2-3-传播机制\"><a href=\"#2-3-传播机制\" class=\"headerlink\" title=\"2.3 传播机制\"></a>2.3 传播机制</h3><p>比特币的传播机制可简述如下：<br>1）发起比特币交易的节点将自己新创建的交易数据向全网其他节点进行广播<br>2）所有的节点将收集这些新的交易数据，并打包至自己的预创建的区块中<br>3）为了争夺记账的权力，每个节点努力工作，找到一个工作量的难度证明(PoW)<br>4) 一旦找到了工作量的难度证明，立即对全网进行广播<br>5）其他节点如果认可该工作量难度最大同时所有交易有效，呢么认可该节点创建的区块有效<br>6）一旦新创建的区块得到认可，则其他所有节点都将接受该区块，并将该区块加入自己区块链条的最后一个区块后。</p>\n<h3 id=\"2-4-共识机制\"><a href=\"#2-4-共识机制\" class=\"headerlink\" title=\"2.4 共识机制\"></a>2.4 共识机制</h3><p>比特币系统中区块链技术采用了基于PoW的共识机制。具体做法：在区块计算的最后一步要求解一个随机数，使区块的哈希函数值小于或等于某一目标哈希值，由于哈希函数的随机性和不可逆性，找到随机数的难度会很大。通常目标哈希值由多个前导0的数串构成。设置的前导零越多，目标哈希值设定的越小，找到符合随机数的难度就越大。比特币系统通过调整目标哈希值，通常将区块的时间动态控制在10分钟左右。</p>\n<h3 id=\"2-5-验证机制\"><a href=\"#2-5-验证机制\" class=\"headerlink\" title=\"2.5 验证机制\"></a>2.5 验证机制</h3><p>基于区块链应用事先达成的各种验证协议来进行，比如交易的格式、交易的数据结构、格式的语法结构、输入输出、数字签名的正确性等。</p>\n<h2 id=\"3-数据安全与隐私保护层\"><a href=\"#3-数据安全与隐私保护层\" class=\"headerlink\" title=\"3. 数据安全与隐私保护层\"></a>3. 数据安全与隐私保护层</h2><h3 id=\"3-1-时间戳\"><a href=\"#3-1-时间戳\" class=\"headerlink\" title=\"3.1 时间戳\"></a>3.1 时间戳</h3><p>基于‘去中心’的设计思路，没有一个具体的时间服务器，因此各个节点时间可能不一致。比特币区块链中规定各个节点不超过2小时的偏离。区块链中已各区块生成的顺序作为一个广义的时间戳服务，可以防止双重支付及溯源的作用。</p>\n<h3 id=\"3-2-哈希函数\"><a href=\"#3-2-哈希函数\" class=\"headerlink\" title=\"3.2 哈希函数\"></a>3.2 哈希函数</h3><p>哈希函数把输入数据按一定的算法计算出来，生成固定长度的摘要，即数字摘要。 数字摘要与输入数据一一对应，生成数字摘要容易，逆向计算出输入数据需要天文数字的计算量。</p>\n<h3 id=\"3-3-数据加密\"><a href=\"#3-3-数据加密\" class=\"headerlink\" title=\"3.3 数据加密\"></a>3.3 数据加密</h3><p><strong>对称加密</strong> </p>\n<p><strong>非对称加密</strong></p>\n<p>对称密钥安全传递技术：数字信封（公钥加密，私钥解密）<br>数字签名防抵赖技术：（私钥加密，公钥解密）</p>\n<h3 id=\"3-4-零知识证明\"><a href=\"#3-4-零知识证明\" class=\"headerlink\" title=\"3.4 零知识证明\"></a>3.4 零知识证明</h3><p>零知识证明指证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某一论断是正确的。<br>零知识证明实质上是两方或者多方的协议，即两方或者多方完成一项任务所需采取的一系列步骤。</p>\n<h3 id=\"3-5-区块链安全体系\"><a href=\"#3-5-区块链安全体系\" class=\"headerlink\" title=\"3.5 区块链安全体系\"></a>3.5 区块链安全体系</h3><p>1）物理网络安全 2）区块链数据安全<br>3）区块链应用系统安全 4）区块链密钥安全管理</p>\n<h3 id=\"3-6-隐私保护机制\"><a href=\"#3-6-隐私保护机制\" class=\"headerlink\" title=\"3.6 隐私保护机制\"></a>3.6 隐私保护机制</h3><p>交易信息或区块链<br>1）创建隐私保护算法 最典型 k-匿名算法 2）存储隐私保护算法<br>3）数据挖掘过程中隐私保护算法 4）用户使用过程中隐私保护算法</p>\n<h2 id=\"4-共识层\"><a href=\"#4-共识层\" class=\"headerlink\" title=\"4. 共识层\"></a>4. 共识层</h2><h3 id=\"4-1-工作量证明-PoW\"><a href=\"#4-1-工作量证明-PoW\" class=\"headerlink\" title=\"4.1 工作量证明 PoW\"></a>4.1 工作量证明 PoW</h3><p>Proof of Work基本思想是：通过完成一个有难度的任务来决定区块记账权。 一般来讲，任务的设计是很难计算答案的，但一旦知道答案，却很容易验证，而且难度还可以根据网上的算力来进行动态调整。</p>\n<p>如给定一个字符串‘Hello World’,比特币应用给出的工作量要求是在其后加一个叫girl的数值，将新的字符串进行双重SHA-256哈希计算，如果得到的哈希结果(以16进制的形式表示)是以一定数量的0开头的，则验证通过。 工作量证明相当耗费算力，所以小矿工抱团取暖，加入矿池，按提供的算力进行分配所得</p>\n<h3 id=\"4-2-权益证明-PoS\"><a href=\"#4-2-权益证明-PoS\" class=\"headerlink\" title=\"4.2 权益证明 PoS\"></a>4.2 权益证明 PoS</h3><p>PoS是点点币(PPC)最早采用的一种共识机制。PoS机制主要根据参与者手中持有代币的多少和时间长短(币龄)来决定出块记账权的概率，越多机会越大。<br>与PoW相比，优点能够大幅提高共识效率，降低共识成本，减少算力浪费。<br>缺点安全性比较差，节点可以低成本的分叉作恶，造成PoS公平性先天不足。</p>\n<h3 id=\"4-3-股份授权证明-DPoS\"><a href=\"#4-3-股份授权证明-DPoS\" class=\"headerlink\" title=\"4.3 股份授权证明 DPoS\"></a>4.3 股份授权证明 DPoS</h3><p>由于Pow与Pos的每个节点均可创建区块，这样共识节点多，效率相应差。DPoS是由被社区选举出来的可信账户(受托人)来创建，为了成为正式受托人，需要拉票，获取足够其他用户信任。<br>DPoS提高了传播效率，减少算力消耗，但存在可靠性与安全性隐患。</p>\n<h3 id=\"4-4-拜占庭容错机制\"><a href=\"#4-4-拜占庭容错机制\" class=\"headerlink\" title=\"4.4 拜占庭容错机制\"></a>4.4 拜占庭容错机制</h3><p>在确认共识是，结果并不代表大多数的人的意见。在已知有成员谋反的情况下，忠诚的将军在不受叛徒影响的情况下如何达成一致，拜占庭问题由此产生。</p>\n","categories":["区块链"],"tags":["区块链"]},{"title":"Docker运行常用软件命令","url":"http://www.shenjian.online/2019/04/21/Docker运行常用软件命令/","content":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动(系统为centos7）</span></span><br><span class=\"line\">systemctl start docker</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl status docker </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一个name为redis的容器并运行redis</span></span><br><span class=\"line\"><span class=\"comment\">## -p 主机端口：容器端口 --name 容器名 -v 挂载目录，规则与端口映射相同 -d 后台启动 redis-server 已配置文件启动redis --appendonly yes 开启redis持久化</span></span><br><span class=\"line\">docker run --name redis -p 6379:6379  -v /usr/<span class=\"built_in\">local</span>/docker/redis.conf:/etc/redis/redis.conf -v /usr/<span class=\"built_in\">local</span>/docker/data:/data -d redis:4.0 redis-server /etc/redis/redis.conf --requirepass password --appendonly yes</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一个name为mysql的容器运行mysql</span></span><br><span class=\"line\"><span class=\"comment\">## -e MYSQL\\_ROOT\\_PASSWORD=123456 设置登录密码为123456</span></span><br><span class=\"line\">docker run --name mysql -p 6379:6379 mysql:5.7 -e MYSQL\\_ROOT\\_PASSWORD=123456 -d </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出所有容器</span></span><br><span class=\"line\">docekr ps -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出已经上线的容器</span></span><br><span class=\"line\">docekr container ls</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入容器</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -it pid /bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出镜像</span></span><br><span class=\"line\">docker image ls</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将镜像push至远程仓库并在其他机器pull，如docker.io</span></span><br><span class=\"line\">docker login <span class=\"comment\">## 首先登陆</span></span><br><span class=\"line\"></span><br><span class=\"line\">docker tag mongo:4.0 haotu369/mongo:4.0 <span class=\"comment\">## 将本地镜像重命令为带有docker.io账号的形式，如我的账号为haotu369</span></span><br><span class=\"line\"></span><br><span class=\"line\">docker push haotu369/mongo:4.0 <span class=\"comment\">## push至远程仓库</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从远程仓库下载镜像</span></span><br><span class=\"line\">docker pull haotu369/mongo:4.0 <span class=\"comment\">## push至本地</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># springboot jar包运行</span></span><br><span class=\"line\">nohup java -jar XXX.jar --server.port=8081 &amp;</span><br></pre></td></tr></table></figure>","categories":["Docker"],"tags":["Docker"]},{"title":"Centos7下安装docker与docker-compose","url":"http://www.shenjian.online/2019/04/21/Centos7下安装docker与docker-compose/","content":"<h2 id=\"1-Docker-yum方式安装\"><a href=\"#1-Docker-yum方式安装\" class=\"headerlink\" title=\"1. Docker yum方式安装\"></a>1. Docker yum方式安装</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看系统版本 </span></span><br><span class=\"line\"><span class=\"comment\">## Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。 建议采用7，可能6.5会有依赖问题</span></span><br><span class=\"line\"><span class=\"comment\">## Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。</span></span><br><span class=\"line\">uname -r </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 移除旧版本</span></span><br><span class=\"line\">yum remove docker \\</span><br><span class=\"line\">                  docker-client \\</span><br><span class=\"line\">                  docker-client-latest \\</span><br><span class=\"line\">                  docker-common \\</span><br><span class=\"line\">                  docker-latest \\</span><br><span class=\"line\">                  docker-latest-logrotate \\</span><br><span class=\"line\">                  docker-logrotate \\</span><br><span class=\"line\">                  docker-selinux \\</span><br><span class=\"line\">                  docker-engine-selinux \\</span><br><span class=\"line\">                  docker-engine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装必要系统工具</span></span><br><span class=\"line\">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加软件源信息</span></span><br><span class=\"line\">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新yum缓存</span></span><br><span class=\"line\">yum makecache fast</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装docker-ce</span></span><br><span class=\"line\">yum install -y docker-ce</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动docker后台服务</span></span><br><span class=\"line\">systemctl start docker</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-docker-compose安装\"><a href=\"#2-docker-compose安装\" class=\"headerlink\" title=\"2. docker-compose安装\"></a>2. docker-compose安装</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装pip</span></span><br><span class=\"line\">yum install -y epel-release</span><br><span class=\"line\">yum install -y python-pip</span><br><span class=\"line\"></span><br><span class=\"line\">pip --version <span class=\"comment\"># 确认版本</span></span><br><span class=\"line\"></span><br><span class=\"line\">pip install --upgrade pip <span class=\"comment\"># 更新pip</span></span><br><span class=\"line\"></span><br><span class=\"line\">pip install docker-compose <span class=\"comment\"># 安装docker-compose</span></span><br><span class=\"line\"></span><br><span class=\"line\">docker-compose version <span class=\"comment\"># 查看版本</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-配置镜像加速器\"><a href=\"#3-配置镜像加速器\" class=\"headerlink\" title=\"3. 配置镜像加速器\"></a>3. 配置镜像加速器</h2><p><a href=\"https://cr.console.aliyun.com/?spm=a2c4g.11186623.2.13.1c2a11beryqiKB\" target=\"_blank\" rel=\"noopener\">容器镜像服务控制台</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># XXXXX 阿里云为你分配的加速地址</span></span><br><span class=\"line\">sudo mkdir -p /etc/docker</span><br><span class=\"line\">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class=\"string\">'EOF'</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"registry-mirrors\"</span>: [<span class=\"string\">\"&lt;your accelerate address&gt;\"</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\">sudo systemctl daemon-reload</span><br><span class=\"line\">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>\n<p>最后<code>chkconfig docker on</code>开机自启动，免得每次虚拟机关闭后手动启动 </p>\n","categories":["Docker"],"tags":["Docker"]},{"title":"互联网下半场的主角-区块链","url":"http://www.shenjian.online/2019/04/21/互联网下半场的主角-区块链/","content":"<p>互联网已经改变了生活的方方面面，带来工作效率大幅提升和生活极大便利，但另一方面，由于互联网依靠中心化机构建立信任，使得互联网日趋中心化，由此带来的数据垄断、隐私侵犯、权益分配不公平等问题也称为制约其发展的瓶颈。<br>“区块链”这一概念起源于2009年初诞生的比特币。其创新的去中心化的信任体系改变了传统互联网依托中心化机构建立和维护信任的机制。2019年达沃斯论坛上，来自全球的顶级区块链企业领袖认为，区块链技术是人类历史上第四次工业革命。</p>\n<h2 id=\"1-当代互联网的局限\"><a href=\"#1-当代互联网的局限\" class=\"headerlink\" title=\"1. 当代互联网的局限\"></a>1. 当代互联网的局限</h2><h3 id=\"1-1-网络信息安全\"><a href=\"#1-1-网络信息安全\" class=\"headerlink\" title=\"1.1 网络信息安全\"></a>1.1 网络信息安全</h3><p>黑客攻击、网上盗窃、网上欺诈、网络病毒等安全问题层出不穷。 在国外，美国大选候选人希拉里的邮件泄露事件直接影响到美国大选的进程。</p>\n<h3 id=\"1-2-数据版权\"><a href=\"#1-2-数据版权\" class=\"headerlink\" title=\"1.2 数据版权\"></a>1.2 数据版权</h3><p>许多网站采用网路爬虫技术自主抓取网络内容，缺乏对他人版权作品的甄别，引发大量侵权案例。</p>\n<h3 id=\"1-3-新的挑战\"><a href=\"#1-3-新的挑战\" class=\"headerlink\" title=\"1.3 新的挑战\"></a>1.3 新的挑战</h3><p>新一代互联网的七点是TCP/IP协议，解决了信息如何低成本、高效率传输的问题，却没有解决信息的信任问题。信任需要中心化的机构来建立和维持。由此派生而来的问题是互联网日趋中心化。中心化的问题是容易形成垄断，特别是数据垄断和隐私侵犯问题，同时也会出现单点故障、易受攻击等安全问题。因此，下一代互联网必须突破的是：<strong>怎样去中心化的建立全球范围内的互联网信任机制；如何让互联网演进到保证信息、价值安全，可靠传输的价值互联网。</strong></p>\n<h2 id=\"2-区块链的演化路径\"><a href=\"#2-区块链的演化路径\" class=\"headerlink\" title=\"2. 区块链的演化路径\"></a>2. 区块链的演化路径</h2><h3 id=\"2-1-区块链和互联网的意义\"><a href=\"#2-1-区块链和互联网的意义\" class=\"headerlink\" title=\"2.1 区块链和互联网的意义\"></a>2.1 区块链和互联网的意义</h3><p>一般意义上，我们把第一代互联网叫做“信息互联网”，BAT本质上都是基于信息互联网提供服务；区块链以其分布式账本结构、去中介化信任机制和不可篡改等技术特性，为“价值互联网”时代的到来提供了最核心的技术支持。</p>\n<h3 id=\"2-2-区块链概念的提出\"><a href=\"#2-2-区块链概念的提出\" class=\"headerlink\" title=\"2.2 区块链概念的提出\"></a>2.2 区块链概念的提出</h3><p>第一阶段：区块链1.0，已数字货币为起点的相关应用，主要包括已比特币为代表的虚拟货币，是区块链技术目前最成功的应用。<br>第二阶段：区块链2.0，由数字资产开启，可以理解为区块链为区块链技术在其他金融领域的运用，如银行间结算、跨境支付、股权登记转让等。<br>第三阶段：区块链3.0，将区块链应用的领域范围扩展到金融行业以外，涵盖备案管理、知识产权存证、物联网、教育应用和政府管理等诸多方面。</p>\n<h3 id=\"2-3-区块链的社会价值和意义\"><a href=\"#2-3-区块链的社会价值和意义\" class=\"headerlink\" title=\"2.3 区块链的社会价值和意义\"></a>2.3 区块链的社会价值和意义</h3><p>1）避免中心化的数据垄断和不公平问题<br>2）区块链可以让资产已信息化方式传输，脱离第三方中心化的背书，并通过区块链的共识机制，防止价值的重复转移(所谓‘双花<br>3）社会经济模式升级 一个全新的世界账本和崭新的共享经济</p>\n<p>PS: 内容参考摘自《区块链核心技术与应用》 邹军等著</p>\n","categories":["区块链"],"tags":["区块链"]},{"title":"Condition接口","url":"http://www.shenjian.online/2019/03/29/Condition接口/","content":"<h2 id=\"1-Condition基本介绍\"><a href=\"#1-Condition基本介绍\" class=\"headerlink\" title=\"1. Condition基本介绍\"></a>1. Condition基本介绍</h2><p>Condition接口主要与Lock接口配合使用，替代Object中监视器方法(wait、notify、notifyAll)</p>\n<p>我们知道，Object类中的wait、notify、notifyAll必须在同步代码块(synchronized)中调用，但我们用ReentrantLock替代了synchronized,因此无法直接调用wait等</p>\n<p>因此，为了实现这个功能，我们必须有另外一种替代机制，这就是Condition的作用</p>\n<h2 id=\"2-Condition接口方法与Object监视器主要方法对比\"><a href=\"#2-Condition接口方法与Object监视器主要方法对比\" class=\"headerlink\" title=\"2. Condition接口方法与Object监视器主要方法对比\"></a>2. Condition接口方法与Object监视器主要方法对比</h2><table>\n<thead>\n<tr>\n<th>Condition</th>\n<th>Object</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>await()</td>\n<td>wait()</td>\n<td>造成当前线程在接到信号或被中断之前一直处于等待状态</td>\n</tr>\n<tr>\n<td>await(long time, TimeUnit unit)</td>\n<td>wait(long timeout)</td>\n<td>造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态</td>\n</tr>\n<tr>\n<td>signal()</td>\n<td>notify()</td>\n<td>唤醒一个等待线程</td>\n</tr>\n<tr>\n<td>signalAll()</td>\n<td>notifyAll()</td>\n<td>唤醒所有等待线程</td>\n</tr>\n</tbody>\n</table>\n<p>类似于wait、notify、notifyAll必须在同步代码块中使用，Condition中的await、signal必须写在Lock.lock()和Lock.unlock()之间</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReentrantLock lock=new ReentrantLock();</span><br><span class=\"line\">Condition condition = lock.newCondition();</span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\">/*获取到锁之后才能调用以下方法</span><br><span class=\"line\">condition.await();</span><br><span class=\"line\">condition.signal();</span><br><span class=\"line\">condition.signalAll();*/</span><br><span class=\"line\">lock.unlock();</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-Lock与Condition实现生产者消费者\"><a href=\"#3-Lock与Condition实现生产者消费者\" class=\"headerlink\" title=\"3. Lock与Condition实现生产者消费者\"></a>3. Lock与Condition实现生产者消费者</h2><p>类似于wait/notify + synchronized实现生产者消费者，详见 <a href=\"https://sjshenjian.github.io/2019/03/19/wait-notify%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/\" target=\"_blank\" rel=\"noopener\">wait/notify使用详解</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Lock + Condition实现生产者消费者</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class ProducerConsumerByCondition &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        int maxSize = 10;</span><br><span class=\"line\">        final Lock lock = new ReentrantLock();</span><br><span class=\"line\">        final Condition notEmpty = lock.newCondition();</span><br><span class=\"line\">        final Condition notFull = lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread producer = new Thread(new ProducerByCondition(queue, maxSize, lock, notEmpty, notFull));</span><br><span class=\"line\">        producer.setName(<span class=\"string\">\"Producer\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread consumerOne = new Thread(new ConsumerByCondition(queue, maxSize, lock, notEmpty, notFull));</span><br><span class=\"line\">        consumerOne.setName(<span class=\"string\">\"ConsumerOne\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread consumerTwo = new Thread(new ConsumerByCondition(queue, maxSize, lock, notEmpty, notFull));</span><br><span class=\"line\">        consumerTwo.setName(<span class=\"string\">\"ConsumerTwo\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">        consumerOne.start();</span><br><span class=\"line\">        consumerTwo.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class ProducerByCondition implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Queue&lt;Integer&gt; queue;</span><br><span class=\"line\">    private int maxSize;</span><br><span class=\"line\">    final Lock lock;</span><br><span class=\"line\">    final Condition notEmpty;</span><br><span class=\"line\">    final Condition notFull;</span><br><span class=\"line\"></span><br><span class=\"line\">    public ProducerByCondition(Queue&lt;Integer&gt; queue, int maxSize, Lock lock, Condition notEmpty, Condition notFull) &#123;</span><br><span class=\"line\">        this.queue = queue;</span><br><span class=\"line\">        this.maxSize = maxSize;</span><br><span class=\"line\">        this.lock = lock;</span><br><span class=\"line\">        this.notEmpty = notEmpty;</span><br><span class=\"line\">        this.notFull = notFull;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</span><br><span class=\"line\">        Random random = new Random();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (queue.size() == maxSize) &#123;</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"Queue is full, Producer \"</span> + Thread.currentThread().getName() + <span class=\"string\">\" waiting\"</span>);</span><br><span class=\"line\">                        notFull.await();</span><br><span class=\"line\">                    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                int value = random.nextInt();</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"Producer \"</span> + value);</span><br><span class=\"line\">                queue.add(value);</span><br><span class=\"line\">                notEmpty.signalAll();</span><br><span class=\"line\"></span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    Thread.sleep(1000);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class ConsumerByCondition implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Queue&lt;Integer&gt; queue;</span><br><span class=\"line\">    private int maxSize;</span><br><span class=\"line\">    final Lock lock;</span><br><span class=\"line\">    final Condition notEmpty;</span><br><span class=\"line\">    final Condition notFull;</span><br><span class=\"line\"></span><br><span class=\"line\">    public ConsumerByCondition(Queue&lt;Integer&gt; queue, int maxSize, Lock lock, Condition notEmpty, Condition notFull) &#123;</span><br><span class=\"line\">        this.queue = queue;</span><br><span class=\"line\">        this.maxSize = maxSize;</span><br><span class=\"line\">        this.lock = lock;</span><br><span class=\"line\">        this.notEmpty = notEmpty;</span><br><span class=\"line\">        this.notFull = notFull;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (queue.isEmpty()) &#123;</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"Queue is empty, Consumer \"</span> + Thread.currentThread().getName() + <span class=\"string\">\" waiting\"</span>);</span><br><span class=\"line\">                        notEmpty.await();</span><br><span class=\"line\">                    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">\" consume \"</span> + queue.remove());</span><br><span class=\"line\">                notFull.signalAll();</span><br><span class=\"line\"></span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    Thread.sleep(1000);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["多线程"],"tags":["多线程"]},{"title":"Lock接口和ReentrantLock","url":"http://www.shenjian.online/2019/03/29/Lock接口和ReentrantLock/","content":"<h2 id=\"1-Lock接口的特性\"><a href=\"#1-Lock接口的特性\" class=\"headerlink\" title=\"1. Lock接口的特性\"></a>1. Lock接口的特性</h2><p>Lock接口提供的synchronized所不具备的主要特性：</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>尝试非阻塞的获取锁</td>\n<td>当线程尝试获取锁，如果该锁没有被其他线程持有，则成功获取并持有锁</td>\n</tr>\n<tr>\n<td>能被中断的获取锁</td>\n<td>与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，抛出中断异常，同时锁被释放</td>\n</tr>\n<tr>\n<td>超时获取锁</td>\n<td>在指定的时间内获取锁，如果超过了指定时间，则返回</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-Lock接口的API\"><a href=\"#2-Lock接口的API\" class=\"headerlink\" title=\"2. Lock接口的API\"></a>2. Lock接口的API</h2><table>\n<thead>\n<tr>\n<th>方法名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>void lock()</td>\n<td>获取锁，调用该方法当前线程会获取锁，当锁获得后，该方法返回</td>\n</tr>\n<tr>\n<td>void lockInterruptibly() throws InterruptedException</td>\n<td>可中断的获取锁，和lock()方法不同之处在于该方法会响应中断，即在锁的获取中可以中断当前线程</td>\n</tr>\n<tr>\n<td>boolean tryLock()</td>\n<td>尝试非阻塞的获取锁，调用该方法后立即返回。如果能够获取到返回true，否则返回false</td>\n</tr>\n<tr>\n<td>boolean tryLock(long time, TimeUnit unit) throws InterruptedException</td>\n<td>超时获取锁，当前线程在以下三种情况下会被返回:当前线程在超时时间内获取了锁 当前线程在超时时间内被中断 超时时间结束，返回false</td>\n</tr>\n<tr>\n<td>void unlock()</td>\n<td>释放锁</td>\n</tr>\n<tr>\n<td>Condition newCondition()</td>\n<td>获取等待通知组件，该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的wait()方法，而调用后，当前线程将释放锁</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-Lock接口类图\"><a href=\"#3-Lock接口类图\" class=\"headerlink\" title=\"3. Lock接口类图\"></a>3. Lock接口类图</h2><p><img src=\"/2019/03/29/Lock接口和ReentrantLock/Lock接口类图.png\" alt=\"Lock接口类图\"></p>\n<h2 id=\"4-Lock接口使用的模板方法\"><a href=\"#4-Lock接口使用的模板方法\" class=\"headerlink\" title=\"4. Lock接口使用的模板方法\"></a>4. Lock接口使用的模板方法</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Lock lock = new ReentrantLock();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        lock.lock();//获取锁</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            lock.unlock();//释放锁</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不要将锁的获取过程写在try块中。因为如果在获取锁(自定义锁的实现)时，发生了异常，异常抛出的同时，也会导致锁的无故释放。</p>\n<h2 id=\"5-ReentrantLock内部组成\"><a href=\"#5-ReentrantLock内部组成\" class=\"headerlink\" title=\"5. ReentrantLock内部组成\"></a>5. ReentrantLock内部组成</h2><p>ReentrantLock支持公平锁(FairSync)与非公平锁(NonfairSync)。new ReentrantLock()，事实上使用的就是非公平锁</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public <span class=\"function\"><span class=\"title\">ReentrantLock</span></span>() &#123;</span><br><span class=\"line\">    sync = new NonfairSync();//非公平锁</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所谓非公平，指的是多个线程同时尝试获取一个锁时，可能会多次被同一个线程获取。实际中公平锁吞吐量比非公平锁小很多，因此我们大多数情况下使用的都是非公平锁。当持有锁的时间较长，或者请求锁的平均时间间隔较长，那么应该使用公平锁。</p>\n<p>ReentrantLock内部维护了一个Sync成员对象，其是FairSync和NonfairSync的抽象父类。表面上看锁的功能是由ReentrantLock实现的，实际是由其内部的私有变量Sync来完成的，根据是否需要是公平锁，给Sync提供不同的具体实现。</p>\n<h2 id=\"6-synchronized和ReentrantLock之间的选择\"><a href=\"#6-synchronized和ReentrantLock之间的选择\" class=\"headerlink\" title=\"6. synchronized和ReentrantLock之间的选择\"></a>6. synchronized和ReentrantLock之间的选择</h2><p>ReentrantLock提供了synchronized以外的功能：定时的锁等待、可中断的锁等待、公平性以及非块结构的加锁；<br>synchronized简单易用，ReentrantLock危险性更高，如果finally块中忘记调用unlock,则埋下定时炸弹；<br>synchronized还有另一优点，在线程转储中能给出哪些调用帧中获取了哪些锁，并能检测和识别发生死锁的线程，而ReentrantLock在JDK1.6后才支持将其注册进一个管理和调试接口，从而使ReentrantLock相关的加锁信息出现在线程转储中；</p>\n","categories":["多线程"],"tags":["多线程"]},{"title":"AbstractQueuedSynchronizer简介与使用","url":"http://www.shenjian.online/2019/03/27/AbstractQueuedSynchronizer简介与使用/","content":"<p>AbstractQueuedSynchronizer是并发包中最核心的类，没有之一，它是在LockSupport与Unsafe的基础上实现的。<br>AQS使用的主要方式是继承，我们编写一个类继承AbstractQueuedSynchronizer，重写特定的方法，来实现不同功能的同步组件。</p>\n<h3 id=\"1-同步组件简介\"><a href=\"#1-同步组件简介\" class=\"headerlink\" title=\"1. 同步组件简介\"></a>1. 同步组件简介</h3><p>同步组件从总体可分为两种：</p>\n<p><strong>独占式同步组件(又称独占锁)：</strong> 在任何时刻只有一个线程获得锁，可以执行，其他线程阻塞，进入等待队列。</p>\n<p><strong>共享式同步组件(又称共享锁)：</strong> 共享锁允许多个线程同时执行，通常情况下，共享锁内部维护了多个执行许可，每个线程运行的时候获得一个许可，结束的时候释放一个许可，如果共享锁已经没有了许可，则线程进入等待队列</p>\n<p>注意：可以认为独占锁是共享锁的一个特例，只有一个许可。<br>从这个角度理解的话，独占锁与共享锁都应该提供<strong>获取许可</strong>与<strong>释放许可</strong>的功能。</p>\n<p><strong>获取许可：</strong> 如果线程获取许可成功，则有执行的权力，许可数量-1，获取失败，则阻塞，进入等待队列<br><strong>释放许可：</strong> 拥有执行许可的线程运行结束后，则释放许可，许可数量+1，同时负责唤醒等待队列中的线程</p>\n<p>可以看到，在获取许可和释放许可的过程中，有两个重要的内容需要维护：可用许可的数量、等待队列</p>\n<h3 id=\"2-AQS支持同步组件原理\"><a href=\"#2-AQS支持同步组件原理\" class=\"headerlink\" title=\"2. AQS支持同步组件原理\"></a>2. AQS支持同步组件原理</h3><p>队列同步器AbstractQueuedSynchronizer作为构建同步组件的基础框架。支持独占式的获取同步状态，也支持共享式获取同步状态。ReentryLock、ReentryReadWriteLock、CountDownLatch等都是在AQS的基础上实现的。</p>\n<p>AQS对可用许可数量与等待队列均提供了支持：</p>\n<p><strong>可用许可数量的支持：</strong> 它使用了int类型state变量表示执行许可，初始状态为0，我们限定许可数量为5个，线程获取到一个许可，state+1, 表明已经使用了几个许可<br><strong>等待队列的支持：</strong> 通过内置的FIFO队列来完成线程的排队工作，队列的节点通过静态内部类Node实现</p>\n<p>需要注意的是，AQS对等待队列是完全支持的，也就是对开发者完全屏蔽了阻塞线程入队与出对的操作细节；；而对可用数量(state)提供了部分支持，需要开发者重写特定的方法才能正常工作</p>\n<p>AQS中定义了8个模板方法，对应4个需要开发者覆写的方法：</p>\n<table>\n<thead>\n<tr>\n<th>组件类型</th>\n<th>模板方法</th>\n<th>需要覆写的方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>独占式同步组件</td>\n<td>void acquire(int arg)</td>\n<td>boolean tryAcquire(int arg)</td>\n</tr>\n<tr>\n<td></td>\n<td>void acquireInterruptibly(int arg)</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>boolean tryAcquireNanos(int arg, long nanosTimeout)</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>boolean release(int arg)</td>\n<td>boolean tryRelease(int arg)</td>\n</tr>\n<tr>\n<td>共享式同步组件</td>\n<td>void acquireShared(int arg)</td>\n<td>boolean tryAcquireShared(int arg)</td>\n</tr>\n<tr>\n<td></td>\n<td>void acquireSharedInterruptibly(int arg)</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>boolean releaseShared(int arg)</td>\n<td>boolean tryReleaseShared(int arg)</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"3-编写同步组件需要注意的地方\"><a href=\"#3-编写同步组件需要注意的地方\" class=\"headerlink\" title=\"3. 编写同步组件需要注意的地方\"></a>3. 编写同步组件需要注意的地方</h3><p>1)使用新的接口和实现包装同步组件：在我们编写一个同步组件的时候，例如我们想实现一个独占锁，假设为Sync，其继承了AQS。只需要在Sync类中覆写tryRelease和tryAcquire即可，但是由于继承AQS的时候，会把tryAcquireShared、tryReleaseShared等共享锁方法也继承下来。而Sync并不会实现这些共享式同步组件的方法，因为Sync只是一个独占锁而已，从业务含义上，因此应该将这些方法屏蔽，从而防止用户误操作。按照最佳实现，屏蔽的方式是定义一个新的接口，假设用Mutex表示，这个接口只定义了独占锁相关方法，再编写一个类MutexImpl实现Mutex接口，而对于同步组件Sync类的操作，都封装在MutexImpl中。</p>\n<p>2)同步组件推荐定义为静态内部类：因为某个同步组件通常是为实现特定的目的而实现，可能只适用于特定的场合。如果某个同步组件不具备通用性，我们应该将其定义为一个私有的静态内部类。结合第一点，我们编写的同步组件Sync应该是MutexImpl的一个私有的静态内部类。</p>\n<h3 id=\"4-基于AQS实现独占锁示例\"><a href=\"#4-基于AQS实现独占锁示例\" class=\"headerlink\" title=\"4. 基于AQS实现独占锁示例\"></a>4. 基于AQS实现独占锁示例</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Mutex &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    void acquire();</span><br><span class=\"line\"></span><br><span class=\"line\">    void release();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MutexImpl implements Mutex &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Sync sync = new Sync();</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">acquire</span></span>() &#123;</span><br><span class=\"line\">        sync.acquire(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">release</span></span>() &#123;</span><br><span class=\"line\">        sync.release(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected boolean tryAcquire(int arg) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> super.compareAndSetState(0, 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected boolean tryRelease(int arg) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> super.compareAndSetState(1, 0);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Main &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Mutex mutex = new MutexImpl();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            new Thread(new MutexThread(mutex)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class MutexThread implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Mutex mutex;</span><br><span class=\"line\"></span><br><span class=\"line\">    public MutexThread(Mutex mutex) &#123;</span><br><span class=\"line\">        this.mutex = mutex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</span><br><span class=\"line\">        String name = Thread.currentThread().getName();</span><br><span class=\"line\">        mutex.acquire();</span><br><span class=\"line\">        System.out.println(name + <span class=\"string\">\"获得锁开始执行\"</span>);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(1000);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            mutex.release();</span><br><span class=\"line\">            System.out.println(name + <span class=\"string\">\"释放锁结束运行\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread-0获得锁开始执行</span><br><span class=\"line\">Thread-1获得锁开始执行</span><br><span class=\"line\">Thread-0释放锁结束运行</span><br><span class=\"line\">Thread-2获得锁开始执行</span><br><span class=\"line\">Thread-1释放锁结束运行</span><br><span class=\"line\">Thread-2释放锁结束运行</span><br><span class=\"line\">Thread-4获得锁开始执行</span><br><span class=\"line\">Thread-4释放锁结束运行</span><br><span class=\"line\">Thread-3获得锁开始执行</span><br><span class=\"line\">Thread-3释放锁结束运行</span><br><span class=\"line\">Thread-5获得锁开始执行</span><br><span class=\"line\">Thread-5释放锁结束运行</span><br><span class=\"line\">Thread-6获得锁开始执行</span><br><span class=\"line\">Thread-6释放锁结束运行</span><br><span class=\"line\">Thread-7获得锁开始执行</span><br><span class=\"line\">Thread-7释放锁结束运行</span><br><span class=\"line\">Thread-8获得锁开始执行</span><br><span class=\"line\">Thread-8释放锁结束运行</span><br><span class=\"line\">Thread-9获得锁开始执行</span><br><span class=\"line\">Thread-9释放锁结束运行</span><br></pre></td></tr></table></figure>","categories":["多线程"],"tags":["多线程","设计模式"]},{"title":"LockSupport简介及使用","url":"http://www.shenjian.online/2019/03/25/LockSupport简介与使用/","content":"<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h3><p>LockSupport是JDK中比较底层的类，是用来创建锁和其他同步工具类的线程阻塞基本原语。<br>JAVA锁和同步工具类的核心AQS: abstractQueuedSynchronizer就是通过调用LockSupport的park()和unpark()实现阻塞和唤醒的。</p>\n<p>LockSupport很类似于二元信号量(只有一个许可证可使用)，如果这个许可还没有被占用，当前线程获取许可并继续执行；如果许可已经被占用，当前线程阻塞，等待获取许可</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LockSupport.park(); // 获取许可</span><br><span class=\"line\">LockSupport.unpark(); // 释放许可</span><br></pre></td></tr></table></figure>\n<p>特别注意：</p>\n<p><strong>许可默认是占用的</strong><br><strong>许可是不可重入的</strong><br><strong>许可是可以响应中断的</strong></p>\n<h3 id=\"2-源码分析\"><a href=\"#2-源码分析\" class=\"headerlink\" title=\"2. 源码分析\"></a>2. 源码分析</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class LockSupport &#123;</span><br><span class=\"line\">\tprivate <span class=\"function\"><span class=\"title\">LockSupport</span></span>() &#123;&#125; // Cannot be instantiated.</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void setBlocker(Thread t, Object arg) &#123;</span><br><span class=\"line\">        UNSAFE.putObject(t, parkBlockerOffset, arg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     public static void unpark(Thread thread) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (thread != null)</span><br><span class=\"line\">            UNSAFE.unpark(thread);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void park(Object blocker) &#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        setBlocker(t, blocker);</span><br><span class=\"line\">        UNSAFE.park(<span class=\"literal\">false</span>, 0L);</span><br><span class=\"line\">        setBlocker(t, null);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static Object getBlocker(Thread t) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == null)</span><br><span class=\"line\">            throw new NullPointerException();</span><br><span class=\"line\">        <span class=\"built_in\">return</span> UNSAFE.getObjectVolatile(t, parkBlockerOffset);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void <span class=\"function\"><span class=\"title\">park</span></span>() &#123;</span><br><span class=\"line\">        UNSAFE.park(<span class=\"literal\">false</span>, 0L);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final sun.misc.Unsafe UNSAFE;</span><br><span class=\"line\">    private static final long parkBlockerOffset;</span><br><span class=\"line\"></span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class=\"line\">            Class&lt;?&gt; tk = Thread.class;</span><br><span class=\"line\">            parkBlockerOffset = UNSAFE.objectFieldOffset</span><br><span class=\"line\">                (tk.getDeclaredField(<span class=\"string\">\"parkBlocker\"</span>));</span><br><span class=\"line\">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-1-parkBlocker作用\"><a href=\"#2-1-parkBlocker作用\" class=\"headerlink\" title=\"2.1 parkBlocker作用\"></a>2.1 parkBlocker作用</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Thread implements Runnable &#123;</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">     * The argument supplied to the current call to</span><br><span class=\"line\">     * java.util.concurrent.locks.LockSupport.park.</span><br><span class=\"line\">     * Set by (private) java.util.concurrent.locks.LockSupport.setBlocker</span><br><span class=\"line\">     * Accessed using java.util.concurrent.locks.LockSupport.getBlocker</span><br><span class=\"line\">     */</span><br><span class=\"line\">    volatile Object parkBlocker;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>parkBlocker是用来记录线程是谁阻塞的，常用于监控与分析线程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">    Thread theadOne = new Thread(() -&gt; &#123;</span><br><span class=\"line\">        LockSupport.park(<span class=\"string\">\"I'm the blocker\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    theadOne.start();</span><br><span class=\"line\"></span><br><span class=\"line\">    Thread.sleep(1000);</span><br><span class=\"line\">    System.out.println(LockSupport.getBlocker(theadOne));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">I<span class=\"string\">'m the blocker</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"2-2-parkBlockerOffset作用\"><a href=\"#2-2-parkBlockerOffset作用\" class=\"headerlink\" title=\"2.2 parkBlockerOffset作用\"></a>2.2 parkBlockerOffset作用</h5><p><code>parkBlockerOffset = UNSAFE.objectFieldOffset(tk.getDeclaredField(&quot;parkBlocker&quot;));</code> 偏移量就是该Thread中变量parkBlocker在内存中的偏移量。<br>对于<code>getBlocker(Thread t)</code>方法，对于阻塞的线程，不会响应线程内的方法调用，只有通过内存方式<code>UNSAFE.getObjectVolatile(t, parkBlockerOffset)</code>进行获取阻塞对象。</p>\n","categories":["多线程"],"tags":["多线程"]},{"title":"Unsafe简介与使用","url":"http://www.shenjian.online/2019/03/25/Unsafe简介与使用/","content":"<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h3><p>Unsafe类可以操作JAVA内存，操作的是直接内存区，没有办法通过HotSpot的GC进行垃圾回收，需要手动进行回收，所以在使用时要特别注意内存泄漏与内存溢出。</p>\n<p>这是一个平台相关的类，在实际的开发工作中，建议不要使用</p>\n<h3 id=\"2-实例化Unsafe\"><a href=\"#2-实例化Unsafe\" class=\"headerlink\" title=\"2. 实例化Unsafe\"></a>2. 实例化Unsafe</h3><p>Unsafe类提供了一个静态方法getUnsafe()方法获取Unsafe的实例，但是如果直接调用该类，会报出SecurityException异常，因为该类只被JDK信任的类使用。<br>但是我们可以采用反射的方法进行实例化。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Field field = Unsafe.class.getDeclaredField(<span class=\"string\">\"theUnsafe\"</span>);</span><br><span class=\"line\">field.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">Unsafe unsafe = (Unsafe) field.get(null);</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-为基本类型变量设值\"><a href=\"#3-为基本类型变量设值\" class=\"headerlink\" title=\"3. 为基本类型变量设值\"></a>3. 为基本类型变量设值</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int index = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123;</span><br><span class=\"line\">        Field field = Unsafe.class.getDeclaredField(<span class=\"string\">\"theUnsafe\"</span>);</span><br><span class=\"line\">        field.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        Unsafe unsafe = (Unsafe) field.get(null);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 获取字段在内存中的偏移量</span><br><span class=\"line\">        long offset = unsafe.objectFieldOffset(Test.class.getDeclaredField(<span class=\"string\">\"index\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        Test <span class=\"built_in\">test</span> = new Test();</span><br><span class=\"line\"></span><br><span class=\"line\">        unsafe.putInt(<span class=\"built_in\">test</span> ,offset, 100);</span><br><span class=\"line\">        System.out.println(test.index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果： <code>100</code></p>\n<h3 id=\"4-创建构造函数私有的类实例\"><a href=\"#4-创建构造函数私有的类实例\" class=\"headerlink\" title=\"4. 创建构造函数私有的类实例\"></a>4. 创建构造函数私有的类实例</h3><p>通过allocateInstance()方法，可以创建一个实例，即使该类构造函数私有，同时不需要调用初始化代码、构造函数、各种JVM检查等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123;</span><br><span class=\"line\">        Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class=\"line\">        field.setAccessible(true);</span><br><span class=\"line\"></span><br><span class=\"line\">        Unsafe unsafe = (Unsafe) field.get(null);</span><br><span class=\"line\"></span><br><span class=\"line\">        Player player = (Player) unsafe.allocateInstance(Player.class);</span><br><span class=\"line\">        System.out.println(player.getAge());</span><br><span class=\"line\"></span><br><span class=\"line\">        player.setAge(33);</span><br><span class=\"line\">        System.out.println(player.getAge());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Player &#123;</span><br><span class=\"line\">    private int age = 23;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Player() &#123;</span><br><span class=\"line\">        age = 50;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getAge() &#123;</span><br><span class=\"line\">        return age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAge(int age) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 // 证明私有方法及构造函数未调用</span><br><span class=\"line\">33</span><br></pre></td></tr></table></figure>","categories":["多线程"],"tags":["多线程"]},{"title":"JVM内存结构、JAVA内存模型、JAVA对象模型","url":"http://www.shenjian.online/2019/03/21/JVM内存结构、JAVA内存模型、JAVA对象模型/","content":"<h3 id=\"1-JVM内存结构\"><a href=\"#1-JVM内存结构\" class=\"headerlink\" title=\"1. JVM内存结构\"></a>1. JVM内存结构</h3><p><img src=\"/2019/03/21/JVM内存结构、JAVA内存模型、JAVA对象模型/JVM内存结构.png\" alt=\"JVM内存结构\"></p>\n<ol>\n<li>不同版本的方法区所处的位置可能不一样，某些JDK版本方法区在堆中实现</li>\n<li>除JVM运行时内存外，还有直接内存，不由JVM管理，利用本地方法库直接在堆外分配内存</li>\n<li>堆与栈的数据划分也不是绝对的，如HotSpot的JIT对对象分配做相应优化</li>\n</ol>\n<h3 id=\"2-JAVA内存模型\"><a href=\"#2-JAVA内存模型\" class=\"headerlink\" title=\"2. JAVA内存模型\"></a>2. JAVA内存模型</h3><p><img src=\"/2019/03/21/JVM内存结构、JAVA内存模型、JAVA对象模型/JAVA内存模型.png\" alt=\"JAVA内存模型\"></p>\n<p>JAVA内存模型是为了解决多线程间通信产生的原子性、可见性、有序性等问题，定义了一些语法集，这些语法集映射到JAVA语言上就是volatile、synchronized等</p>\n<h3 id=\"3-JAVA对象模型\"><a href=\"#3-JAVA对象模型\" class=\"headerlink\" title=\"3. JAVA对象模型\"></a>3. JAVA对象模型</h3><p><img src=\"/2019/03/21/JVM内存结构、JAVA内存模型、JAVA对象模型/JAVA对象模型.jpeg\" alt=\"JAVA对象模型\"></p>\n<p>HotSpot虚拟机中，每一个JAVA类被JVM加载时，JVM会给该类创建一个instanceKlass,保存在方法区，用来在JVM层表示该类。<br>当我们new一个对象时，JVM会创建instanceOopDesc对象。</p>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p>JVM内存结构，与JVM运行时数据区有关；JAVA内存模型，与JAVA并发编程有关；JAVA对象模型，与JAVA对象在JVM中表现形式有关</p>\n","categories":["JAVA"],"tags":["JAVA"]},{"title":"wait/notify使用详解","url":"http://www.shenjian.online/2019/03/19/wait-notify使用详解/","content":"<h3 id=\"1-使用注意事项\"><a href=\"#1-使用注意事项\" class=\"headerlink\" title=\"1. 使用注意事项\"></a>1. 使用注意事项</h3><p>1) wait/notify(All)可用于线程间(线程数量&gt;3)通信</p>\n<p>2) 永远在synchronized方法或对象里使用wait/notify(All),不然JVM报java.lang.IllegalMonitorStateException</p>\n<p>3) 永远在while循环里使用wait，防止其他原因改变先前判断条件</p>\n<p>4) 永远在线程间共享对象(生产者消费者中为缓冲区队列)上使用wait/notify(All)</p>\n<p>5) 多线程间协作，更倾向于使用notifyAll，唤醒在该对象上等待的全部线程</p>\n<h3 id=\"2-实现生产者消费者\"><a href=\"#2-实现生产者消费者\" class=\"headerlink\" title=\"2. 实现生产者消费者\"></a>2. 实现生产者消费者</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerConsumerDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Queue&lt;Integer&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSize = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread producer = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Producer(queue, maxSize));</span><br><span class=\"line\">        producer.setName(<span class=\"string\">\"Producer\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread consumerOne = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Consumer(queue, maxSize));</span><br><span class=\"line\">        consumerOne.setName(<span class=\"string\">\"ConsumerOne\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread consumerTwo = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Consumer(queue, maxSize));</span><br><span class=\"line\">        consumerTwo.setName(<span class=\"string\">\"ConsumerTwo\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">        consumerOne.start();</span><br><span class=\"line\">        consumerTwo.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Queue&lt;Integer&gt; queue;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxSize;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Producer</span><span class=\"params\">(Queue&lt;Integer&gt; queue, <span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.queue = queue;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.maxSize = maxSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (queue) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (queue.size() == maxSize) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"Queue is full, Producer \"</span> + Thread.currentThread().getName() + <span class=\"string\">\" waiting\"</span>);</span><br><span class=\"line\">                        queue.wait();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> value = random.nextInt();</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"Producer \"</span> + value);</span><br><span class=\"line\">                queue.add(value);</span><br><span class=\"line\">                queue.notifyAll();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Queue&lt;Integer&gt; queue;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxSize;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Consumer</span><span class=\"params\">(Queue&lt;Integer&gt; queue, <span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.queue = queue;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.maxSize = maxSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// synchronized方法或对象里使用wait/notify(All),不然JVM报java.lang.IllegalMonitorStateException</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (queue) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// while不可改为if,如果改为if，则可能抛出java.util.NoSuchElementException</span></span><br><span class=\"line\">                <span class=\"comment\">// 当前等待的线程被唤醒时，但是由于其他消费者刚好消费完，使得队列为空</span></span><br><span class=\"line\">                <span class=\"comment\">// 此时如果不重新判断队列为空，代码继续向下执行queue.remove势必抛出java.util.NoSuchElementException</span></span><br><span class=\"line\">                <span class=\"comment\">// 若放入while循环中重新判断条件，若条件不满足，线程则继续挂起，无影响</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (queue.isEmpty()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"Queue is empty, Consumer \"</span> + Thread.currentThread().getName() + <span class=\"string\">\" waiting\"</span>);</span><br><span class=\"line\">                        queue.wait(); <span class=\"comment\">// 在线程间共享对象(生产者消费者中为缓冲区队列)上使用wait/notify(All)</span></span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">\" consume \"</span> + queue.remove());</span><br><span class=\"line\">                queue.notifyAll(); <span class=\"comment\">// 多线程间协作，更倾向于使用notifyAll，唤醒在该对象上等待的全部线程</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Queue is empty, Consumer ConsumerOne waiting</span><br><span class=\"line\">Queue is empty, Consumer ConsumerTwo waiting</span><br><span class=\"line\">Producer -1203276467</span><br><span class=\"line\">Producer 626398544</span><br><span class=\"line\">Producer -108152878</span><br><span class=\"line\">Producer -705401944</span><br><span class=\"line\">ConsumerTwo consume -1203276467</span><br><span class=\"line\">ConsumerTwo consume 626398544</span><br><span class=\"line\">ConsumerTwo consume -108152878</span><br><span class=\"line\">ConsumerTwo consume -705401944</span><br><span class=\"line\">Queue is empty, Consumer ConsumerTwo waiting</span><br><span class=\"line\">Queue is empty, Consumer ConsumerOne waiting</span><br><span class=\"line\">Producer -1487489511</span><br><span class=\"line\">Producer 420807949</span><br><span class=\"line\">Producer 428506738</span><br><span class=\"line\">ConsumerOne consume -1487489511</span><br><span class=\"line\">ConsumerTwo consume 420807949</span><br><span class=\"line\">ConsumerTwo consume 428506738</span><br><span class=\"line\">Queue is empty, Consumer ConsumerTwo waiting</span><br><span class=\"line\">Queue is empty, Consumer ConsumerOne waiting</span><br><span class=\"line\">Producer 1411031303</span><br><span class=\"line\">Producer 1426589341</span><br><span class=\"line\">Producer -1307293143</span><br><span class=\"line\">Producer -970522822</span><br><span class=\"line\">Producer -2074755062</span><br><span class=\"line\">ConsumerOne consume 1411031303</span><br><span class=\"line\">ConsumerOne consume 1426589341</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-wait-nofity内部运行细节\"><a href=\"#3-wait-nofity内部运行细节\" class=\"headerlink\" title=\"3. wait/nofity内部运行细节\"></a>3. wait/nofity内部运行细节</h3><p>1) 使用wait()、notify()、notifyAll()时需要先对对象加锁<br>2) 调用wait()方法后，线程状态由RUNNING变为WAITTING,并将当前线程放置到对象的等待队列<br>3) notify()、notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()、notify()的线程释放锁后，等待线程才有机会从wait()返回<br>4) notify()、notifyAll()方法将线程从等待队列移到同步队列(前者移1个，后者移全部),被移动的线程由WAITTING变为BLOCKED<br>5) 从wait()方法返回的前提是获得了调用对象的锁[这也是3)中为啥说有机会返回的原因]</p>\n<p><img src=\"/2019/03/19/wait-notify使用详解/WaitNotify运行过程.png\" alt=\"wait/nofity运行过程\"></p>\n<h3 id=\"4-sleep与wait的区别\"><a href=\"#4-sleep与wait的区别\" class=\"headerlink\" title=\"4. sleep与wait的区别\"></a>4. sleep与wait的区别</h3><p>sleep是Thread中定义的方法, wait是Object中定义的方法;</p>\n<p>可以在任何地方调用线程对象的sleep方法，wait方法只能在同步代码块或同步方法中调用；</p>\n<p>调用线程对象的sleep方法后，不释放锁，调用对象的wait方法，释放对象获得的锁</p>\n","categories":["多线程"],"tags":["多线程"]},{"title":"线程的状态","url":"http://www.shenjian.online/2019/03/18/线程的状态/","content":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Thread implements Runnable &#123;</span><br><span class=\"line\">\t public enum State &#123;</span><br><span class=\"line\">\t \t NEW,</span><br><span class=\"line\">\t \t RUNNABLE,</span><br><span class=\"line\">\t \t BLOCKED,</span><br><span class=\"line\">\t \t WAITING,</span><br><span class=\"line\">\t \t TIMED_WAITING,</span><br><span class=\"line\">\t \t TERMINATED;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/03/18/线程的状态/线程状态.png\" alt=\"线程状态\"></p>\n","categories":["多线程"],"tags":["多线程"]},{"title":"线程的优先级","url":"http://www.shenjian.online/2019/03/18/线程的优先级/","content":"<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h3><p>优先级高的线程可能获得比优先级低的线程更多的运行机会，但并不一定起作用，因为线程是<strong>抢占式</strong>。有些操作系统如centos6.5，优先级被忽略</p>\n<p>Java中Tread分为1-10个级别，默认级别为5</p>\n<h3 id=\"2-示例\"><a href=\"#2-示例\" class=\"headerlink\" title=\"2. 示例\"></a>2. 示例</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Temp &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Thread threadOne = new Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">\"第\"</span> + i + <span class=\"string\">\"次执行\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        threadOne.setName(<span class=\"string\">\"Thread-1\"</span>);</span><br><span class=\"line\">        threadOne.setPriority(Thread.MAX_PRIORITY);</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread threadTwo = new Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">\"第\"</span> + i + <span class=\"string\">\"次执行\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        threadTwo.setName(<span class=\"string\">\"Thread-2\"</span>);</span><br><span class=\"line\">        threadTwo.setPriority(Thread.MIN_PRIORITY);</span><br><span class=\"line\"></span><br><span class=\"line\">        threadOne.start();</span><br><span class=\"line\">        threadTwo.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread-2第0次执行</span><br><span class=\"line\">Thread-2第1次执行</span><br><span class=\"line\">Thread-2第2次执行</span><br><span class=\"line\">Thread-2第3次执行</span><br><span class=\"line\">Thread-2第4次执行</span><br><span class=\"line\">Thread-1第0次执行</span><br><span class=\"line\">Thread-2第5次执行</span><br><span class=\"line\">Thread-2第6次执行</span><br><span class=\"line\">Thread-2第7次执行</span><br><span class=\"line\">Thread-2第8次执行</span><br><span class=\"line\">Thread-2第9次执行</span><br><span class=\"line\">Thread-1第1次执行</span><br><span class=\"line\">Thread-1第2次执行</span><br><span class=\"line\">Thread-1第3次执行</span><br><span class=\"line\">Thread-1第4次执行</span><br><span class=\"line\">Thread-1第5次执行</span><br><span class=\"line\">Thread-1第6次执行</span><br><span class=\"line\">Thread-1第7次执行</span><br><span class=\"line\">Thread-1第8次执行</span><br><span class=\"line\">Thread-1第9次执行</span><br></pre></td></tr></table></figure>\n<p>由结果看来，优先级高的Thread-1执行优先级设置优势并没有显现出来。</p>\n<h3 id=\"3-查看\"><a href=\"#3-查看\" class=\"headerlink\" title=\"3. 查看\"></a>3. 查看</h3><p>使用jps + jstack 查看线程的优先级，其中 prio表示JVM设置的优先级，os_prio表示操作系统线程优先级</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\Project\\java\\design-pattern&gt;jps -l</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13360</span><br><span class=\"line\">7728 org.jetbrains.jps.cmdline.Launcher</span><br><span class=\"line\">14164 org.jetbrains.jps.cmdline.Launcher</span><br><span class=\"line\">3396 org.apache.catalina.startup.Bootstrap</span><br><span class=\"line\">9972 sun.tools.jps.Jps</span><br><span class=\"line\">13960 org.jetbrains.kotlin.daemon.KotlinCompileDaemon</span><br><span class=\"line\">2316 Temp</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\Project\\java\\design-pattern&gt;jstack 2316</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"Thread-2\"</span> <span class=\"comment\">#13 prio=1 os_prio=-2 tid=0x000000001f236000 nid=0x950 waiting on condition [0x000000001fbbf000]</span></span><br><span class=\"line\">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class=\"line\">        at java.lang.Thread.sleep(Native Method)</span><br><span class=\"line\">        at Temp.lambda<span class=\"variable\">$main</span><span class=\"variable\">$1</span>(Temp.java:20)</span><br><span class=\"line\">        at Temp$<span class=\"variable\">$Lambda</span><span class=\"variable\">$2</span>/1023892928.run(Unknown Source)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:748)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"Thread-1\"</span> <span class=\"comment\">#12 prio=10 os_prio=2 tid=0x000000001f1d7800 nid=0x1c20 waiting on condition [0x000000001fabf000]</span></span><br><span class=\"line\">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class=\"line\">        at java.lang.Thread.sleep(Native Method)</span><br><span class=\"line\">        at Temp.lambda<span class=\"variable\">$main</span><span class=\"variable\">$0</span>(Temp.java:7)</span><br><span class=\"line\">        at Temp$<span class=\"variable\">$Lambda</span><span class=\"variable\">$1</span>/1078694789.run(Unknown Source)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>","categories":["多线程"],"tags":["多线程"]},{"title":"Thread的join方法","url":"http://www.shenjian.online/2019/03/18/Thread的join方法/","content":"<h2 id=\"1-join的作用\"><a href=\"#1-join的作用\" class=\"headerlink\" title=\"1. join的作用\"></a>1. join的作用</h2><p>Thread类中有一个join方法，其作用是： <strong>在线程A中调用了线程B的join方法，则线程A需要等待线程B执行完毕后才能继续执行</strong></p>\n<h2 id=\"2-使用demo\"><a href=\"#2-使用demo\" class=\"headerlink\" title=\"2. 使用demo\"></a>2. 使用demo</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Temp &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        long start = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">\"开始执行\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread threadOne = new Thread(() -&gt; &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">\"开始执行\"</span>);</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.sleep(10000);</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">\"结束执行\"</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        threadOne.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.sleep(9000);</span><br><span class=\"line\">        long joinStart = System.currentTimeMillis();</span><br><span class=\"line\">        threadOne.join();</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">\"执行完毕，共花费\"</span> + (System.currentTimeMillis() - start) / 1000 + <span class=\"string\">\"S,\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"其中等待threadOne时间为\"</span> + (System.currentTimeMillis() - joinStart) / 1000 + <span class=\"string\">\"S\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main开始执行</span><br><span class=\"line\">Thread-0开始执行</span><br><span class=\"line\">Thread-0结束执行</span><br><span class=\"line\">main执行完毕，共花费10S,其中等待threadOne时间为1S</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-使用场景\"><a href=\"#3-使用场景\" class=\"headerlink\" title=\"3. 使用场景\"></a>3. 使用场景</h2><p>分库查询。如果某个页面的数据需要来自两个数据库，在A中查询需要9秒，在B中查询需要10秒，如果采用join方式，两个线程进行执行，先执行完的等待后执行完的，则总共执行花费10秒</p>\n","categories":["多线程"],"tags":["多线程"]},{"title":"避免活跃性风险","url":"http://www.shenjian.online/2019/03/17/避免活跃性风险/","content":"<h2 id=\"1-死锁\"><a href=\"#1-死锁\" class=\"headerlink\" title=\"1. 死锁\"></a>1. 死锁</h2><h3 id=\"1-1-死锁的必要条件\"><a href=\"#1-1-死锁的必要条件\" class=\"headerlink\" title=\"1.1 死锁的必要条件\"></a>1.1 死锁的必要条件</h3><p><strong>互斥、 等待、 不可剥夺、 循环等待</strong></p>\n<h3 id=\"1-2-死锁的产生方式\"><a href=\"#1-2-死锁的产生方式\" class=\"headerlink\" title=\"1.2 死锁的产生方式\"></a>1.2 死锁的产生方式</h3><h4 id=\"1-2-1-锁顺序死锁\"><a href=\"#1-2-1-锁顺序死锁\" class=\"headerlink\" title=\"1.2.1 锁顺序死锁\"></a>1.2.1 锁顺序死锁</h4><p>线程A先获取了锁a,尝试获取锁b, 此时，线程B获取了锁b,尝试获取锁a, 产生死锁。 </p>\n<h4 id=\"1-2-2-动态的锁顺序死锁\"><a href=\"#1-2-2-动态的锁顺序死锁\" class=\"headerlink\" title=\"1.2.2 动态的锁顺序死锁\"></a>1.2.2 动态的锁顺序死锁</h4><p>线程A: <code>transferMoney(myAccount, yourAccount, 1);</code><br>线程B: <code>transferMoney(yourAccount, myAccount, 1);</code></p>\n<p>由于动态传参的顺序问题，导致死锁，以下代码为死锁案例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Temp &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 开设100个账户每个账户100元</span><br><span class=\"line\">        Account[] accounts = new Account[100];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (int i = 0; i &lt; accounts.length; i++) &#123;</span><br><span class=\"line\">            accounts[i] = new Temp().new Account();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Random random = new Random();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (int i = 0; i &lt; 20; i++) &#123;</span><br><span class=\"line\">            new Thread(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (int j = 0; j &lt; 100000; j++) &#123; // 模拟10万次转转账</span><br><span class=\"line\">                    int fromIndex = random.nextInt(2);</span><br><span class=\"line\">                    int toIndex = random.nextInt(2);</span><br><span class=\"line\">                    System.out.println(fromIndex + <span class=\"string\">\" \"</span> + toIndex);</span><br><span class=\"line\">                    transferMoney(accounts[fromIndex], accounts[toIndex], 1);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void transferMoney(Account fromAccount, Account toAccount, int amount) &#123;</span><br><span class=\"line\">        synchronized (fromAccount) &#123;</span><br><span class=\"line\">            synchronized (toAccount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (fromAccount.money &lt; amount) &#123;</span><br><span class=\"line\">                    throw new IllegalArgumentException(<span class=\"string\">\"账户余额不足\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                fromAccount.money -= amount;</span><br><span class=\"line\">                toAccount.money += amount;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class Account &#123;</span><br><span class=\"line\">        long money = 100000000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-2-3-在协作对象之间发生死锁\"><a href=\"#1-2-3-在协作对象之间发生死锁\" class=\"headerlink\" title=\"1.2.3 在协作对象之间发生死锁\"></a>1.2.3 在协作对象之间发生死锁</h4><p>类A同步方法中，存在调用类B中同步方法，类B中同步方法，存在调用类A中同步方法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Dispatcher &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized void getImage (Taxi taxi) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"获取车位置图像\"</span>);</span><br><span class=\"line\">        taxi.getLocation();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized void notifyAvailable(Taxi taxi) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"该车辆已到达\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Taxi &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Dispatcher dispatcher;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Taxi(Dispatcher dispatcher) &#123;</span><br><span class=\"line\">        this.dispatcher = dispatcher;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized void <span class=\"function\"><span class=\"title\">getLocation</span></span>() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"获取位置\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized void <span class=\"function\"><span class=\"title\">setLocation</span></span>() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"设置位置\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            dispatcher.notifyAvailable(this);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Dispatcher dispatcher = new Dispatcher();</span><br><span class=\"line\">        Taxi taxi = new Taxi(dispatcher);</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread threadOne = new Thread(() -&gt; &#123;</span><br><span class=\"line\">            taxi.setLocation();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread threadTwo = new Thread(() -&gt; &#123;</span><br><span class=\"line\">            dispatcher.getImage(taxi);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        threadOne.start();</span><br><span class=\"line\">        threadTwo.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：</p>\n<p><strong>JAVA实例方法同步是同步在该方法的对象实例上，如果每个线程运行的是不同对象实例的同步方法，则没有同步效果</strong></p>\n<h4 id=\"1-2-4-在协作对象之间发生死锁\"><a href=\"#1-2-4-在协作对象之间发生死锁\" class=\"headerlink\" title=\"1.2.4 在协作对象之间发生死锁\"></a>1.2.4 在协作对象之间发生死锁</h4><p>多个线程相互等待锁而不释放自己持有的锁时会发生死锁；当它们在相同的资源集合上等待上也会发生死锁。</p>\n<p>如一个任务需要连接两个数据库，线程A持有数据库D1,需要获取数据库D2,而线程B持有数据库D2，需要获取数据库D1，线程AB因为资源相互等待，产生死锁。</p>\n<h3 id=\"1-3-死锁的避免与诊断\"><a href=\"#1-3-死锁的避免与诊断\" class=\"headerlink\" title=\"1.3 死锁的避免与诊断\"></a>1.3 死锁的避免与诊断</h3><h4 id=\"1-3-1定义锁的顺序\"><a href=\"#1-3-1定义锁的顺序\" class=\"headerlink\" title=\"1.3.1定义锁的顺序\"></a>1.3.1定义锁的顺序</h4><p>针对1.2.2动态的锁顺序发生的死锁，我们可以定义锁的顺序，代码如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Temp &#123;</span><br><span class=\"line\">    \tprivate static final Object object = new Object();</span><br><span class=\"line\">    \t......</span><br><span class=\"line\"></span><br><span class=\"line\">    \tpublic static void transferMoney(Account fromAccount, Account toAccount, int amount) &#123;</span><br><span class=\"line\">        int fromHash = System.identityHashCode(fromAccount);</span><br><span class=\"line\">        int toHash = System.identityHashCode(toAccount);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fromHash &lt; toHash) &#123;</span><br><span class=\"line\">            synchronized (fromAccount) &#123;</span><br><span class=\"line\">                synchronized (toAccount) &#123;</span><br><span class=\"line\">                   ......</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fromHash &gt; toHash) &#123;</span><br><span class=\"line\">            synchronized (toAccount) &#123;</span><br><span class=\"line\">                synchronized (fromAccount) &#123;</span><br><span class=\"line\">                   ......</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            synchronized (object) &#123;</span><br><span class=\"line\">                synchronized (fromAccount) &#123;</span><br><span class=\"line\">                    synchronized (toAccount) &#123;</span><br><span class=\"line\">                       ......</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-3-2-开放调用\"><a href=\"#1-3-2-开放调用\" class=\"headerlink\" title=\"1.3.2 开放调用\"></a>1.3.2 开放调用</h4><p>如果调用某个方法时不需要持有锁，呢么这种调用被称为开放调用。</p>\n<p>如在1.2.3协作对象之间发生的死锁，可通过开放调用来解决，具体代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Dispatcher &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void getImage (Taxi taxi) &#123;</span><br><span class=\"line\">        synchronized (this) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"获取车位置图像\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        taxi.getLocation();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized void notifyAvailable(Taxi taxi) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"该车辆已到达\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Taxi &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Dispatcher dispatcher;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Taxi(Dispatcher dispatcher) &#123;</span><br><span class=\"line\">        this.dispatcher = dispatcher;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized void <span class=\"function\"><span class=\"title\">getLocation</span></span>() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"获取位置\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">setLocation</span></span>() &#123;</span><br><span class=\"line\">        synchronized (this) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"设置位置\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            dispatcher.notifyAvailable(this);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Dispatcher dispatcher = new Dispatcher();</span><br><span class=\"line\">        Taxi taxi = new Taxi(dispatcher);</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread threadOne = new Thread(() -&gt; &#123;</span><br><span class=\"line\">            taxi.setLocation();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread threadTwo = new Thread(() -&gt; &#123;</span><br><span class=\"line\">            dispatcher.getImage(taxi);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        threadOne.start();</span><br><span class=\"line\">        threadTwo.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-3-3-使用支持定时的锁\"><a href=\"#1-3-3-使用支持定时的锁\" class=\"headerlink\" title=\"1.3.3 使用支持定时的锁\"></a>1.3.3 使用支持定时的锁</h4><p>针对1.2.2动态的锁顺序发生的死锁，我们除了可以定义锁的顺序，还可以使用定时的锁，代码如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Temp &#123;</span><br><span class=\"line\">    public static boolean transferMoney(Account fromAccount, Account toAccount, int amount) &#123;</span><br><span class=\"line\">        Lock lock = new ReentrantLock();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lock.tryLock()) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (fromAccount.money &lt; amount) &#123;</span><br><span class=\"line\">                        throw new IllegalArgumentException(<span class=\"string\">\"账户余额不足\"</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    fromAccount.money -= amount;</span><br><span class=\"line\">                    toAccount.money += amount;</span><br><span class=\"line\">                    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125; finally &#123;</span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-3-4-通过线程转储来分析死锁\"><a href=\"#1-3-4-通过线程转储来分析死锁\" class=\"headerlink\" title=\"1.3.4 通过线程转储来分析死锁\"></a>1.3.4 通过线程转储来分析死锁</h4><p>UNIX平台按下Ctrl-\\键 ，Window下按Ctrl-Break</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-03-17 12:42:45</span><br><span class=\"line\">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.131-b11 mixed mode):</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"DestroyJavaVM\"</span> <span class=\"comment\">#32 prio=5 os_prio=0 tid=0x000000001f99f000 nid=0x650 waiting on condition [0x0000000000000000]</span></span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"Thread-16\"</span> <span class=\"comment\">#28 prio=5 os_prio=0 tid=0x000000001f98f800 nid=0x38e8 waiting for monitor entry [0x000000002135e000]</span></span><br><span class=\"line\">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class=\"line\">\tat Temp.transferMoney(Temp.java:38)</span><br><span class=\"line\">\t- waiting to lock &lt;0x000000076fe344e0&gt; (a Temp<span class=\"variable\">$Account</span>)</span><br><span class=\"line\">\t- locked &lt;0x000000076fe09118&gt; (a Temp<span class=\"variable\">$Account</span>)</span><br><span class=\"line\">\tat Temp.lambda<span class=\"variable\">$main</span><span class=\"variable\">$0</span>(Temp.java:30)</span><br><span class=\"line\">\tat Temp$<span class=\"variable\">$Lambda</span><span class=\"variable\">$1</span>/1831932724.run(Unknown Source)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:748)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"Thread-13\"</span> <span class=\"comment\">#25 prio=5 os_prio=0 tid=0x000000001f98c800 nid=0x1584 waiting for monitor entry [0x000000002105e000]</span></span><br><span class=\"line\">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class=\"line\">\tat Temp.transferMoney(Temp.java:38)</span><br><span class=\"line\">\t- waiting to lock &lt;0x000000076fe09118&gt; (a Temp<span class=\"variable\">$Account</span>)</span><br><span class=\"line\">\t- locked &lt;0x000000076fe344e0&gt; (a Temp<span class=\"variable\">$Account</span>)</span><br><span class=\"line\">\tat Temp.lambda<span class=\"variable\">$main</span><span class=\"variable\">$0</span>(Temp.java:30)</span><br><span class=\"line\">\tat Temp$<span class=\"variable\">$Lambda</span><span class=\"variable\">$1</span>/1831932724.run(Unknown Source)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:748)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"Thread-11\"</span> <span class=\"comment\">#23 prio=5 os_prio=0 tid=0x000000001f990800 nid=0x3254 waiting for monitor entry [0x0000000020e5f000]</span></span><br><span class=\"line\">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class=\"line\">\tat Temp.transferMoney(Temp.java:37)</span><br><span class=\"line\">\t- waiting to lock &lt;0x000000076fe344e0&gt; (a Temp<span class=\"variable\">$Account</span>)</span><br><span class=\"line\">\tat Temp.lambda<span class=\"variable\">$main</span><span class=\"variable\">$0</span>(Temp.java:30)</span><br><span class=\"line\">\tat Temp$<span class=\"variable\">$Lambda</span><span class=\"variable\">$1</span>/1831932724.run(Unknown Source)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:748)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"Thread-10\"</span> <span class=\"comment\">#22 prio=5 os_prio=0 tid=0x000000001f98b000 nid=0x36e0 waiting for monitor entry [0x0000000020d5e000]</span></span><br><span class=\"line\">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class=\"line\">\tat Temp.transferMoney(Temp.java:37)</span><br><span class=\"line\">\t- waiting to lock &lt;0x000000076fe344e0&gt; (a Temp<span class=\"variable\">$Account</span>)</span><br><span class=\"line\">\tat Temp.lambda<span class=\"variable\">$main</span><span class=\"variable\">$0</span>(Temp.java:30)</span><br><span class=\"line\">\tat Temp$<span class=\"variable\">$Lambda</span><span class=\"variable\">$1</span>/1831932724.run(Unknown Source)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:748)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"Thread-5\"</span> <span class=\"comment\">#17 prio=5 os_prio=0 tid=0x000000001f982800 nid=0x3b94 waiting for monitor entry [0x000000002075f000]</span></span><br><span class=\"line\">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class=\"line\">\tat Temp.transferMoney(Temp.java:37)</span><br><span class=\"line\">\t- waiting to lock &lt;0x000000076fe344e0&gt; (a Temp<span class=\"variable\">$Account</span>)</span><br><span class=\"line\">\tat Temp.lambda<span class=\"variable\">$main</span><span class=\"variable\">$0</span>(Temp.java:30)</span><br><span class=\"line\">\tat Temp$<span class=\"variable\">$Lambda</span><span class=\"variable\">$1</span>/1831932724.run(Unknown Source)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:748)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"Thread-3\"</span> <span class=\"comment\">#15 prio=5 os_prio=0 tid=0x000000001f981000 nid=0x1928 waiting for monitor entry [0x000000002055f000]</span></span><br><span class=\"line\">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class=\"line\">\tat Temp.transferMoney(Temp.java:37)</span><br><span class=\"line\">\t- waiting to lock &lt;0x000000076fe344e0&gt; (a Temp<span class=\"variable\">$Account</span>)</span><br><span class=\"line\">\tat Temp.lambda<span class=\"variable\">$main</span><span class=\"variable\">$0</span>(Temp.java:30)</span><br><span class=\"line\">\tat Temp$<span class=\"variable\">$Lambda</span><span class=\"variable\">$1</span>/1831932724.run(Unknown Source)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:748)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"Thread-2\"</span> <span class=\"comment\">#14 prio=5 os_prio=0 tid=0x000000001f97c000 nid=0x15f0 waiting for monitor entry [0x000000002045f000]</span></span><br><span class=\"line\">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class=\"line\">\tat Temp.transferMoney(Temp.java:37)</span><br><span class=\"line\">\t- waiting to lock &lt;0x000000076fe344e0&gt; (a Temp<span class=\"variable\">$Account</span>)</span><br><span class=\"line\">\tat Temp.lambda<span class=\"variable\">$main</span><span class=\"variable\">$0</span>(Temp.java:30)</span><br><span class=\"line\">\tat Temp$<span class=\"variable\">$Lambda</span><span class=\"variable\">$1</span>/1831932724.run(Unknown Source)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:748)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"Service Thread\"</span> <span class=\"comment\">#11 daemon prio=9 os_prio=0 tid=0x000000001ec51000 nid=0x2844 runnable [0x0000000000000000]</span></span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"C1 CompilerThread3\"</span> <span class=\"comment\">#10 daemon prio=9 os_prio=2 tid=0x000000001ebb5800 nid=0xfa4 waiting on condition [0x0000000000000000]</span></span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"C2 CompilerThread2\"</span> <span class=\"comment\">#9 daemon prio=9 os_prio=2 tid=0x000000001ebb0800 nid=0x3dbc waiting on condition [0x0000000000000000]</span></span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"C2 CompilerThread1\"</span> <span class=\"comment\">#8 daemon prio=9 os_prio=2 tid=0x000000001ebad000 nid=0xa60 waiting on condition [0x0000000000000000]</span></span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"C2 CompilerThread0\"</span> <span class=\"comment\">#7 daemon prio=9 os_prio=2 tid=0x000000001eb88000 nid=0x674 waiting on condition [0x0000000000000000]</span></span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"Monitor Ctrl-Break\"</span> <span class=\"comment\">#6 daemon prio=5 os_prio=0 tid=0x000000001eb89800 nid=0x28ec runnable [0x000000001f33e000]</span></span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\">\tat java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class=\"line\">\tat java.net.SocketInputStream.socketRead(SocketInputStream.java:116)</span><br><span class=\"line\">\tat java.net.SocketInputStream.read(SocketInputStream.java:171)</span><br><span class=\"line\">\tat java.net.SocketInputStream.read(SocketInputStream.java:141)</span><br><span class=\"line\">\tat sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)</span><br><span class=\"line\">\tat sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)</span><br><span class=\"line\">\tat sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)</span><br><span class=\"line\">\t- locked &lt;0x000000076fe30d38&gt; (a java.io.InputStreamReader)</span><br><span class=\"line\">\tat java.io.InputStreamReader.read(InputStreamReader.java:184)</span><br><span class=\"line\">\tat java.io.BufferedReader.fill(BufferedReader.java:161)</span><br><span class=\"line\">\tat java.io.BufferedReader.readLine(BufferedReader.java:324)</span><br><span class=\"line\">\t- locked &lt;0x000000076fe30d38&gt; (a java.io.InputStreamReader)</span><br><span class=\"line\">\tat java.io.BufferedReader.readLine(BufferedReader.java:389)</span><br><span class=\"line\">\tat com.intellij.rt.execution.application.AppMainV2<span class=\"variable\">$1</span>.run(AppMainV2.java:64)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"Attach Listener\"</span> <span class=\"comment\">#5 daemon prio=5 os_prio=2 tid=0x000000001eaf8800 nid=0xc8c runnable [0x0000000000000000]</span></span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"Signal Dispatcher\"</span> <span class=\"comment\">#4 daemon prio=9 os_prio=2 tid=0x000000001eb53000 nid=0x395c waiting on condition [0x0000000000000000]</span></span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"Finalizer\"</span> <span class=\"comment\">#3 daemon prio=8 os_prio=1 tid=0x000000001eae1800 nid=0x3888 in Object.wait() [0x000000001efbf000]</span></span><br><span class=\"line\">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class=\"line\">\tat java.lang.Object.wait(Native Method)</span><br><span class=\"line\">\t- waiting on &lt;0x000000076fe24628&gt; (a java.lang.ref.ReferenceQueue<span class=\"variable\">$Lock</span>)</span><br><span class=\"line\">\tat java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)</span><br><span class=\"line\">\t- locked &lt;0x000000076fe24628&gt; (a java.lang.ref.ReferenceQueue<span class=\"variable\">$Lock</span>)</span><br><span class=\"line\">\tat java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)</span><br><span class=\"line\">\tat java.lang.ref.Finalizer<span class=\"variable\">$FinalizerThread</span>.run(Finalizer.java:209)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"Reference Handler\"</span> <span class=\"comment\">#2 daemon prio=10 os_prio=2 tid=0x0000000003139800 nid=0x1368 in Object.wait() [0x000000001eabe000]</span></span><br><span class=\"line\">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class=\"line\">\tat java.lang.Object.wait(Native Method)</span><br><span class=\"line\">\t- waiting on &lt;0x000000076fe34300&gt; (a java.lang.ref.Reference<span class=\"variable\">$Lock</span>)</span><br><span class=\"line\">\tat java.lang.Object.wait(Object.java:502)</span><br><span class=\"line\">\tat java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class=\"line\">\t- locked &lt;0x000000076fe34300&gt; (a java.lang.ref.Reference<span class=\"variable\">$Lock</span>)</span><br><span class=\"line\">\tat java.lang.ref.Reference<span class=\"variable\">$ReferenceHandler</span>.run(Reference.java:153)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"VM Thread\"</span> os_prio=2 tid=0x000000001cbd9800 nid=0x1aa4 runnable </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"GC task thread#0 (ParallelGC)\"</span> os_prio=0 tid=0x0000000003058800 nid=0x3354 runnable </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"GC task thread#1 (ParallelGC)\"</span> os_prio=0 tid=0x000000000305a000 nid=0x2a50 runnable </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"GC task thread#2 (ParallelGC)\"</span> os_prio=0 tid=0x000000000305c000 nid=0x3690 runnable </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"GC task thread#3 (ParallelGC)\"</span> os_prio=0 tid=0x000000000305e800 nid=0x1e48 runnable </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"GC task thread#4 (ParallelGC)\"</span> os_prio=0 tid=0x0000000003060800 nid=0xd38 runnable </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"GC task thread#5 (ParallelGC)\"</span> os_prio=0 tid=0x0000000003062000 nid=0x1ff8 runnable </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"GC task thread#6 (ParallelGC)\"</span> os_prio=0 tid=0x0000000003065000 nid=0x2ef0 runnable </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"GC task thread#7 (ParallelGC)\"</span> os_prio=0 tid=0x0000000003066000 nid=0x1e1c runnable </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"VM Periodic Task Thread\"</span> os_prio=2 tid=0x000000001eca5000 nid=0x38e0 waiting on condition </span><br><span class=\"line\"></span><br><span class=\"line\">JNI global references: 217</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Found one Java-level deadlock:</span><br><span class=\"line\">=============================</span><br><span class=\"line\"><span class=\"string\">\"Thread-16\"</span>:</span><br><span class=\"line\">  waiting to lock monitor 0x000000001cbe35b8 (object 0x000000076fe344e0, a Temp<span class=\"variable\">$Account</span>),</span><br><span class=\"line\">  <span class=\"built_in\">which</span> is held by <span class=\"string\">\"Thread-13\"</span></span><br><span class=\"line\"><span class=\"string\">\"Thread-13\"</span>:</span><br><span class=\"line\">  waiting to lock monitor 0x000000001cbe0bc8 (object 0x000000076fe09118, a Temp<span class=\"variable\">$Account</span>),</span><br><span class=\"line\">  <span class=\"built_in\">which</span> is held by <span class=\"string\">\"Thread-16\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">Java stack information <span class=\"keyword\">for</span> the threads listed above:</span><br><span class=\"line\">===================================================</span><br><span class=\"line\"><span class=\"string\">\"Thread-16\"</span>:</span><br><span class=\"line\">\tat Temp.transferMoney(Temp.java:38)</span><br><span class=\"line\">\t- waiting to lock &lt;0x000000076fe344e0&gt; (a Temp<span class=\"variable\">$Account</span>)</span><br><span class=\"line\">\t- locked &lt;0x000000076fe09118&gt; (a Temp<span class=\"variable\">$Account</span>)</span><br><span class=\"line\">\tat Temp.lambda<span class=\"variable\">$main</span><span class=\"variable\">$0</span>(Temp.java:30)</span><br><span class=\"line\">\tat Temp$<span class=\"variable\">$Lambda</span><span class=\"variable\">$1</span>/1831932724.run(Unknown Source)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:748)</span><br><span class=\"line\"><span class=\"string\">\"Thread-13\"</span>:</span><br><span class=\"line\">\tat Temp.transferMoney(Temp.java:38)</span><br><span class=\"line\">\t- waiting to lock &lt;0x000000076fe09118&gt; (a Temp<span class=\"variable\">$Account</span>)</span><br><span class=\"line\">\t- locked &lt;0x000000076fe344e0&gt; (a Temp<span class=\"variable\">$Account</span>)</span><br><span class=\"line\">\tat Temp.lambda<span class=\"variable\">$main</span><span class=\"variable\">$0</span>(Temp.java:30)</span><br><span class=\"line\">\tat Temp$<span class=\"variable\">$Lambda</span><span class=\"variable\">$1</span>/1831932724.run(Unknown Source)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:748)</span><br><span class=\"line\"></span><br><span class=\"line\">Found 1 deadlock.</span><br><span class=\"line\"></span><br><span class=\"line\">Heap</span><br><span class=\"line\"> PSYoungGen      total 76288K, used 6337K [0x000000076b380000, 0x0000000770880000, 0x00000007c0000000)</span><br><span class=\"line\">  eden space 65536K, 7% used [0x000000076b380000,0x000000076b85e7b0,0x000000076f380000)</span><br><span class=\"line\">  from space 10752K, 12% used [0x000000076fe00000,0x000000076ff52040,0x0000000770880000)</span><br><span class=\"line\">  to   space 10752K, 0% used [0x000000076f380000,0x000000076f380000,0x000000076fe00000)</span><br><span class=\"line\"> ParOldGen       total 175104K, used 24K [0x00000006c1a00000, 0x00000006cc500000, 0x000000076b380000)</span><br><span class=\"line\">  object space 175104K, 0% used [0x00000006c1a00000,0x00000006c1a06000,0x00000006cc500000)</span><br><span class=\"line\"> Metaspace       used 4940K, capacity 5052K, committed 5248K, reserved 1056768K</span><br><span class=\"line\">  class space    used 550K, capacity 594K, committed 640K, reserved 1048576K</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-饥饿\"><a href=\"#2-饥饿\" class=\"headerlink\" title=\"2. 饥饿\"></a>2. 饥饿</h2><p>当线程无法访问它所需要的资源并且不能继续执行时，就发生了“饥饿”。引发饥饿的最常见资源就是CPU时钟周期</p>\n<p>如果JAVA应用对线程的优先级使用不当或者采用了无法结束的数据结构（无限循环或者无限制的等待），呢么也可能发生饥饿</p>\n<h2 id=\"3-糟糕的响应性\"><a href=\"#3-糟糕的响应性\" class=\"headerlink\" title=\"3. 糟糕的响应性\"></a>3. 糟糕的响应性</h2><h2 id=\"4-活锁\"><a href=\"#4-活锁\" class=\"headerlink\" title=\"4. 活锁\"></a>4. 活锁</h2><p>活锁尽管不会阻塞线程，但也不能继续执行，因为线程将重复执行相同的操作，并且总会失败。</p>\n<p>活锁通常发生在事务消息的应用中，如失败，回滚，将它重新放入队列执行。</p>\n","categories":["多线程"],"tags":["多线程"]},{"title":"并发编程模型","url":"http://www.shenjian.online/2019/03/11/并发编程模型/","content":"<h2 id=\"1-并行工作者模型\"><a href=\"#1-并行工作者模型\" class=\"headerlink\" title=\"1. 并行工作者模型\"></a>1. 并行工作者模型</h2><h3 id=\"1-1-简介\"><a href=\"#1-1-简介\" class=\"headerlink\" title=\"1.1 简介\"></a>1.1 简介</h3><p>委派者会将传入的工作分配给不同的工作者，每个工作者完成整个任务。并发工作者模型是最常见的并发模型</p>\n<p><img src=\"/2019/03/11/并发编程模型/并行工作者.png\" alt=\"并行工作者\"></p>\n<h3 id=\"1-2-优点\"><a href=\"#1-2-优点\" class=\"headerlink\" title=\"1.2 优点\"></a>1.2 优点</h3><p>只需添加更多的工作者来提高系统的并行度</p>\n<h3 id=\"1-3-缺点\"><a href=\"#1-3-缺点\" class=\"headerlink\" title=\"1.3 缺点\"></a>1.3 缺点</h3><p><strong>共享状态可能会很复杂</strong>  线程间数据共享意味着要处理好竞态、死锁等并发性问题</p>\n<p><strong>工作者无状态</strong> 共享状态能够被其他线程修改，所以工作者在每次需要的时候都要重新读状态，所以称为无状态</p>\n<p><strong>任务执行顺序不确定</strong></p>\n<h2 id=\"2-流水线并发模型\"><a href=\"#2-流水线并发模型\" class=\"headerlink\" title=\"2. 流水线并发模型\"></a>2. 流水线并发模型</h2><h3 id=\"2-1-简介\"><a href=\"#2-1-简介\" class=\"headerlink\" title=\"2.1 简介\"></a>2.1 简介</h3><p>每个工作者只负责作业中的部分工作，完成了会将作业转发给下一个工作者。 采用流水线并发模型的系统又称为反应器系统或者事件驱动系统。以下为其各个表现形式：</p>\n<p><img src=\"/2019/03/11/并发编程模型/流水线并发模型1.png\" alt=\"流水线并发模型1\"></p>\n<p><img src=\"/2019/03/11/并发编程模型/流水线并发模型2.png\" alt=\"流水线并发模型2\"></p>\n<p><img src=\"/2019/03/11/并发编程模型/流水线并发模型3.png\" alt=\"流水线并发模型3\"></p>\n<p><img src=\"/2019/03/11/并发编程模型/流水线并发模型4.png\" alt=\"流水线并发模型4\"></p>\n<h3 id=\"2-2-优点\"><a href=\"#2-2-优点\" class=\"headerlink\" title=\"2.2 优点\"></a>2.2 优点</h3><p><strong>无需共享状态</strong></p>\n<p><strong>工作者有状态</strong></p>\n<p><strong>较好的硬件整合</strong></p>\n<p><strong>合理的作业顺序</strong></p>\n<h3 id=\"2-3-缺点\"><a href=\"#2-3-缺点\" class=\"headerlink\" title=\"2.3 缺点\"></a>2.3 缺点</h3><p>作业被分布到多个工作者中，导致追踪某个工作到底被什么代码执行时变得困难。</p>\n<h2 id=\"3-函数式并行模型\"><a href=\"#3-函数式并行模型\" class=\"headerlink\" title=\"3. 函数式并行模型\"></a>3. 函数式并行模型</h2><p>函数式调用的基本思想是采用函数调用实现程序。函数可以看作代理人，函数之间可以像流水线模型互相发送消息(通过函数间的互相调用实现)。</p>\n<p>函数是通过拷贝来传递参数的，每个函数的执行类似原子操作，执行独立，互不影响。一旦可以独立运行，呢么可以在不同的CPU上进行过执行。</p>\n<p>java.util.concurrent包中的ForkJoinPool可以实现函数式并行的一些东西。JAVA8中的stream能够并行的迭代大型集合。</p>\n<p>跨CPU协调函数调用需要一定开销，要确定好并行的调用函数，其完成的工作单元可以弥补这个开销，否则，慎用！！</p>\n","categories":["多线程"],"tags":["多线程"]},{"title":"CompletionService优点及其应用","url":"http://www.shenjian.online/2019/03/03/CompletionService优点及其应用/","content":"<h3 id=\"1-需求描述\"><a href=\"#1-需求描述\" class=\"headerlink\" title=\"1. 需求描述\"></a>1. 需求描述</h3><p>某一图片网站首页有许多图片，渲染时间较长，给用户带来较差体验，为提高用户体验度，图片需缓存且无需等待所有图片全部准备完毕后，进行渲染</p>\n<h3 id=\"2-问题分析与实现\"><a href=\"#2-问题分析与实现\" class=\"headerlink\" title=\"2. 问题分析与实现\"></a>2. 问题分析与实现</h3><p>显而易见，我们可以想到一边获取图片，一边进行渲染，并行操作。但是每张图片获取的时间无法预知，即任务的执行时长不一致，有的可能几毫秒，有的可能几秒, 我们如何才能做到先获取的图片先进行渲染呢？幸好CompletionService适合该场景: 将Executor与BlockingQueue的功能融合在一起，将Callable任务提交给它执行，然后类似队列中的take与poll获取已经完成的任务。</p>\n<h3 id=\"3-CompletionService源码分析\"><a href=\"#3-CompletionService源码分析\" class=\"headerlink\" title=\"3. CompletionService源码分析\"></a>3. CompletionService源码分析</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface CompletionService&lt;V&gt; &#123;</span><br><span class=\"line\">        Future&lt;V&gt; submit(Callable&lt;V&gt; task);</span><br><span class=\"line\"></span><br><span class=\"line\">        Future&lt;V&gt; take() throws InterruptedException;</span><br><span class=\"line\"></span><br><span class=\"line\">        Future&lt;V&gt; poll();</span><br><span class=\"line\"></span><br><span class=\"line\">        ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>CompletionService唯一实现类： ExecutorCompletionService。 在构建函数中创建一个BlockingQueue保存结果。任务提交后，将任务包装成QueueingFuture(FutureTask的一个子类)，任务完成后，调用QueueingFuture的done方法，将结果放入BlockingQueue中。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ExecutorCompletionService&lt;V&gt; implements CompletionService&lt;V&gt; &#123;</span><br><span class=\"line\">    \tprivate final BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">    \tpublic ExecutorCompletionService(Executor executor) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (executor == null)</span><br><span class=\"line\">                    throw new NullPointerException();</span><br><span class=\"line\">                this.executor = executor;</span><br><span class=\"line\">                this.aes = (executor instanceof AbstractExecutorService) ?</span><br><span class=\"line\">                    (AbstractExecutorService) executor : null;</span><br><span class=\"line\">                this.completionQueue = new LinkedBlockingQueue&lt;Future&lt;V&gt;&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    \tpublic Future&lt;V&gt; submit(Callable&lt;V&gt; task) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (task == null) throw new NullPointerException();</span><br><span class=\"line\">                RunnableFuture&lt;V&gt; f = newTaskFor(task);</span><br><span class=\"line\">                executor.execute(new QueueingFuture(f)); // 任务包装成QueueingFuture</span><br><span class=\"line\">                <span class=\"built_in\">return</span> f;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        private class QueueingFuture extends FutureTask&lt;Void&gt; &#123;</span><br><span class=\"line\">                QueueingFuture(RunnableFuture&lt;V&gt; task) &#123;</span><br><span class=\"line\">                    super(task, null);</span><br><span class=\"line\">                    this.task = task;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                protected void <span class=\"function\"><span class=\"title\">done</span></span>() &#123; completionQueue.add(task); &#125; // 任务完成后，调用<span class=\"keyword\">done</span>方法，放入队列</span><br><span class=\"line\">                private final Future&lt;V&gt; task;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public Future&lt;V&gt; take() throws InterruptedException &#123;</span><br><span class=\"line\">                <span class=\"built_in\">return</span> completionQueue.take();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public Future&lt;V&gt; <span class=\"function\"><span class=\"title\">poll</span></span>() &#123;</span><br><span class=\"line\">                <span class=\"built_in\">return</span> completionQueue.poll();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-代码实现\"><a href=\"#4-代码实现\" class=\"headerlink\" title=\"4. 代码实现\"></a>4. 代码实现</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 使用CompletionService实现页面渲染器</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class Renderer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        private ExecutorService executor;</span><br><span class=\"line\"></span><br><span class=\"line\">        public Renderer(ExecutorService executor) &#123;</span><br><span class=\"line\">                this.executor = executor;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public void renderPage(CharSequence <span class=\"built_in\">source</span>) &#123;</span><br><span class=\"line\">                List&lt;ImageInfo&gt; info = scanImageInfo(<span class=\"built_in\">source</span>);</span><br><span class=\"line\">                CompletionService&lt;ImageData&gt; completionService = new ExecutorCompletionService&lt;&gt;(executor);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (final ImageInfo imageInfo : info) &#123;</span><br><span class=\"line\">                        completionService.submit(() -&gt; &#123;</span><br><span class=\"line\">                                <span class=\"built_in\">return</span> imageInfo.downloadImage();</span><br><span class=\"line\">                        &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                renderText(<span class=\"built_in\">source</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (int i = 0; i &lt; info.size(); i++) &#123;</span><br><span class=\"line\">                                Future&lt;ImageData&gt; future = completionService.take();</span><br><span class=\"line\">                                ImageData imageData = future.get();</span><br><span class=\"line\">                                renderImage(imageData);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                        Thread.currentThread().interrupt();</span><br><span class=\"line\">                &#125; catch (ExecutionException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["多线程"],"tags":["多线程"]},{"title":"Executor及其相关类分析","url":"http://www.shenjian.online/2019/03/02/Executor及其相关类分析/","content":"<h3 id=\"1-两个重要的接口\"><a href=\"#1-两个重要的接口\" class=\"headerlink\" title=\"1. 两个重要的接口\"></a>1. 两个重要的接口</h3><p>Executor用于应用程序执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Executor &#123;</span><br><span class=\"line\">    \tvoid execute(Runnable <span class=\"built_in\">command</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ExecutorService新增应用程序生命周期管理</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface ExecutorService extends Executor &#123;</span><br><span class=\"line\">      // 平缓方式关闭：不在接受新的任务，同时等待已经提交的任务执行完成(包括呢些已提交还没未开始执行的任务)</span><br><span class=\"line\">  \t \tvoid shutdown(); </span><br><span class=\"line\">      // 粗暴的关闭：尝试取消所有运行中的任务，并且不在启动队列中尚未开始执行的任务，返回从未执行的任务列表</span><br><span class=\"line\">  \t \tList&lt;Runnable&gt; shutdownNow(); </span><br><span class=\"line\">  \t \tboolean isShutdown();</span><br><span class=\"line\">      // 是否已经终止</span><br><span class=\"line\">  \t \tboolean isTerminated();</span><br><span class=\"line\">      // 阻塞直到到达终止状态</span><br><span class=\"line\">  \t \tboolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;</span><br><span class=\"line\">      // 传入n个Callable任务，按序返回一组Future</span><br><span class=\"line\">      &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-线程池\"><a href=\"#2-线程池\" class=\"headerlink\" title=\"2. 线程池\"></a>2. 线程池</h3><p><img src=\"/2019/03/02/Executor及其相关类分析/ThreadPool.png\" alt=\"线程池类图\"></p>\n<p>线程池与工作队列密切相关，工作队列中存取所有等待执行的任务，工作线程在工作队列中获取一个任务，执行任务，然后返回线程池等待执行下一个任务</p>\n<p>可以通过Executors中的静态方法来创建线程池：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Executors &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    \t\t// 创建固定长度的线程，达到最大规模后，如果某一线程Exception结束，</span><br><span class=\"line\">        // 线程池会补充一个新的线程；采用LinkedBlockingQueue</span><br><span class=\"line\">    \t\tpublic static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class=\"line\">           \t \t\t<span class=\"built_in\">return</span> new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class=\"line\">                                          0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                          new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      \t// 创建可缓冲的线程池，当线程池当前规模超过处理需求时，回收空闲线程; </span><br><span class=\"line\">        // 当需求增加时，创建新的线程，线程池的规模不受限制(需求突增，规模可怕，慎用!)</span><br><span class=\"line\">      \t// 采用SynchronousQueue，A synchronous queue does not have any internal capacity</span><br><span class=\"line\">      \tpublic static ExecutorService <span class=\"function\"><span class=\"title\">newCachedThreadPool</span></span>() &#123;</span><br><span class=\"line\">         \t\t\t  <span class=\"built_in\">return</span> new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class=\"line\">                                        60L, TimeUnit.SECONDS,</span><br><span class=\"line\">                                        new SynchronousQueue&lt;Runnable&gt;());</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      \t// 单线程Executor, FinalizableDelegatedExecutorService: 静态内部类, 继承自DelegatedExecutorService;</span><br><span class=\"line\">        // 采用LinkedBlockingQueue</span><br><span class=\"line\">      \tpublic static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class=\"line\">          \t\t  <span class=\"built_in\">return</span> new FinalizableDelegatedExecutorService</span><br><span class=\"line\">              \t\t\t(new ThreadPoolExecutor(1, 1,</span><br><span class=\"line\">                                      0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                      new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class=\"line\">                                      threadFactory));</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      \t// 固定长度的线程池，延迟或者定时的方式执行任务;</span><br><span class=\"line\">        // 采用ScheduledThreadPoolExecutor.DelayedWorkQueue</span><br><span class=\"line\">      \tpublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class=\"line\">          \t   \t<span class=\"built_in\">return</span> new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["多线程"],"tags":["多线程"]},{"title":"基于数组的ArrayList","url":"http://www.shenjian.online/2019/03/01/基于数组的ArrayList/","content":"<p>ArrayList基于数组，故需注意数组相关注意事项，详见 <a href=\"https://sjshenjian.github.io/2019/01/25/%E6%95%B0%E7%BB%84/\" target=\"_blank\" rel=\"noopener\">数组</a></p>\n<p>首先我们看到ArrayList在集合中的位置如图</p>\n<p><img src=\"/2019/03/01/基于数组的ArrayList/ArrayList在Collection中的位置.png\" alt=\"基于数组的ArrayList\"></p>\n<h3 id=\"1-几个重要的变量\"><a href=\"#1-几个重要的变量\" class=\"headerlink\" title=\"1. 几个重要的变量\"></a>1. 几个重要的变量</h3><p>数组默认容量大小为10，transient忽略数组被序列化</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static final int DEFAULT_CAPACITY = 10; // 默认数组大小，也可构造器指定</span><br><span class=\"line\">transient Object[] elementData; // 存放元素</span><br><span class=\"line\">private int size; // 当前数组大小</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-插入方法\"><a href=\"#2-插入方法\" class=\"headerlink\" title=\"2. 插入方法\"></a>2. 插入方法</h3><p>首先保证数组容量是否足够，不够则使用grow()方法进行1.5倍扩容，modCount++以便迭代器遍历时其他线程进行不期望的修改时抛出ConcurrentModificationException，从而快速失败(fail-fast)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean add(E e) &#123;</span><br><span class=\"line\">        ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class=\"line\">        elementData[size++] = e;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void grow(int minCapacity) &#123;</span><br><span class=\"line\">        // overflow-conscious code</span><br><span class=\"line\">        int oldCapacity = elementData.length;</span><br><span class=\"line\">        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 右移1位，扩容1.5倍</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; 0)</span><br><span class=\"line\">            newCapacity = minCapacity;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class=\"line\">            newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">        // minCapacity is usually close to size, so this is a win:</span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity); // 底层采用Array.newInstance与System.arraycopy</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-删除方法\"><a href=\"#3-删除方法\" class=\"headerlink\" title=\"3. 删除方法\"></a>3. 删除方法</h3><p>index后数组拷贝至已index为头，已size-1为尾，数组中的最后一个非空元素置为null,以便垃圾回收</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public E remove(int index) &#123;</span><br><span class=\"line\">\t    rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">\t    modCount++;</span><br><span class=\"line\">\t    E oldValue = elementData(index);</span><br><span class=\"line\"></span><br><span class=\"line\">\t    int numMoved = size - index - 1;</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (numMoved &gt; 0)</span><br><span class=\"line\">\t        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class=\"line\">\t                         numMoved); // 涉及数组的拷贝，时间复杂度为O(n)</span><br><span class=\"line\">\t    elementData[--size] = null; // clear to <span class=\"built_in\">let</span> GC <span class=\"keyword\">do</span> its work</span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"built_in\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-查找方法\"><a href=\"#4-查找方法\" class=\"headerlink\" title=\"4. 查找方法\"></a>4. 查找方法</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int indexOf(Object o) &#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (o == null) &#123;</span><br><span class=\"line\">\t        <span class=\"keyword\">for</span> (int i = 0; i &lt; size; i++)</span><br><span class=\"line\">\t            <span class=\"keyword\">if</span> (elementData[i]==null)</span><br><span class=\"line\">\t                <span class=\"built_in\">return</span> i;</span><br><span class=\"line\">\t    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t        <span class=\"keyword\">for</span> (int i = 0; i &lt; size; i++)</span><br><span class=\"line\">\t            <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">\t                <span class=\"built_in\">return</span> i;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    <span class=\"built_in\">return</span> -1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h3><p>ArrayList的插入不考虑扩容时间复杂度为O(1), 考虑扩容时间复杂度为O(n), 查找与修改时间复杂度为O(n)。<br>数据量大时，频繁的插入与删除会触发底层数组频繁的拷贝，效率低，还会造成内存空间的浪费。</p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构"]},{"title":"JAVA实现登录获取资源","url":"http://www.shenjian.online/2019/03/01/JAVA实现登录获取资源/","content":"<h3 id=\"1-需求描述\"><a href=\"#1-需求描述\" class=\"headerlink\" title=\"1. 需求描述\"></a>1. 需求描述</h3><p>每月定时从第三方系统获取excel报表(报表内容格式较为复杂)，留痕解析落地数据库</p>\n<p>需求涉及到的开发过程如下：<br>1）登录第三方系统(已提供url、username、password及js jsonp方式登录demo)<br>2）url方式获取财务报表(已提供报表url)保存至服务器按月建立文件夹存储进行留痕<br>3）excel解析落地数据库临时表</p>\n<h3 id=\"2-分析过程\"><a href=\"#2-分析过程\" class=\"headerlink\" title=\"2. 分析过程\"></a>2. 分析过程</h3><p>采用jsonp方式登录缺点： 需js实现定时；需js实现资源获取与保存，由于js知识欠缺且个人认为js实现不如java方式简便便于管理</p>\n<p>我们知道，系统登录成功后，<strong>服务器会返回给浏览器一个JSESSIONID用于用户再次访问时的身份凭证</strong>，删除该JSESSIONID后再次访问则重定向到登录页面。</p>\n<p><img src=\"/2019/03/01/JAVA实现登录获取资源/JSESSIONID.png\" alt=\"JSESSIONID\"></p>\n<h3 id=\"3-解决方案\"><a href=\"#3-解决方案\" class=\"headerlink\" title=\"3. 解决方案\"></a>3. 解决方案</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package online.shenjian.jsonp;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.alibaba.fastjson.JSONObject;</span><br><span class=\"line\">import org.apache.commons.httpclient.HttpClient;</span><br><span class=\"line\">import org.apache.commons.httpclient.methods.GetMethod;</span><br><span class=\"line\">import org.springframework.http.*;</span><br><span class=\"line\">import org.springframework.web.client.RestTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.*;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * JAVA后台登录获取数据</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class JsonpLogin &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws IOException &#123;</span><br><span class=\"line\">        RestTemplate restTemplate = new RestTemplate();</span><br><span class=\"line\"></span><br><span class=\"line\">        String url = <span class=\"string\">\"http://ip:port/report/reportServer\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        JSONObject jsonObject = new JSONObject();</span><br><span class=\"line\">        jsonObject.put(<span class=\"string\">\"username\"</span>, <span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">        jsonObject.put(<span class=\"string\">\"password\"</span>, <span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">        String body = jsonObject.toJSONString();</span><br><span class=\"line\"></span><br><span class=\"line\">        HttpHeaders headers = new HttpHeaders();</span><br><span class=\"line\">        MediaType mediaType = MediaType.parseMediaType(<span class=\"string\">\"application/json; charset=UTF-8\"</span>);</span><br><span class=\"line\">        headers.setContentType(mediaType);</span><br><span class=\"line\"></span><br><span class=\"line\">        HttpEntity&lt;String&gt; entity = new HttpEntity&lt;&gt;(body, headers);</span><br><span class=\"line\"></span><br><span class=\"line\">        ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity(url, entity, String.class);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (HttpStatus.OK.equals(responseEntity.getStatusCode())) &#123;</span><br><span class=\"line\">            String cookieString = String.valueOf(responseEntity.getHeaders().get(<span class=\"string\">\"Set-Cookie\"</span>));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cookieString != null &amp;&amp; cookieString.length() &gt; 1) &#123;</span><br><span class=\"line\">                cookieString = cookieString.substring(1, cookieString.length() - 1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String address = <span class=\"string\">\"http://ip:port/webReport/reportServer?report=test.xlsx\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            HttpClient httpClient = new HttpClient();</span><br><span class=\"line\">            GetMethod getMethod = new GetMethod(address);</span><br><span class=\"line\">            // Cookie如不传递，服务器则认为为新请求，故下载内容后缀更改为html,会发现为登录页面</span><br><span class=\"line\">            getMethod.setRequestHeader(<span class=\"string\">\"Cookie\"</span>, cookieString);</span><br><span class=\"line\"></span><br><span class=\"line\">            int statusCode = httpClient.executeMethod(getMethod);</span><br><span class=\"line\"></span><br><span class=\"line\">            InputStream inputStream = null;</span><br><span class=\"line\">            OutputStream outputStream = null;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (statusCode == org.apache.commons.httpclient.HttpStatus.SC_OK) &#123;</span><br><span class=\"line\">                    inputStream = getMethod.getResponseBodyAsStream();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                File file = new File(<span class=\"string\">\"/home/document/report/201902/test.xlsx\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (file.exists()) &#123;</span><br><span class=\"line\">                    file.delete();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                outputStream = new FileOutputStream(file);</span><br><span class=\"line\">                // 由于报表文件较小，不到M,不采用缓冲流(默认大小8M)</span><br><span class=\"line\">                byte[] bytes = new byte[1024];</span><br><span class=\"line\">                int size;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> ((size = inputStream.read(bytes)) != -1) &#123;</span><br><span class=\"line\">                    outputStream.write(bytes, 0, size);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inputStream != null) &#123;</span><br><span class=\"line\">                    inputStream.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (outputStream != null) &#123;</span><br><span class=\"line\">                    outputStream.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["工作干货"],"tags":["工作干货"]},{"title":"构建高效可伸缩的缓存","url":"http://www.shenjian.online/2019/02/25/构建高效可伸缩的缓存/","content":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\">public interface Computable&lt;K, V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    V compute(K key) throws InterruptedException;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 构建高效且可伸缩的缓存</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MemCache&lt;K, V&gt; implements Computable&lt;K, V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final ConcurrentHashMap&lt;K, Future&lt;V&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\">    private final Computable&lt;K, V&gt; computable;</span><br><span class=\"line\"></span><br><span class=\"line\">    public MemCache(Computable&lt;K, V&gt; computable) &#123;</span><br><span class=\"line\">        this.computable = computable;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public V compute(K key) throws InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            Future&lt;V&gt; f = cache.get(key);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (f == null) &#123;</span><br><span class=\"line\">                Callable&lt;V&gt; callable = () -&gt; &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">return</span> computable.compute(key);</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">                FutureTask&lt;V&gt; task = new FutureTask&lt;&gt;(callable);</span><br><span class=\"line\">                Future&lt;V&gt; ft = cache.putIfAbsent(key, task);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (f == null) &#123;</span><br><span class=\"line\">                    f = ft;</span><br><span class=\"line\">                    task.run();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (f != null) &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">return</span> f.get();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; catch (CancellationException e) &#123;</span><br><span class=\"line\">                cache.remove(key, f);</span><br><span class=\"line\">            &#125; catch (ExecutionException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Computable&lt;Integer, Integer&gt; computable = (key) -&gt; &#123;</span><br><span class=\"line\">            // 模拟费时计算过程</span><br><span class=\"line\">            Thread.sleep(10000);</span><br><span class=\"line\">            <span class=\"built_in\">return</span> key;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        MemCache&lt;Integer, Integer&gt; memCache = new MemCache&lt;&gt;(computable);</span><br><span class=\"line\"></span><br><span class=\"line\">        CyclicBarrier cyclicBarrier = new CyclicBarrier(1, () -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (int i = 0; i &lt; 6; i++) &#123;</span><br><span class=\"line\">                new Thread(() -&gt; &#123;</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        long startTime = System.currentTimeMillis();</span><br><span class=\"line\">                        memCache.compute(99);</span><br><span class=\"line\">                        long endTime = System.currentTimeMillis();</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"从缓存中取值线程执行时间为：\"</span> + (endTime - startTime));</span><br><span class=\"line\">                    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;).start();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        new Thread(() -&gt; &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                long startTime = System.currentTimeMillis();</span><br><span class=\"line\">                memCache.compute(99);</span><br><span class=\"line\">                long endTime = System.currentTimeMillis();</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"未从缓存中取值线程执行时间为：\"</span> + (endTime - startTime));</span><br><span class=\"line\">                cyclicBarrier.await();</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; catch (BrokenBarrierException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>执行结果</strong><br>未从缓存中取值线程执行时间为：10010<br>从缓存中取值线程执行时间为：0<br>从缓存中取值线程执行时间为：0<br>从缓存中取值线程执行时间为：0<br>从缓存中取值线程执行时间为：0<br>从缓存中取值线程执行时间为：0<br>从缓存中取值线程执行时间为：0</p>\n","categories":["高并发"],"tags":["高并发"]},{"title":"JAVA同步工具类之栅栏","url":"http://www.shenjian.online/2019/02/24/JAVA同步工具类之栅栏/","content":"<p>栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生，CyclicBarrier可以使一定数量的参与方反复的在栅栏处汇集。</p>\n<p>当线程到达栅栏处，将调用CyclicBarrier.await方法，这个方法一直阻塞直到所有线程到达栅栏处，当所有线程到达了栅栏处，栅栏将打开，所有线程被释放，而栅栏被重置以便下次使用。</p>\n<p><strong>栅栏与闭锁区别</strong><br>所有线程必须全部到达栅栏处，才能继续执行；闭锁结束前，不允许线程执行，结束时，允许所有线程执行<br>栅栏等待线程；闭锁等待事件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 栅栏理解代码示例</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CyclicBarrierWorker &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    class Worker implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        private int id;</span><br><span class=\"line\">        private CyclicBarrier cyclicBarrier;</span><br><span class=\"line\"></span><br><span class=\"line\">        public Worker(int id, CyclicBarrier cyclicBarrier) &#123;</span><br><span class=\"line\">            this.id = id;</span><br><span class=\"line\">            this.cyclicBarrier = cyclicBarrier;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"线程\"</span> + id + <span class=\"string\">\"已到达栅栏处\"</span>);</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                cyclicBarrier.await();</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; catch (BrokenBarrierException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        CyclicBarrier cyclicBarrier = new CyclicBarrier(10, () -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"所有线程已到达栅栏处, 2333\"</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            new Thread(new CyclicBarrierWorker().new Worker(i, cyclicBarrier)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>运行结果</strong></p>\n<p>线程0已到达栅栏处<br>线程4已到达栅栏处<br>线程3已到达栅栏处<br>线程2已到达栅栏处<br>线程1已到达栅栏处<br>线程6已到达栅栏处<br>线程8已到达栅栏处<br>线程7已到达栅栏处<br>线程5已到达栅栏处<br>线程9已到达栅栏处<br>所有线程已到达栅栏处, 2333</p>\n","categories":["多线程"],"tags":["多线程"]},{"title":"JAVA同步工具类之信号量","url":"http://www.shenjian.online/2019/02/24/JAVA同步工具类之信号量/","content":"<p>计数信号量(Counting Semaphore)用来控制同时访问某个资源的操作数量。信号量还可以实现资源池，为容器设置边界。</p>\n<p>Semaphore管理着一组虚拟的许可，许可的初始数量可以通过构造函数来指定。acquire获取许可，没有许可则阻塞直到有许可，release将返回一个许可给信号量。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 使用Semaphore为容器设置边界</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class BoundedHashSet&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final Set&lt;T&gt; <span class=\"built_in\">set</span>;</span><br><span class=\"line\">    private final Semaphore semaphore;</span><br><span class=\"line\"></span><br><span class=\"line\">    public BoundedHashSet(int bound) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">set</span> = Collections.synchronizedSet(new HashSet&lt;&gt;());</span><br><span class=\"line\">        semaphore = new Semaphore(bound);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean add(T e) throws InterruptedException &#123;</span><br><span class=\"line\">        semaphore.acquire();</span><br><span class=\"line\">        boolean wasAdded = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            wasAdded = set.add(e);</span><br><span class=\"line\">            <span class=\"built_in\">return</span> wasAdded;</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!wasAdded) &#123;</span><br><span class=\"line\">                semaphore.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean remove(Object o) &#123;</span><br><span class=\"line\">        boolean wasRemoved = set.remove(o);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wasRemoved) &#123;</span><br><span class=\"line\">            semaphore.release();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> wasRemoved;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["多线程"],"tags":["多线程"]},{"title":"JAVA同步工具类之闭锁","url":"http://www.shenjian.online/2019/02/24/JAVA同步工具类之闭锁/","content":"<p>闭锁是一种同步工具类，可以延迟线程的进度直到其到达终止状态。<br>闭锁相当于一扇门，在闭锁结束之前，这扇门一直关闭，没有任何线程能够通过；当闭锁结束时，这扇门打开，所有的线程均可通过</p>\n<p>闭锁状态包括一个计数器，该计数器初始化为一个正数，表示需要等待的事件数量。countDown方法递减计数器，表示一个事件已经发生，如果计数器非零，则await方法等待计数器为零，或等待中的线程中断或者等待超时。</p>\n<p>闭锁是一次性对象，一旦进入终止状态，就不能被重置。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package concurrent.module;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.concurrent.CountDownLatch;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 闭锁实现统计多个线程执行时间</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class TestHarness &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   public long timeTasks(int nThreads, final Runnable task) throws InterruptedException &#123;</span><br><span class=\"line\">       CountDownLatch startGate = new CountDownLatch(1);</span><br><span class=\"line\">       CountDownLatch endGate = new CountDownLatch(nThreads);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">for</span> (int i = 0 ; i &lt; nThreads; i++) &#123;</span><br><span class=\"line\">           new Thread(() -&gt; &#123;</span><br><span class=\"line\">               try &#123;</span><br><span class=\"line\">                   startGate.await();</span><br><span class=\"line\">                   try &#123;</span><br><span class=\"line\">                       task.run();</span><br><span class=\"line\">                   &#125; finally &#123;</span><br><span class=\"line\">                       endGate.countDown();</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                   e.printStackTrace();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;).start();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       long startTime = System.nanoTime();</span><br><span class=\"line\">       startGate.countDown();</span><br><span class=\"line\">       endGate.await();</span><br><span class=\"line\">       long endTime = System.nanoTime();</span><br><span class=\"line\">       <span class=\"built_in\">return</span> endTime - startTime;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">       Runnable runnable = () -&gt; &#123;</span><br><span class=\"line\">           <span class=\"keyword\">for</span> (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\">        long time = new TestHarness().timeTasks(4, runnable);</span><br><span class=\"line\">        System.out.println(time);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["多线程"],"tags":["多线程"]},{"title":"队列和生产者-消费者模式","url":"http://www.shenjian.online/2019/02/24/阻塞队列和生产者-消费者模式/","content":"<h2 id=\"1-阻塞队列\"><a href=\"#1-阻塞队列\" class=\"headerlink\" title=\"1. 阻塞队列\"></a>1. 阻塞队列</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 桌面搜索应用中的生产者任务和消费者任务</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class FileCrawler implements Runnable&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final BlockingQueue&lt;File&gt; queue;</span><br><span class=\"line\">    private final FileFilter fileFilter;</span><br><span class=\"line\">    private final File root;</span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            crawl(root);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void crawl(File root) throws InterruptedException &#123;</span><br><span class=\"line\">        File[] files = root.listFiles(fileFilter);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (files != null) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (File file: files) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (file.isDirectory()) &#123;</span><br><span class=\"line\">                    crawl(file);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!alreadyIndexed(file))&#123;</span><br><span class=\"line\">                    queue.put(file);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 索引建立</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class Indexer implements Runnable&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final BlockingQueue&lt;File&gt; fileQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Indexer(BlockingQueue&lt;File&gt; fileQueue) &#123;</span><br><span class=\"line\">        this.fileQueue = fileQueue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                indexFile(fileQueue.take());</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 应用启动</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class Window &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">startIndexing</span></span>() &#123;</span><br><span class=\"line\">        BlockingQueue&lt;File&gt; fileQueue = new ArrayBlockingQueue&lt;&gt;(8);</span><br><span class=\"line\">        FileFilter fileFilter = (pathname) -&gt; &#123; <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        String path =  <span class=\"string\">\"src\"</span> + File.separator + <span class=\"string\">\"main\"</span> + File.separator + <span class=\"string\">\"resources\"</span> +</span><br><span class=\"line\">                File.separator + <span class=\"string\">\"concurrent\"</span>;</span><br><span class=\"line\">        File root = new File(path);</span><br><span class=\"line\"></span><br><span class=\"line\">        new Thread(new FileCrawler(fileQueue, fileFilter, root)).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (int i = 0; i &lt; 3; i++) &#123;</span><br><span class=\"line\">            new Thread(new Indexer(fileQueue)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-双端队列\"><a href=\"#2-双端队列\" class=\"headerlink\" title=\"2. 双端队列\"></a>2. 双端队列</h2><p>JAVA6新增两种容器类型，Deque与BlockingDeque，分别为Queue与BlockingQueue的扩展。 Deque是一种双端队列，实现了队列头和队列尾的高效插入与删除，具体实现包括ArrayDeque和LinkedBlockingDeque.</p>\n<p><strong>工作密取</strong> 在生产者-消费者设计中，所有的消费者拥有一个工作队列，而在工作密取中，每个消费者拥有一个双端队列，如果消费者完成自己双端队列的工作，则可以从其他消费者双端队列末尾秘密的获取工作。</p>\n","categories":["多线程"],"tags":["多线程"]},{"title":"CopyOnWriteArrayList实现原理","url":"http://www.shenjian.online/2019/02/23/CopyOnWriteArrayList实现原理/","content":"<h2 id=\"1-实现原理\"><a href=\"#1-实现原理\" class=\"headerlink\" title=\"1. 实现原理\"></a>1. 实现原理</h2><p>CopyOnWriteArrayList是线程安全且读操作无锁的ArrayList,写操作则通过创建底层数组的新副本来实现，是一种<strong>读写分离</strong>的并发策略。对于写操作，比如向容器中添加一个元素，首先将当前容器复制一份，然后在新副本上执行写操作，然后将原容器的引用指向新容器</p>\n<h2 id=\"2-优点\"><a href=\"#2-优点\" class=\"headerlink\" title=\"2. 优点\"></a>2. 优点</h2><p>读操作不加锁，性能很高，适合<strong>读多写少</strong>的并发场景，使用迭代器遍历时候，不会抛出ConcurrentModificationException异常</p>\n<h2 id=\"3-缺点\"><a href=\"#3-缺点\" class=\"headerlink\" title=\"3. 缺点\"></a>3. 缺点</h2><p>1）内存占用问题 每次写操作都要创建底层数组的新副本，当数据量大时，内存压力较大，可能引起频繁GC<br>2）无法保证实时性 写和读操作作用在不同的容器上，在写做操作执行的过程中，读操作不会阻塞但是会读取到老容器的数据</p>\n<h2 id=\"4-源码分析\"><a href=\"#4-源码分析\" class=\"headerlink\" title=\"4. 源码分析\"></a>4. 源码分析</h2><p>add/remove方式使用<code>ReentrantLock</code>，操作前lock(),操作时Arrays.copyOf进行数组拷贝,操作后unlock()</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean add(E e) &#123;</span><br><span class=\"line\">        final ReentrantLock lock = this.lock;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Object[] elements = getArray();</span><br><span class=\"line\">            int len = elements.length;</span><br><span class=\"line\">            Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class=\"line\">            newElements[len] = e;</span><br><span class=\"line\">            setArray(newElements);</span><br><span class=\"line\">            <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public E remove(int index) &#123;</span><br><span class=\"line\">     final ReentrantLock lock = this.lock;</span><br><span class=\"line\">     lock.lock();</span><br><span class=\"line\">     try &#123;</span><br><span class=\"line\">         Object[] elements = getArray();</span><br><span class=\"line\">         int len = elements.length;</span><br><span class=\"line\">         E oldValue = get(elements, index);</span><br><span class=\"line\">         int numMoved = len - index - 1;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (numMoved == 0)</span><br><span class=\"line\">             setArray(Arrays.copyOf(elements, len - 1));</span><br><span class=\"line\">         <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">             Object[] newElements = new Object[len - 1];</span><br><span class=\"line\">             System.arraycopy(elements, 0, newElements, 0, index);</span><br><span class=\"line\">             System.arraycopy(elements, index + 1, newElements, index,</span><br><span class=\"line\">                              numMoved);</span><br><span class=\"line\">             setArray(newElements);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"built_in\">return</span> oldValue;</span><br><span class=\"line\">     &#125; finally &#123;</span><br><span class=\"line\">         lock.unlock();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>读操作时无需加锁，直接读取</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private E get(Object[] a, int index) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> (E) a[index];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["高并发"],"tags":["高并发","面试"]},{"title":"ConcurrentHashMap的实现原理","url":"http://www.shenjian.online/2019/02/14/ConcurrentHashMap的实现原理/","content":"<h2 id=\"1-哈希表\"><a href=\"#1-哈希表\" class=\"headerlink\" title=\"1. 哈希表\"></a>1. 哈希表</h2><h3 id=\"1-1-介绍\"><a href=\"#1-1-介绍\" class=\"headerlink\" title=\"1.1 介绍\"></a>1.1 介绍</h3><p>哈希表是一种key-value存储数据的结构，根据key即可查到对应的value。<br>如果所有的键是整数，我们可用简单的无序数组来表示，键作为数组索引，值即为对应的值</p>\n<h3 id=\"1-2-链式哈希表\"><a href=\"#1-2-链式哈希表\" class=\"headerlink\" title=\"1.2 链式哈希表\"></a>1.2 链式哈希表</h3><p>链式哈希表本质由一组链表构成。每个链表可以看作一个桶，将键传入哈希函数(该过程称为哈希键)，函数通过散列的方式告知元素属于哪个桶，然后在相应的链表头插入元素。查找与删除，以同样的方式先找到桶，然后遍历链表得到想要的元素。<br>由于每个桶都是一个链表，所以链式哈希表不限制元素的个数，但是，如果表变的特别大，则性能会降低</p>\n<p><img src=\"/2019/02/14/ConcurrentHashMap的实现原理/链式哈希表结构.jpg\" alt=\"链式哈希表结构图\"></p>\n<h3 id=\"1-3-应用场景\"><a href=\"#1-3-应用场景\" class=\"headerlink\" title=\"1.3 应用场景\"></a>1.3 应用场景</h3><p>缓存技术（redis、memcached）在内存中维护一个巨大的哈希表，还有HashMap、ConcurrentHashMap</p>\n<h2 id=\"2-ConcurrentHashMap与HashMap等的区别\"><a href=\"#2-ConcurrentHashMap与HashMap等的区别\" class=\"headerlink\" title=\"2. ConcurrentHashMap与HashMap等的区别\"></a>2. ConcurrentHashMap与HashMap等的区别</h2><p><strong>HashMap</strong></p>\n<p>HashMap<a href=\"https://shenjian.online/2019/11/01/%E8%85%BE%E8%AE%AF%E7%AF%87%E4%B9%8BJAVA%E5%9F%BA%E7%A1%80/#6-1-%E4%B8%BA%E4%BB%80%E4%B9%88HashMap%E6%98%AF%E9%9D%9E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9F\" target=\"_blank\" rel=\"noopener\">线程不安全</a>，在多线程情况下，执行HashMap的get操作会引起死循环，导致CPU利用率接近100%</p>\n<p><strong>HashTable</strong> (太保面试题)</p>\n<p>HashMap线程不安全，HashTable线程安全<br>HashMap允许key、value为null,HashTable不允许<br>HashMap把HashTable的contains方法去掉，改为containsKey和containsValue<br>HashMap继承自Dictionary，HashMap继承自AbstractMap<br>HashMap的迭代器Iterator是快速失败的，HashTable的Enumerator非快速失败</p>\n<p><strong>ConcurrentHashMap</strong></p>\n<p>Map一般都是数组+链表结构（JDK1.8改为数组+红黑树）</p>\n<p><img src=\"/2019/02/14/ConcurrentHashMap的实现原理/Map结构.jpg\" alt=\"Map结构图\"></p>\n<p>ConcurrentHashMap避免了全局加锁而改用局部加锁，极大的提高了并发环境下的操作速度；<br>大量的使用了volatile、final、CAS等lock-free技术来减少竞争对性能带来的影响</p>\n<h2 id=\"3-JDK1-7-1-8的ConcurrentHashMap实现原理\"><a href=\"#3-JDK1-7-1-8的ConcurrentHashMap实现原理\" class=\"headerlink\" title=\"3. JDK1.7 1.8的ConcurrentHashMap实现原理\"></a>3. JDK1.7 1.8的ConcurrentHashMap实现原理</h2><p><strong>JDK1.7 ConcurrentHashMap实现原理</strong></p>\n<p>在JDK1.7中ConcurrentHashMap采用数组+Segment+分段锁的方式实现</p>\n<h3 id=\"3-1-Segment-分段锁\"><a href=\"#3-1-Segment-分段锁\" class=\"headerlink\" title=\"3.1 Segment(分段锁)\"></a>3.1 Segment(分段锁)</h3><p>ConcurrentHashMap中的分段锁称为Segment.它类似HashMap的结构，内部拥有一个Entry数组，数组中的每个元素又是一个链表，同时又是一个ReentrantLock(Segment继承了ReentrantLock)</p>\n<h3 id=\"3-2-内部结构\"><a href=\"#3-2-内部结构\" class=\"headerlink\" title=\"3.2 内部结构\"></a>3.2 内部结构</h3><p>Concurrent使用分段锁机制，将数据一段一段的存储，然后给每一段数据加锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据可以被其他线程访问，能够实现真正的并发访问。</p>\n<p><img src=\"/2019/02/14/ConcurrentHashMap的实现原理/ConcurrentHashMap内部结构图.jpg\" alt=\"ConcurrentHashMap内部结构图\"></p>\n<p>由图可见，ConcurrentHashMap定位一个元素需要经过两次hash过程：第一次定位到Segmnent,第二次定位到元素所在的链表的头部</p>\n<h3 id=\"3-3-该结构的优缺点\"><a href=\"#3-3-该结构的优缺点\" class=\"headerlink\" title=\"3.3 该结构的优缺点\"></a>3.3 该结构的优缺点</h3><p>缺点：Hash的过程要比普通的HashMap要长<br>优点：写操作时只对元素所在的Segment进行加锁即可，不会影响到其他Segment,在最理想的情况下,ConcurrentHashMap可以最高同时支持Segment数量大小的写操作（写操作非常平均的分布在所有Segment上）。所以，通过这种结构，ConcurrentHashMap并发能力大大提高。</p>\n<p><strong>JDK1.8 ConcurrentHashMap实现原理</strong></p>\n<p>1) JDK8中ConcurrentHashMap的实现参考了JDK8中HashMap的实现，采用了<strong>数组+链表+红黑树</strong>的实现方式，内部大量采用<strong>CAS操作</strong>。</p>\n<p>CAS是compare and swap的缩写，即比较并交换。CAS是一种基于锁的操作，而且是乐观锁。在JAVA中分为乐观锁与悲观锁，悲观锁将资源锁住，等释放后下一个线程才可以进行访问，而乐观锁采用一种宽泛的方式进行处理，通过某种方式不加锁来处理资源，比如通过给记录加version来获取资源，性能较悲观锁有很大提高。<br>CAS操作包含三个操作数–内存位置(V)，预期原值(A)和新值(B), 如果内存地址里的值与A相同，则将值更新为B。CAS是通过无限循环来获取数据的，如果在第一轮循环中，a线程获取地址里的值被b线程修改了，呢么a线程需要自旋，到下次循环时才有可能执行</p>\n<p>2) JDK8中彻底放弃了Segment转而采用Node,其设计思想不在是JDK7中分段锁的思想</p>\n<p>Node: 保存key,value和key的hash值的数据结构，value与next都用volatile修饰，保证了并发的可见性</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">    final int <span class=\"built_in\">hash</span>;</span><br><span class=\"line\">    final K key;</span><br><span class=\"line\">    volatile V val;</span><br><span class=\"line\">    volatile Node&lt;K,V&gt; next;</span><br><span class=\"line\">    //... 省略部分代码</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3）JDK8中ConcurrentHashMap在链表的长度大于某个阈值(默认为8)的时候会将链表O(n)转化为红黑树O(logN)进一步提高查找性能</p>\n<p><img src=\"/2019/02/14/ConcurrentHashMap的实现原理/链表红黑树.jpg\" alt=\"链表红黑树\"></p>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4 总结\"></a>4 总结</h2><p><strong>数据结构</strong> JDK7采用数组+Segment的段锁的数据结构，JDK8采用数组+链表+红黑树的数据结构<br><strong>线程安全机制</strong> JDK7采用Segment分段锁实现线程安全，其中Segment继承ReentrantLock. JDK8采用CAS+synchronized保证线程安全<br><strong>锁的粒度</strong> JDK7对Segment进行加锁，JDK8对数组中每个元素(Node)加锁<br><strong>查询时间复杂度</strong> 遍历链表O(N), 红黑树(O(logN))</p>\n<p>ps: 参考 <a href=\"http://youzhixueyuan.com/concurrenthashmap.html\" target=\"_blank\" rel=\"noopener\">http://youzhixueyuan.com/concurrenthashmap.html</a></p>\n","categories":["高并发"],"tags":["高并发","面试"]},{"title":"浏览器间接性崩溃服务器400错误排查分析","url":"http://www.shenjian.online/2019/02/14/浏览器间接性崩溃服务器400错误排查分析/","content":"<h2 id=\"1-问题现象描述\"><a href=\"#1-问题现象描述\" class=\"headerlink\" title=\"1. 问题现象描述\"></a>1. 问题现象描述</h2><p>最近谷歌浏览器间接性的崩溃，服务器400错误，所用livebos-tomcat为6.5</p>\n<h2 id=\"2-排查过程\"><a href=\"#2-排查过程\" class=\"headerlink\" title=\"2. 排查过程\"></a>2. 排查过程</h2><p>多次记录出现错误的日期，搜索上下文，未发现任何服务器报错的信息；<br>恰好计划tomcat升级为livebos-tomcat8.5，故优先升级tomcat为8.5；<br>后仍然出现该错误，只不过有了错误提示： java.lang.IllegalArgumentException: Request header is too large<br>联想最近开发的新功能rest方式调用oa接口，流程传递json串，可能因为json串的过长原因导致；</p>\n<h2 id=\"3-解决方案\"><a href=\"#3-解决方案\" class=\"headerlink\" title=\"3. 解决方案\"></a>3. 解决方案</h2><p><strong>普通tomcat</strong> </p>\n<p>在server.xml中 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Connector connectionTimeout=<span class=\"string\">\"20000\"</span> port=<span class=\"string\">\"8080\"</span> protocol=<span class=\"string\">\"HTTP/1.1\"</span> redirectPort=<span class=\"string\">\"8443\"</span> maxPostSize=<span class=\"string\">\"0\"</span> maxHttpHeaderSize =<span class=\"string\">\"102400\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n<p>处加上maxHttpHeaderSize =”102400”</p>\n<p><strong>SpringBoot</strong></p>\n<p>在application.properties文件中添加 <code>server.max-http-header-size=102400</code></p>\n","categories":["工作干货"],"tags":["工作干货"]},{"title":"50_Pow(x,n)_leetcode","url":"http://www.shenjian.online/2019/02/13/50-Pow(x,n)-leetcode/","content":"<p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p>\n<blockquote>\n<p>输入: 2.00000, 10<br>输出: 1024.00000<br>输入: 2.10000, 3<br>输出: 9.26100<br>输入: 2.00000, -2<br>输出: 0.25000<br>解释: 2-2 = 1/22 = 1/4 = 0.25<br>说明:-100.0 &lt; x &lt; 100.0<br>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</p>\n</blockquote>\n<p><strong>题解：</strong>  快速幂算法（循环）<br>x^n次方，n在二进制中可表示为10010形式，即2^4+2^1,那么我们可利用位运算求解<br>则x^n=x^(2^4) + x^(2^1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">myPow</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> N = n;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            x = <span class=\"number\">1</span> / x;</span><br><span class=\"line\">            N = -N;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> res = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> temp = x;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (N &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前末位二进制为1，则为解的一部分</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((N &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                res *= temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 每次右移一位基值平方,如x^(2^4)、 x^(2^1)</span></span><br><span class=\"line\">            temp *= temp;</span><br><span class=\"line\">            N &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AC传送门<a href=\"https://leetcode-cn.com/problems/powx-n/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n","categories":["算法与数据结构"],"tags":["算法与数据结构","Leetcode"]},{"title":"浅谈栈帧结构","url":"http://www.shenjian.online/2019/01/29/浅谈栈帧结构/","content":"<p><img src=\"/2019/01/29/浅谈栈帧结构/jvmStack.jpg\" alt=\"虚拟机内存结构\"></p>\n<h2 id=\"1-虚拟机栈在运行时数据区位置\"><a href=\"#1-虚拟机栈在运行时数据区位置\" class=\"headerlink\" title=\"1. 虚拟机栈在运行时数据区位置\"></a>1. 虚拟机栈在运行时数据区位置</h2><p>如图所示，JAVA虚拟机栈与本地方法栈及程序计数器为线程私有； 方法区与JAVA堆为线程共享，以上共同组成了运行时数据区。</p>\n<h2 id=\"2-何为栈帧\"><a href=\"#2-何为栈帧\" class=\"headerlink\" title=\"2. 何为栈帧\"></a>2. 何为栈帧</h2><p>虚拟机栈包含栈帧。 一个方法开始执行的时候同时会在栈空间中创建一个栈帧，一个方法的调用与执行完成对应一个栈帧的入栈与出栈</p>\n<h2 id=\"3-栈帧结构\"><a href=\"#3-栈帧结构\" class=\"headerlink\" title=\"3. 栈帧结构\"></a>3. 栈帧结构</h2><p><img src=\"/2019/01/29/浅谈栈帧结构/jvmStackFrame.jpg\" alt=\"栈帧结构\"></p>\n<p><strong>局部变量表</strong> 局部变量表以变量槽(slot)为最小存储单位。</p>\n<p>存储类型：</p>\n<ul>\n<li>基本数据类型： byte/boolean/char/short/int/float/long/double 由于每个slot只能存32位，故long/double需要2个slot存储</li>\n<li>reference类型: </li>\n<li>returnAddress类型：</li>\n</ul>\n<p><strong>操作数栈</strong></p>\n<ul>\n<li>是一个先入后出的栈</li>\n<li>JAVA虚拟机的解释执行引擎称为”基于栈的执行引擎”，其中所指的栈就是操作数栈</li>\n</ul>\n<p><strong>动态链接</strong></p>\n<p>在运行时创建的直接引用称为动态链接。 每一个栈帧都包含有一个指向运行时常量池该栈帧所属方法的引用，该引用就是为了方法调用过程中的动态链接。</p>\n<p><strong>返回地址</strong></p>\n<p>方法开始后有两种方式退出：正常退出和异常退出</p>\n<p><em>正常退出：</em> 执行引擎遇到任意一个方法返回的字节码指令，如ftreturn、dreturn，可能有返回值返回给方法上一层调用者<br><em>异常退出：</em> 无论是JAVA虚拟机内部的产生的异常，还是代码中使用athrow产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。异常退出无返回值返回给方法上一层调用者。</p>\n","categories":["JVM"],"tags":["面试"]},{"title":"JAVA程序启动至少会启动几个线程","url":"http://www.shenjian.online/2019/01/28/JAVA程序启动至少会启动几个线程/","content":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class=\"line\">   ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class=\"literal\">false</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class=\"line\">   \tSystem.out.println(threadInfo.getThreadId() + <span class=\"string\">\":\"</span> + threadInfo.getThreadName());</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>JDK1.8 执行结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6:Monitor Ctrl-Break</span><br><span class=\"line\">5:Attach Listener 接收外部JVM命令</span><br><span class=\"line\">4:Signal Dispatcher 分发到不同的模块进行处理外部JVM命令，并且返回处理结结果</span><br><span class=\"line\">3:Finalizer <span class=\"comment\"># 调用对象的finalize方法的线程，即垃圾回收的线程</span></span><br><span class=\"line\">2:Reference Handler <span class=\"comment\"># 清除reference的线程</span></span><br><span class=\"line\">1:main <span class=\"comment\"># 主线程</span></span><br></pre></td></tr></table></figure>\n<p>查看以上线程所属线程组及优先级</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Thread threadOne = new Thread(() -&gt; &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.sleep(2000);</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        threadOne.setName(<span class=\"string\">\"threadOne\"</span>);</span><br><span class=\"line\">        threadOne.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        ThreadGroup threadGroup = threadOne.getThreadGroup();</span><br><span class=\"line\">        System.out.println(threadGroup);</span><br><span class=\"line\"></span><br><span class=\"line\">        ThreadGroup systemThreadGroup = threadGroup.getParent();</span><br><span class=\"line\">        System.out.println(systemThreadGroup);</span><br><span class=\"line\"></span><br><span class=\"line\">        systemThreadGroup.list();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.ThreadGroup[name=main,maxpri=10]</span><br><span class=\"line\">java.lang.ThreadGroup[name=system,maxpri=10]</span><br><span class=\"line\">java.lang.ThreadGroup[name=system,maxpri=10]</span><br><span class=\"line\">    Thread[Reference Handler,10,system]</span><br><span class=\"line\">    Thread[Finalizer,8,system]</span><br><span class=\"line\">    Thread[Signal Dispatcher,9,system]</span><br><span class=\"line\">    Thread[Attach Listener,5,system]</span><br><span class=\"line\">    java.lang.ThreadGroup[name=main,maxpri=10]</span><br><span class=\"line\">        Thread[main,5,main]</span><br><span class=\"line\">        Thread[Monitor Ctrl-Break,5,main]</span><br><span class=\"line\">        Thread[threadOne,5,main]</span><br></pre></td></tr></table></figure>\n<p>由此看来，当一个应用程序启动时，至少创建6个线程，两个线程组(system和main线程组)，其中system线程组是main线程组的父线程组，main与Monitor Ctrl-Break处于main线程组，其他线程处于system线程组。</p>\n","categories":["多线程"],"tags":["多线程","面试"]},{"title":"线程简介及安全性","url":"http://www.shenjian.online/2019/01/27/线程简介及安全性/","content":"<h2 id=\"1-线程的优点\"><a href=\"#1-线程的优点\" class=\"headerlink\" title=\"1. 线程的优点\"></a>1. 线程的优点</h2><p><strong>1）发挥多处理器的强大功能</strong><br><strong>2）建模的简单性</strong>  为模型中的每种类型任务都分配一个专门的线程<br><strong>3）异步事件的简化处理</strong><br><strong>4）响应更灵敏的用户界面</strong> </p>\n<h2 id=\"2-线程带来的风险\"><a href=\"#2-线程带来的风险\" class=\"headerlink\" title=\"2. 线程带来的风险\"></a>2. 线程带来的风险</h2><p><strong>1）安全性问题</strong><br><strong>2）活跃性问题</strong> 如发生死锁，无限等待<br><strong>3）性能问题</strong> 如频繁的上下文切换：保存与恢复上下文，丢失局部性，CPU花在线程切换上更多开销而不是线程上；如同步机制，抑制某些编译器优化，使内存缓存区内存无效，增加共享内存总线流量</p>\n<h2 id=\"3-线程安全性\"><a href=\"#3-线程安全性\" class=\"headerlink\" title=\"3. 线程安全性\"></a>3. 线程安全性</h2><p>如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：<br>&radic; 不在线程之间共享该变量<br>&radic; 将状态变量修改为不可变变量<br>&radic; 在访问状态变量时使用同步</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">无状态对象一定是线程安全的。</span><br><span class=\"line\">无状态对象：他既不包含任何域，也不包含对其他类中域的引用</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">竞态条件： 由于不恰当的执行时序而出现的不正确的结果</span><br><span class=\"line\">竞态条件出现常见操作： 先检查后执行，如延迟初始化； 读取-修改-写入， 如i++</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-内置锁与重入\"><a href=\"#3-1-内置锁与重入\" class=\"headerlink\" title=\"3.1 内置锁与重入\"></a>3.1 内置锁与重入</h3><p>JAVA中提供了一种内置锁机制支持原子性：同步代码块<br>同步代码块分为两部分：<br>1）锁的对象引用 <code>synchronized (lock) { }</code><br>2）锁保护的代码块</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void synchronized <span class=\"function\"><span class=\"title\">count</span></span>() &#123;</span><br><span class=\"line\">\t.....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>内置锁是可重入的，如果某个线程试图获得该线程已经获得的锁，那么该请求会成功<br>重入实现方式： 为每个锁关联一个获取计数器与一个所有者线程，线程进入则+1，线程退出则-1。当计数器为0，该锁将被释放</p>\n<h3 id=\"3-2-活跃性与性能\"><a href=\"#3-2-活跃性与性能\" class=\"headerlink\" title=\"3.2 活跃性与性能\"></a>3.2 活跃性与性能</h3><p><strong>当实现某个同步策略时，一定不要盲目为了性能而牺牲简单性（这可能会破环安全性）</strong></p>\n<p><strong>当执行时间较长的计算或者可能无法完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁</strong></p>\n","categories":["多线程"],"tags":["多线程"]},{"title":"数组","url":"http://www.shenjian.online/2019/01/25/数组/","content":"<h2 id=\"1-数组注意事项\"><a href=\"#1-数组注意事项\" class=\"headerlink\" title=\"1. 数组注意事项\"></a>1. 数组注意事项</h2><p><strong> 1) 通常假设数组是没有空元素</strong> 当我们查找某一元素时，如果查找了所有元素后也没有找到，就说明数组中不包含该元素。但如何确定所有元素都查找完了呢？只要我们保证所有数组中所有非空元素都排在前面，呢么当遇到第一个空元素时，则证明所有元素均已查找完毕<br><strong> 2) 当删除一个元素时，这个元素之后的所有元素均向前移动一位</strong> 在java中，就是移除数组对这个对象的引用，就是将对应的对应的位置为null,又根据第1条原则，故之后非空元素需向前移动一位<br><strong> 3) 如果是无序数组的话，添加一个元素时，总是添加在数组的最后位置</strong> 根据原则1，如果数组还剩余两个位置，不可添加到第二个位置，否则会有空元素<br><strong> 4) 通常假设数组中没有相同的元素</strong> 在数组中查找一元素时，如果有多个相同的元素值，返回单个值，还是多个值？我们通常假设数组中没有相同的元素，只需要返回第一个匹配到的值即可</p>\n<h2 id=\"2-数组复杂度\"><a href=\"#2-数组复杂度\" class=\"headerlink\" title=\"2. 数组复杂度\"></a>2. 数组复杂度</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">操作</th>\n<th style=\"text-align:center\">时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">插入</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">查找</td>\n<td style=\"text-align:center\">O(n)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">删除</td>\n<td style=\"text-align:center\">O(n)</td>\n</tr>\n</tbody>\n</table>\n","categories":["算法与数据结构"],"tags":["算法与数据结构"]},{"title":"Spring与SpringMVC父子容器","url":"http://www.shenjian.online/2019/01/22/Spring与SpringMVC父子容器/","content":"<h2 id=\"1-父子容器概念\"><a href=\"#1-父子容器概念\" class=\"headerlink\" title=\"1. 父子容器概念\"></a>1. 父子容器概念</h2><p><strong>Servlet WebApplicationContext:</strong> 主要针对Web层，如控制器(Controller)、视图解析器(View Resolvers)等相关bean。通过SpringMVC提供的DispatcherServlet加载配置，通常配置文件名为spring-servlet.xml。<br><strong>Root WebApplicationContext:</strong> 主要针对Service层、Dao层，如业务bean、数据源等。在web应用中，一般通过ContextLoaderListener加载配置，通常配置文件名为applicationContext.xml。</p>\n<p>附上web.xml配置案例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&lt;web-app version=<span class=\"string\">\"3.0\"</span> xmlns=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee\"</span>  </span><br><span class=\"line\">    xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>  </span><br><span class=\"line\">    xsi:schemaLocation=<span class=\"string\">\"http://java.sun.com/xml/ns/javaeehttp://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"</span>&gt;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;!— 创建Root WebApplicationContext --&gt;</span><br><span class=\"line\">    &lt;context-param&gt;  </span><br><span class=\"line\">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  </span><br><span class=\"line\">        &lt;param-value&gt;/WEB-INF/spring/applicationContext.xml&lt;/param-value&gt;  </span><br><span class=\"line\">    &lt;/context-param&gt;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &lt;listener&gt;  </span><br><span class=\"line\">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  </span><br><span class=\"line\">    &lt;/listener&gt;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;!— 创建Servlet WebApplicationContext --&gt;</span><br><span class=\"line\">    &lt;servlet&gt;  </span><br><span class=\"line\">        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;  </span><br><span class=\"line\">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  </span><br><span class=\"line\">        &lt;init-param&gt;  </span><br><span class=\"line\">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  </span><br><span class=\"line\">            &lt;param-value&gt;/WEB-INF/spring/spring-servlet.xml&lt;/param-value&gt;  </span><br><span class=\"line\">        &lt;/init-param&gt;  </span><br><span class=\"line\">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  </span><br><span class=\"line\">    &lt;/servlet&gt;  </span><br><span class=\"line\">    &lt;servlet-mapping&gt;  </span><br><span class=\"line\">        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;  </span><br><span class=\"line\">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  </span><br><span class=\"line\">    &lt;/servlet-mapping&gt;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>\n<p>1、 contextLoaderListener首先被初始化，根据<context-param>元素中contextConfigLocation参数指定的配置文件路径，来创建 Root WebApplicationContext实例,并调用ServletContext中的setAttribute方法，设置key为‘org.springframework.web.context.WebApplicationContext.ROOT’， value为该WebApplicationContext实例。<br>2、DispatherServlet在初始化时，会根据<init-param>元素中contextConfigLocation参数指定的配置文件路径，创建Servlet WebApplicationContext,同时调用ServletContext的getAttribute方法来判断RootWebApplicationContext是否存在，如果存在，则设置为自己的parent。这就是父子容器的概念</init-param></context-param></p>\n<h2 id=\"2-父子容器的作用\"><a href=\"#2-父子容器的作用\" class=\"headerlink\" title=\"2. 父子容器的作用\"></a>2. 父子容器的作用</h2><p>1）查找bean时，先从子容器找，如果子容器中找不到且父容器非空，则从父容器中找到bean<br>2）SRP职责分离，解耦。Servlet WebApplicationContext主要针对Web层，而web层有多种选择如Spring MVC, Struts，这样即使web层框架改变并不会影响到Root WebApplicationContext中使用的配置文件，同理，dao层改变，也互不影响</p>\n<h2 id=\"3-Root-WebApplicationContext源码主方法\"><a href=\"#3-Root-WebApplicationContext源码主方法\" class=\"headerlink\" title=\"3. Root WebApplicationContext源码主方法\"></a>3. Root WebApplicationContext源码主方法</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ContextLoaderListener extends ContextLoader implements ServletContextListener &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void contextInitialized(ServletContextEvent event) &#123;</span><br><span class=\"line\">        initWebApplicationContext(event.getServletContext());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ContextLoader &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"Root WebApplicationContext: initialization started\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (this.context == null) &#123;</span><br><span class=\"line\">            this.context = createWebApplicationContext(servletContext);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-Servlet-WebApplicationContext源码主方法\"><a href=\"#4-Servlet-WebApplicationContext源码主方法\" class=\"headerlink\" title=\"4. Servlet WebApplicationContext源码主方法\"></a>4. Servlet WebApplicationContext源码主方法</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class HttpServletBean extends HttpServlet</span><br><span class=\"line\">        implements EnvironmentCapable, EnvironmentAware &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public final void init() throws ServletException &#123;</span><br><span class=\"line\">        // Let subclasses <span class=\"keyword\">do</span> whatever initialization they like.</span><br><span class=\"line\">        initServletBean();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    protected void initServletBean() throws ServletException &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class FrameworkServlet extends HttpServletBean implements ApplicationContextAware &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected final void initServletBean() throws ServletException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (this.logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">            this.logger.info(<span class=\"string\">\"FrameworkServlet '\"</span> + getServletName() + <span class=\"string\">\"': initialization started\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        this.webApplicationContext = initWebApplicationContext();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    protected WebApplicationContext <span class=\"function\"><span class=\"title\">initWebApplicationContext</span></span>() &#123;</span><br><span class=\"line\">        // 获取Root WebApplicationContext</span><br><span class=\"line\">        WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class=\"line\">        WebApplicationContext wac = null;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wac == null) &#123;</span><br><span class=\"line\">            // No context instance is defined <span class=\"keyword\">for</span> this servlet -&gt; create a <span class=\"built_in\">local</span> one</span><br><span class=\"line\">            wac = createWebApplicationContext(rootContext);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DispatcherServlet extends FrameworkServlet &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-JAVA方式配置\"><a href=\"#5-JAVA方式配置\" class=\"headerlink\" title=\"5. JAVA方式配置\"></a>5. JAVA方式配置</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface WebApplicationInitializer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    void onStartup(ServletContext servletContext) throws ServletException;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AbstractContextLoaderInitializer implements WebApplicationInitializer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 向ServletContext中注册ContextLoaderListener,从而创建Root WebApplicationContext</span><br><span class=\"line\">     */</span><br><span class=\"line\">    protected void registerContextLoaderListener(ServletContext servletContext) &#123;</span><br><span class=\"line\">        WebApplicationContext rootAppContext = createRootApplicationContext();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rootAppContext != null) &#123;</span><br><span class=\"line\">            ContextLoaderListener listener = new ContextLoaderListener(rootAppContext);</span><br><span class=\"line\">            listener.setContextInitializers(getRootApplicationContextInitializers());</span><br><span class=\"line\">            servletContext.addListener(listener);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            logger.debug(<span class=\"string\">\"No ContextLoaderListener registered, as \"</span> +</span><br><span class=\"line\">                    <span class=\"string\">\"createRootApplicationContext() did not return an application context\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AbstractDispatcherServletInitializer extends AbstractContextLoaderInitializer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">    * 向ServletContext中注册DispatcherServlet，从而创建Servlet WebApplicationContext</span><br><span class=\"line\">    */</span><br><span class=\"line\">    protected void registerDispatcherServlet(ServletContext servletContext) &#123;</span><br><span class=\"line\">        String servletName = getServletName();</span><br><span class=\"line\">        WebApplicationContext servletAppContext = createServletApplicationContext();</span><br><span class=\"line\">        DispatcherServlet dispatcherServlet = createDispatcherServlet(servletAppContext);</span><br><span class=\"line\">        ServletRegistration.Dynamic registration = servletContext.addServlet(servletName, dispatcherServlet);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\">    protected abstract String[] getServletMappings();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AbstractAnnotationConfigDispatcherServletInitializer</span><br><span class=\"line\">        extends AbstractDispatcherServletInitializer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">    protected abstract Class&lt;?&gt;[] getRootConfigClasses();</span><br><span class=\"line\"></span><br><span class=\"line\">    protected abstract Class&lt;?&gt;[] getServletConfigClasses();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 根据Spring以上抽象类的逻辑，实现以下代码</span><br><span class=\"line\">public class MyWebConfigInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //获得创建Root WebApplicationContext所需的配置类</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Class&lt;?&gt;[] <span class=\"function\"><span class=\"title\">getRootConfigClasses</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> new Class&lt;?[] &#123; RootConfig.class &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //获得创建Servlet WebApplicationContext所需的配置类</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Class&lt;?&gt;[] <span class=\"function\"><span class=\"title\">getServletConfigClasses</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> new Class&lt;?[] &#123; ServletConfig.class &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //获得DispatchServlet拦截的url</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected String[] <span class=\"function\"><span class=\"title\">getServletMappings</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> new String[] &#123; <span class=\"string\">\"/app/*\"</span> &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["Spring"],"tags":["Spring"]},{"title":"Spring常见面试题","url":"http://www.shenjian.online/2019/01/20/Spring常见面试题/","content":"<h2 id=\"1-使用Spring框架的好处是？\"><a href=\"#1-使用Spring框架的好处是？\" class=\"headerlink\" title=\"1. 使用Spring框架的好处是？\"></a>1. 使用Spring框架的好处是？</h2><p><strong>轻量</strong>  Spring是轻量的，基本版本约为2M<br><strong>控制反转(IOC)</strong> Spring通过控制反转实现松耦合，对象们给出了依赖，而不是创建与查找依赖的对象们<br><strong>面向切面(AOP)</strong> Spring支持AOP编程，把业务逻辑与系统服务分开<br><strong>容器</strong> Spring管理应用中对象的生命周期与配置<br><strong>MVC框架</strong><br><strong>事务管理</strong> Spring提供事务管理接口，上至本地事务，下至全局事务<br><strong>异常处理</strong> Spring提供API将具体技术相关的异常转化为一致的unchecked异常</p>\n<h2 id=\"2-Spring由哪些模块组成\"><a href=\"#2-Spring由哪些模块组成\" class=\"headerlink\" title=\"2. Spring由哪些模块组成\"></a>2. Spring由哪些模块组成</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring-core  spring-beans  spring-context  spring-aop  spring-expression</span><br><span class=\"line\">spring-jdbc  spring-oxm    spring-tx       spring-web  spring-webmvc</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-ApplicationContext通常的实现是什么？\"><a href=\"#3-ApplicationContext通常的实现是什么？\" class=\"headerlink\" title=\"3. ApplicationContext通常的实现是什么？\"></a>3. ApplicationContext通常的实现是什么？</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPathXmlApplicationContext</span><br><span class=\"line\">FileSystemXmlApplicationContext</span><br><span class=\"line\">WebXmlApplicationContext</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-解释Spring支持的几种bean的作用域\"><a href=\"#4-解释Spring支持的几种bean的作用域\" class=\"headerlink\" title=\"4. 解释Spring支持的几种bean的作用域\"></a>4. 解释Spring支持的几种bean的作用域</h2><p><strong>singleton</strong> 容器中只有一个对应bean实例<br><strong>prototype</strong> 一个bean的定义有多个实例<br><em>以下四种基于web模块下的webApplicationContext</em><br><strong>request</strong><br><strong>session</strong><br><strong>globalSession</strong><br><strong>application</strong></p>\n<h2 id=\"5-Spring框架中的单例bean是线程安全的吗\"><a href=\"#5-Spring框架中的单例bean是线程安全的吗\" class=\"headerlink\" title=\"5. Spring框架中的单例bean是线程安全的吗\"></a>5. Spring框架中的单例bean是线程安全的吗</h2><p>不是</p>\n<h2 id=\"6-解释Spring框架中bean的生命周期\"><a href=\"#6-解释Spring框架中bean的生命周期\" class=\"headerlink\" title=\"6. 解释Spring框架中bean的生命周期\"></a>6. 解释Spring框架中bean的生命周期</h2><p>1) Spring容器从XML文件中读取bean的定义，并实例化bean<br>2) Spring根据bean的定义填充所有属性<br>3) 如果bean实现了BeanNameAware接口，Spring传递bean的Id到setBeanName方法<br>4) 如果bean实现了BeanFactoryAware接口, Spring传递beanFactory到setBeanFactory方法<br>5) 如果bean实现了BeanPostProcessor接口，postProcessorBeforeInitialization方法将被调用<br>6) 如果bean实现了InitializingBean接口，afterPropertiesSet方法被调用；如果bean声明了初始化方法，则调用该初始化方法<br>7) 如果bean实现了BeanPostProcessor接口，postProcessorAfterInitialization方法将被调用<br>8) 如果bean实现了DisposableBean接口，destroy方法将被调用</p>\n","categories":["Spring"],"tags":["面试","Spring"]},{"title":"Linux工作常用命令","url":"http://www.shenjian.online/2019/01/17/Linux工作常用命令/","content":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定位到第一行(连续按两个g)</span></span><br><span class=\"line\">gg</span><br><span class=\"line\"><span class=\"comment\"># 定位到最后一行</span></span><br><span class=\"line\">G</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看软件安装目录</span></span><br><span class=\"line\"><span class=\"built_in\">which</span> ftp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看端口占用情况</span></span><br><span class=\"line\">netstat -anp | grep 端口号</span><br><span class=\"line\">netstat -tunlp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建FTP用户默认登录目录</span></span><br><span class=\"line\">useradd -d /opt/tomcat shenjian</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 密码设置</span></span><br><span class=\"line\">passwd shenjian</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为FTP用户授权目录操作权限</span></span><br><span class=\"line\">chown -hR shenjian /opt/tomcat/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 目录权限设置</span></span><br><span class=\"line\">chmod 755 /opt/tomcat</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压</span></span><br><span class=\"line\"><span class=\"comment\">## -C 指定目标目录</span></span><br><span class=\"line\">tar -zxvf [源文件] -C [目标目录]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 压缩</span></span><br><span class=\"line\">tar -zcvf [目标压缩文件] [源文件]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 本地安装</span></span><br><span class=\"line\">yum localinstall *.rpm</span><br><span class=\"line\"></span><br><span class=\"line\">yum install net-tools <span class=\"comment\"># netstat安装</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># rpm安装</span></span><br><span class=\"line\"><span class=\"comment\">## ivh 安装显示安装进度--install--verbose--hash</span></span><br><span class=\"line\">rpm -ivh XXX.rpm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行post请求</span></span><br><span class=\"line\">curl -v -X POST http://localhost:8772/actuator/bus-refresh</span><br><span class=\"line\"></span><br><span class=\"line\">uname -r <span class=\"comment\"># 查看系统信息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">########## 性能监控调优 ##########</span></span><br><span class=\"line\"><span class=\"comment\"># 线程上下文切换次数查看 </span></span><br><span class=\"line\"><span class=\"comment\">## 1|每秒 10|统计10次, 结果中cs是context switch,即上下文切换次数</span></span><br><span class=\"line\">vmstat 1 10 </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进程PID查看</span></span><br><span class=\"line\">jps</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 转储pid=1159的线程信息至文件dump1</span></span><br><span class=\"line\">jstack 1159 &gt; /opt/temp/dump1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 线程运行状态打印统计</span></span><br><span class=\"line\"><span class=\"comment\">## sort|排序 uniq 去重与空行 -c 统计打印次数 </span></span><br><span class=\"line\">grep java.lang.Thread.State /opt/temp/dump1 | awk <span class=\"string\">'&#123;print $2$3$4$5&#125;'</span> | sort | uniq -c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Linux线程模型查看</span></span><br><span class=\"line\"><span class=\"comment\">## linuxthreads-0.10(该线程模型一个进程限制创建1024个线程) 或者 NPTL 2.12(无限制)</span></span><br><span class=\"line\">getconf GNU_LIBPTHREAD_VERSION</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 操作系统线程栈大小查看 </span></span><br><span class=\"line\"><span class=\"comment\">## 操作系统线程栈默认10M,JVM栈内存默认1M</span></span><br><span class=\"line\"><span class=\"comment\">## 一个Java进程中可以创建的线程数主要是受到JVM可以使用的内存大小的影响，而不是操作系统的总内存。</span></span><br><span class=\"line\"><span class=\"built_in\">ulimit</span> -s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 虚拟机Centos7网络配置及DNS</span></span><br><span class=\"line\"><span class=\"comment\">## ifcfg-ens后可能不一样 /etc/sysconfig/network-scripts/ifcfg-ens32  /etc/sysconfig/network-scripts/ifcfg-lo</span></span><br><span class=\"line\">sudo ls /etc/sysconfig/network-scripts/ifcfg-*</span><br><span class=\"line\">vim /etc/sysconfig/network-scripts/ifcfg-ens32</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># centos7 防火墙</span></span><br><span class=\"line\">firewall-cmd --state <span class=\"comment\"># 查看防火墙状态</span></span><br><span class=\"line\">systemctl stop firewalld.service <span class=\"comment\"># 关闭防火墙</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> firewalld.service <span class=\"comment\"># 禁止开机自启动</span></span><br></pre></td></tr></table></figure>\n<p>以下为windows常用命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看端口占用情况</span></span><br><span class=\"line\">netstat -ano|findstr 端口号</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 强制查杀指定进程 </span></span><br><span class=\"line\"><span class=\"comment\">##-t 终止指定的进程和由它启用的子进程 </span></span><br><span class=\"line\"><span class=\"comment\">##-f 指定强制终止进程</span></span><br><span class=\"line\">taskkill /pid 进程号 -t -f</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查找指定PID并杀死进程</span></span><br><span class=\"line\"><span class=\"comment\">## /f \"tokens=2\"： 文件的第二个属性 %%a： 变量(特别注意，在单独执行命令时使用%a，在脚本中执行时使用%%a) /fi： 过滤 /nh： 不显示列标题</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> /f <span class=\"string\">\"tokens=2\"</span> %%a <span class=\"keyword\">in</span> (<span class=\"string\">'tasklist /fi \"imagename eq soffice.exe\" /nh'</span>) <span class=\"keyword\">do</span> taskkill /pid %%a  -t -f</span><br></pre></td></tr></table></figure>","categories":["Linux"],"tags":["Linux"]},{"title":"Object转JSON日期格式化并保持数据顺序及Value为空Key仍返回","url":"http://www.shenjian.online/2019/01/10/Object转JSON保持数据顺序及Value为空Key仍返回/","content":"<h2 id=\"业务背景\"><a href=\"#业务背景\" class=\"headerlink\" title=\"业务背景\"></a>业务背景</h2><p>（1）项目全景不可配置化，过程修改返回字段前端页面也需相应修改，可扩展性差。<br>（2）要想可配置化，字段需从过程中取，但AJAX返回的JSON数据KEY顺序不与过程中返回字段顺序一致</p>\n<h2 id=\"原因分析\"><a href=\"#原因分析\" class=\"headerlink\" title=\"原因分析\"></a>原因分析</h2><p>fastjson在Object转JSON的时候，底层采用HashMap, 若有序，则需为LinkedHashMap, 查看源码发现</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public JSONObject(int initialCapacity, boolean ordered)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (ordered) &#123;</span><br><span class=\"line\">           map = new LinkedHashMap&lt;String, Object&gt;(initialCapacity);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           map = new HashMap&lt;String, Object&gt;(initialCapacity);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>可是Object如何转为JSON字符串，查看源码并没有发现转的方法，但是过程中返回的是标准的Map类型，故贴上以下代码</p>\n<h2 id=\"解决代码\"><a href=\"#解决代码\" class=\"headerlink\" title=\"解决代码\"></a>解决代码</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SerializeConfig serializeConfig = new SerializeConfig();</span><br><span class=\"line\">ObjectSerializer serializer = new SimpleDateFormatSerializer(DateUtils.format());</span><br><span class=\"line\">serializeConfig.put(Timestamp.class, serializer);</span><br><span class=\"line\">serializeConfig.put(java.sql.Date.class, serializer);</span><br><span class=\"line\">serializeConfig.put(Date.class, serializer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (obj instanceof Map)&#123;</span><br><span class=\"line\">    JSONObject jsonObject = new JSONObject(16, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    jsonObject.putAll((Map) obj);</span><br><span class=\"line\">    // 输出key时是否使用双引号,默认为<span class=\"literal\">true</span></span><br><span class=\"line\">    // 是否输出值为null的字段,默认为<span class=\"literal\">false</span></span><br><span class=\"line\">    result = JSON.toJSONStringZ(jsonObject, serializeConfig, SerializerFeature.QuoteFieldNames, SerializerFeature.WriteMapNullValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["工作干货"],"tags":["工作干货"]},{"title":"Java并发机制底层实现原理之volatile","url":"http://www.shenjian.online/2019/01/10/Java并发机制底层实现原理之volatile/","content":"<p>如果一个字段被声明成volatile，Java内存模型保证所有线程看到这个变量的值是一致的。</p>\n<h1 id=\"1-实现原理\"><a href=\"#1-实现原理\" class=\"headerlink\" title=\"1. 实现原理\"></a>1. 实现原理</h1><p>有volatile修饰的变量进行写操作时会多出带有lock前缀的汇编指令，该指令在多核处理器中引发两件事情：<br>1）将当前处理器缓存行的数据写回系统内存。 通过总线锁定或缓存行锁定。<br>2）这个写回内存的操作会使其他CPU中缓存了该内存地址的数据无效。 其他处理器通过嗅探总线上传播过来的数据监测自己工作内存中缓存是否过期。过期，修改的时候则从主存中重新读取。</p>\n<h1 id=\"2-内存语义层次理解\"><a href=\"#2-内存语义层次理解\" class=\"headerlink\" title=\"2. 内存语义层次理解\"></a>2. 内存语义层次理解</h1><h2 id=\"2-1-volatile的特性\"><a href=\"#2-1-volatile的特性\" class=\"headerlink\" title=\"2.1 volatile的特性\"></a>2.1 volatile的特性</h2><p>volatile变量自身具有以下特性：</p>\n<ul>\n<li>可见性：对一个volatile变量的读，总是能看到任意线程对这个volatile变量最后的写入</li>\n<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性，如</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> v = <span class=\"number\">0L</span>;</span><br><span class=\"line\">v = <span class=\"number\">200L</span>; <span class=\"comment\">// 具有原子性</span></span><br><span class=\"line\">v++; <span class=\"comment\">// 不具有原子性</span></span><br></pre></td></tr></table></figure>\n<p>ps: JDK5开始，JSR-133内存模型只允许64位long/double型的写操作拆分为两个32位的写操作来执行，任意的读操作在JSR-133中都必须具有原子性。</p>\n<h2 id=\"2-2-volatile的写-读内存语义\"><a href=\"#2-2-volatile的写-读内存语义\" class=\"headerlink\" title=\"2.2 volatile的写-读内存语义\"></a>2.2 volatile的写-读内存语义</h2><p>写内存语义： 当写一个volatile变量时，JMM会把线程对应的本地内存的共享变量刷新到主内存<br>读内存语义： 当读一个volatile变量时，JMM会把该线程对应的本地内存置于无效，线程接下来将从主内存读取共享变量</p>\n<h2 id=\"2-3-重排序与volatile内存语义的实现\"><a href=\"#2-3-重排序与volatile内存语义的实现\" class=\"headerlink\" title=\"2.3 重排序与volatile内存语义的实现\"></a>2.3 重排序与volatile内存语义的实现</h2><h3 id=\"2-3-1-重排序简介\"><a href=\"#2-3-1-重排序简介\" class=\"headerlink\" title=\"2.3.1 重排序简介\"></a>2.3.1 重排序简介</h3><p>为了提高性能，处理器与编译器会对指令做重排序，分为3种类型：<br>1）编译器优化的重排序 不改变单线程程序语义，重新安排语句执行顺序<br>2）指令级并行的重排序 若不存在数据依赖性，处理器可以改变语句对机器指令的执行顺序<br>3）内存系统的重排序 处理器采用缓存和读、写缓冲区，使得加载与存储看上去是乱序执行</p>\n<p>1）属于编译器重排序 2)、3)属于处理器重排序。为了实现volatile内存语义，需要JMM会分别限制这两大类型的重排序。</p>\n<h3 id=\"2-3-2-volatile内存语义具体实现\"><a href=\"#2-3-2-volatile内存语义具体实现\" class=\"headerlink\" title=\"2.3.2 volatile内存语义具体实现\"></a>2.3.2 volatile内存语义具体实现</h3><p>volatile写： 前面插入StoreStore屏障(禁止该屏障前的普通写与volatile写重排序)， 后面插入StoreLoad屏障(防止volatile写与该屏障后的可能有的volatile读/写重排序)<br>volatile读： 后面首先插入一个LoadLoad(禁止该屏障后所有的普通读操作与volatile读重排序)，然后插入LoadStore屏障(禁止该屏障后所有的普通写操作与volatile读重排序)</p>\n<h1 id=\"3-使用优化\"><a href=\"#3-使用优化\" class=\"headerlink\" title=\"3. 使用优化\"></a>3. 使用优化</h1><p>JDK7并发包中新增了一个队列集合类LinkedTransferQueue, 他在使用volatile变量时，用一种追加字节的方式来优化队列的入队与出队的性能。使用追加到64字节的方式填满同一个高速缓冲行，避免头结点与尾节点加载到同一个缓存行，使头、尾节点在修改时都不会相互锁定。  </p>\n<h1 id=\"4-实际使用场景–状态变量标记\"><a href=\"#4-实际使用场景–状态变量标记\" class=\"headerlink\" title=\"4. 实际使用场景–状态变量标记\"></a>4. 实际使用场景–状态变量标记</h1><p>一般业务场景中用于 volatile static Boolean flag = true</p>\n<p>在双重检查锁定中起到防止重排序作用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SafeDoubleCheckedLocking</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Instance instance;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Instance <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 第一次检查</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">synchronized</span>(SafeDoubleCheckedLocking.class) &#123; <span class=\"comment\">// 加锁</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 第二次检查</span></span><br><span class=\"line\">\t\t\t\t\tinstance = <span class=\"keyword\">new</span> Instance(); <span class=\"comment\">// 该步骤有三小步 (1)分配对象的内存空间 (2)初始化对象 (3)设置instance指向刚分配的内存地址 volatile就是防止(2)与(3)重排序</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ps: CPU术语定义<br>内存屏障： 是一组处理器指令，用于实现对内存操作的顺序控制<br>缓存行： CPU高速缓存中可以分配的最小存储单位，处理器填写缓存行时会加载整个缓存行<br>数据依赖性： 如果两个操作同时访问一个变量，其中一个操作为写操作，则这两个操作存在数据依赖性</p>\n","categories":["多线程"],"tags":["多线程","面试"]},{"title":"分类","url":"http://www.shenjian.online/category/index.html","content":"","categories":[],"tags":[]},{"title":"友链","url":"http://www.shenjian.online/link/index.html","content":"<p>link:</p>\n<ul>\n<li>name: 鱼鱼的博客<br>info: hyperactive fish<br>url: <a href=\"https://www.fishmaple.cn/\" target=\"_blank\" rel=\"noopener\">https://www.fishmaple.cn/</a><br>avatar: <a href=\"https://www.fishmaple.cn/pics/logo-fish-small.png\" target=\"_blank\" rel=\"noopener\">https://www.fishmaple.cn/pics/logo-fish-small.png</a></li>\n</ul>\n","categories":[],"tags":[]},{"title":"标签","url":"http://www.shenjian.online/tag/index.html","content":"","categories":[],"tags":[]},{"title":"搜索","url":"http://www.shenjian.online/search/index.html","content":"","categories":[],"tags":[]}]